AGENT: architecture
FINDINGS:
- FINDING: Agent and asset-type classification reverse-engineered from file paths instead of derived from driver config
  SEVERITY: medium
  FILES: src/commands/list-detail.ts:35-48, src/commands/remove.ts:38-43
  DESCRIPTION: Two separate locations reconstruct the agent-to-directory and asset-type-to-directory mapping by pattern-matching on file path strings. `list-detail.ts:deriveAgent` hardcodes `.claude/` -> `claude` and `.agents/` -> `codex`; `classifyAssetType` uses `filePath.includes("/skills/")` substring matching. `remove.ts:classifyFile` uses the same substring approach. These are the inverse of the driver's `getTargetDir` configuration, but implemented independently via string heuristics. If a driver's target directory changes (e.g., codex moves from `.agents/` to `.codex/`), or a new agent is added, these functions silently produce wrong results. The `includes()` approach is also fragile -- a path like `.claude/skills/my-agents-toolkit/` would match both `/skills/` and `/agents/`. The driver registry already owns the authoritative mapping from (agent, asset-type) to directory prefix; the reverse mapping should be derived from it, not independently guessed from path substrings.
  RECOMMENDATION: Add a utility in the driver layer (e.g., `identifyFileOwnership(filePath: string): { agentId: AgentId; assetType: AssetType } | null`) that iterates registered drivers and their `getTargetDir` results to find which agent/asset-type pair owns a given path prefix. Use `startsWith` against actual driver target dirs rather than `includes` against hardcoded substrings. Both `list-detail.ts` and `remove.ts` can import this single function, eliminating the hardcoded inverse mapping and the substring false-positive risk.

- FINDING: `CollectionPluginResult` in summary.ts weakens `detectedType` to `{ type: string }` instead of reusing the concrete `DetectedType` union
  SEVERITY: low
  FILES: src/summary.ts:86-93, src/commands/add.ts:301-308
  DESCRIPTION: `add.ts` defines `PluginInstallResult` with `detectedType?: DetectedType` (the concrete discriminated union from `type-detection.ts`). `summary.ts` defines a near-identical `CollectionPluginResult` interface but declares `detectedType?: { type: string }`. The only consumer of `detectedType` in summary.ts is line 113: `r.detectedType?.type === "plugin"`. Using `{ type: string }` means a typo like `"pluginn"` would be a valid value at compile time and the comparison would silently return false. The two interfaces share the same shape -- `pluginName`, `status`, `copiedFiles`, `assetCountsByAgent`, `detectedType`, `errorMessage` -- but are independently defined with this one field weakened.
  RECOMMENDATION: Import `DetectedType` from `type-detection.ts` in summary.ts and use it for the `detectedType` field. Alternatively, extract the shared `PluginInstallResult` interface into a common module that both `add.ts` and `summary.ts` import, ensuring the type stays aligned.

SUMMARY: The architecture has improved significantly over five cycles. Previous high and medium severity issues (untyped interfaces, duplicated clone URL logic, missing mapCloneFailure, duplicated update orchestration) are all addressed. The remaining medium-severity issue is agent/asset classification being reverse-engineered from file path substrings rather than derived from the driver registry, which creates fragile inverse mappings that would silently break if driver configuration changes.
