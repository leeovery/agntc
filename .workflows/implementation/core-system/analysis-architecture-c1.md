AGENT: architecture
FINDINGS:
- FINDING: AgentDriver.getTargetDir accepts untyped string when asset types are a known finite set
  SEVERITY: medium
  FILES: src/drivers/types.ts:5, src/drivers/claude-driver.ts:30, src/drivers/codex-driver.ts:23
  DESCRIPTION: The AgentDriver interface declares `getTargetDir(assetType: string): string | null`. The valid asset types are already defined as a const tuple in `src/type-detection.ts` (`ASSET_DIRS = ["skills", "agents", "hooks"] as const`), and every call site passes one of these known literals ("skills", "agents", "hooks"). Using `string` bypasses compile-time validation, meaning a typo like `getTargetDir("skill")` silently returns null instead of producing a type error. The driver implementations use `Record<string, string>` for their internal lookup tables, reinforcing the untyped path. This is the kind of signature the code-quality guidelines flag under "Concrete Over Abstract" -- the concrete types are known at design time.
  RECOMMENDATION: Define `type AssetType = typeof ASSET_DIRS[number]` (i.e., `"skills" | "agents" | "hooks"`) and use it as the parameter type for `getTargetDir(assetType: AssetType)`. Update driver implementations' internal `TARGET_DIRS` records to use `Partial<Record<AssetType, string>>`. This catches invalid asset type strings at compile time rather than silently returning null.

- FINDING: ManifestEntry.agents and AgntcConfig.agents typed as string[] instead of AgentId[]
  SEVERITY: medium
  FILES: src/manifest.ts:9, src/config.ts:5, src/commands/add.ts:116, src/commands/add.ts:223, src/commands/update.ts:194-195
  DESCRIPTION: Both `ManifestEntry.agents` and `AgntcConfig.agents` are declared as `string[]`, while the system has a well-defined `AgentId = "claude" | "codex"` union type. This forces `as AgentId[]` casts at every boundary where these values flow into agent-typed code (at least 12 occurrences across add.ts, update.ts, list-update-action.ts, list-change-version-action.ts). The casts are unsound -- nothing prevents a string[] containing "invalid-agent" from being cast to AgentId[]. The code-quality guidelines say "Untyped parameters when concrete types are known at design time" is an anti-pattern, and "runtime type checks inside implementations signal the signature should be more specific." The config reader (`readConfig`) already filters to known agents, and the manifest is only written by the tool itself, so both can safely declare `AgentId[]`.
  RECOMMENDATION: Change both interfaces to use `AgentId[]`. In `readConfig`, the validation loop already filters to known agents, so its return type naturally becomes `AgntcConfig` with `agents: AgentId[]`. This eliminates all `as AgentId[]` casts downstream.

- FINDING: Nuke-then-clone ordering in update creates a window of data loss
  SEVERITY: high
  FILES: src/commands/update.ts:199, src/commands/update.ts:455, src/commands/list-update-action.ts:132, src/commands/list-change-version-action.ts:144
  DESCRIPTION: In `runGitUpdate` (line 199), the sequence is: clone succeeds -> nuke existing files -> copy new files. However, in `processGitUpdateForAll` (line 455) and the list action files, the same pattern applies. The problem is that if the copy step fails after nuke (e.g., disk full, permission error), the user's installed files are gone with no recovery path. The spec explicitly states "Rollback to clean state" for partial copy failures, but a failed rollback after nuke leaves the plugin in a worse state than before the update -- zero files instead of the old version. The `runGitUpdate` single-plugin path does clone-then-nuke which is correct in sequencing, but the copy operations use rollback that only deletes newly-copied files -- it cannot restore the nuked originals. This is a latent data-loss risk acknowledged in the spec as an edge case for cross-plugin overwrites but not for same-plugin update failures.
  RECOMMENDATION: The most robust fix is to nuke only after verifying copy succeeded to a staging area, then atomically swap. A simpler mitigation: before nuking, record the list of files that will be removed, and if copy fails, log a clear message like "Update failed after removing old files. Run `npx agntc update {key}` to retry." so the user knows the plugin needs reinstallation. This is the minimum viable safety net within the current nuke-and-reinstall architecture.

- FINDING: update-check.ts derives clone URL from manifest key with hardcoded github.com assumption
  SEVERITY: medium
  FILES: src/update-check.ts:35-39, src/commands/update.ts:37-52, src/commands/list-update-action.ts:35-46
  DESCRIPTION: The `deriveCloneUrl` function in `update-check.ts` (line 35) constructs `https://github.com/${owner}/${repo}.git` from the manifest key. The same pattern is repeated via `buildParsedSource` in `update.ts` and `list-update-action.ts`, which creates a `github-shorthand` ParsedSource. This means any plugin originally installed via HTTPS URL from GitLab/Bitbucket/etc., or via SSH, will have its update checks and re-clones pointed at github.com instead of the original host. The manifest stores `owner/repo` as the key for all git sources (the host is discarded during key derivation in source-parser.ts), so the original host is lost. This will silently fail for non-GitHub repos or hit the wrong repo if the same owner/repo exists on GitHub.
  RECOMMENDATION: Store the original clone URL in the manifest entry (e.g., `cloneUrl: string | null`). Use it for update checks and re-clones instead of reconstructing from the key. This is a single field addition to ManifestEntry and eliminates host assumptions throughout the update pipeline.

- FINDING: No integration tests for cross-module workflows
  SEVERITY: medium
  FILES: tests/commands/add.test.ts, tests/commands/update.test.ts, tests/commands/remove.test.ts
  DESCRIPTION: All command-level tests mock every dependency, verifying orchestration logic in isolation. There are no tests that exercise the real interaction between, for example: `computeIncomingFiles` -> `checkFileCollisions` -> `resolveCollisions` -> `copyPluginAssets` -> `writeManifest`. The cli.test.ts only tests CLI argument parsing and help output. This means seam defects (e.g., `computeIncomingFiles` producing paths in a format that `checkFileCollisions` doesn't match against, or `copyPluginAssets` producing a different path format than what was predicted) would go undetected. The spec describes a multi-step pipeline with precise path-matching semantics that are only validated when modules run together against a real filesystem.
  RECOMMENDATION: Add a small set of filesystem-based integration tests that exercise the add/update/remove pipelines end-to-end against temp directories. These would use real file operations but mock only the interactive prompts (clack) and git operations (network). Even 3-5 scenarios (bare skill add, plugin add with collision, update with agent drop, remove) would catch path-format mismatches and manifest consistency issues.

SUMMARY: The implementation has clean module boundaries and good separation of concerns. The main structural issues are: type safety erosion at key interfaces (AgentDriver.getTargetDir and ManifestEntry.agents use untyped strings where concrete types exist), a hardcoded github.com assumption that breaks non-GitHub update flows, a nuke-before-copy ordering that creates data loss risk on copy failure, and no integration tests to verify cross-module path format consistency.
