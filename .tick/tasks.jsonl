{"id":"tick-20aa13","title":"Core System","status":"open","priority":2,"created":"2026-02-18T20:38:55Z","updated":"2026-02-18T20:38:55Z"}
{"id":"tick-dea5ee","title":"Phase 1: Walking Skeleton - Add a Bare Skill from Git","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-18T20:39:00Z","updated":"2026-02-18T20:39:00Z"}
{"id":"tick-0ba43c","title":"cs-1-1: Project Scaffolding and CLI Entry Point","status":"open","priority":2,"description":"**Problem**: The agntc repo has no TypeScript setup, no build tooling, no test framework, and no CLI entry point. Every subsequent task depends on this.\n\n**Solution**: Scaffold a TypeScript project with tsup for bundling, Vitest for testing, and Commander for CLI argument parsing. Create the bin entry point with add and list as subcommand stubs.\n\n**Outcome**: A buildable, testable TypeScript project where npx agntc add owner/repo and npx agntc list print placeholders, help works, unknown commands error, and Vitest runs.\n\n**Do**:\n1. Create tsconfig.json — ES2022/NodeNext, strict mode, rootDir src/, outDir dist/\n2. Install deps: typescript, tsup, vitest (dev); commander, @clack/prompts (runtime)\n3. Update package.json — type: module, bin: { \"agntc\": \"dist/cli.js\" }, scripts for build/test\n4. Create tsup.config.ts — entry src/cli.ts, format esm, target node20, dts, shebang banner\n5. Create src/cli.ts — Commander program with add (required \u003csource\u003e arg) and list subcommands\n6. Create src/index.ts — empty barrel export\n7. Create src/commands/add.ts — stub with @clack/prompts intro/outro\n8. Create src/commands/list.ts — stub with @clack/prompts intro/outro\n9. Create vitest.config.ts\n10. Create tests/cli.test.ts — smoke tests for CLI wiring\n11. Ensure .gitignore covers dist/ and node_modules/\n12. Build and verify\n\n**Acceptance Criteria**:\n- npm run build produces dist/cli.js with shebang, executable\n- npx agntc --help shows help listing add and list\n- npx agntc add owner/repo exits 0 with placeholder output\n- npx agntc add (no source) exits non-zero\n- npx agntc list exits 0 with placeholder output\n- npx agntc (no command) shows help\n- npx agntc unknown-command exits non-zero\n- npm test runs vitest, all tests pass\n- package.json bin field points to dist/cli.js\n- TypeScript strict mode enabled\n\n**Tests**:\n- npx agntc --help includes add and list in output\n- npx agntc add \u003csource\u003e exits 0 and outputs placeholder message\n- npx agntc add with no source argument exits non-zero\n- npx agntc list exits 0 and outputs placeholder message\n- npx agntc with no arguments shows help\n- npx agntc with unknown command exits non-zero\n- build produces dist/cli.js with node shebang\n\n**Context**: Naming spec mandates agntc as CLI command and package name. Spec requires Commander + @clack/prompts. Phase 1 only stubs add and list — remove and update come later.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:39:09Z","updated":"2026-02-18T20:39:09Z"}
{"id":"tick-be4c96","title":"cs-1-2: Source Argument Parsing (GitHub Shorthand)","status":"open","priority":2,"description":"**Problem**: The add command receives a raw string but needs structured data (owner, repo, ref) for downstream operations (clone, manifest key).\n\n**Solution**: Create a parseSource function returning a typed ParsedSource object with a type: \"github-shorthand\" discriminant for future union extension in Phase 3.\n\n**Outcome**: Tested parser that extracts owner, repo, and optional ref from owner/repo and owner/repo@ref, rejects malformed input with descriptive errors.\n\n**Do**:\n1. Create src/source-parser.ts with ParsedSource type (type, owner, repo, ref, manifestKey)\n2. Implement parseSource(raw) — trim, split on first @, split on /, validate segments\n3. Throw descriptive errors for: missing owner/repo, empty owner, empty repo, empty ref, extra slashes, empty string\n4. Create tests/source-parser.test.ts with all edge case tests\n5. Wire into src/commands/add.ts — call parseSource on source arg\n\n**Acceptance Criteria**:\n- parseSource(\"owner/repo\") returns { type: \"github-shorthand\", owner: \"owner\", repo: \"repo\", ref: null, manifestKey: \"owner/repo\" }\n- parseSource(\"owner/repo@v2.0\") returns ref: \"v2.0\"\n- parseSource(\"owner/repo@main\") returns ref: \"main\"\n- parseSource(\"repo\") throws with descriptive error (missing owner)\n- parseSource(\"/repo\") throws with descriptive error (empty owner)\n- parseSource(\"owner/\") throws with descriptive error (empty repo)\n- parseSource(\"owner/repo@\") throws with descriptive error (empty ref)\n- parseSource(\"a/b/c\") throws with descriptive error (extra slashes)\n- parseSource(\"\") throws with descriptive error\n- The add command calls parseSource on its source argument\n\n**Tests**:\n- parses owner/repo into structured source with null ref\n- parses owner/repo@ref with tag ref\n- parses owner/repo@ref with branch name ref\n- returns manifestKey as owner/repo\n- trims whitespace from input\n- throws for missing owner segment (bare repo name)\n- throws for empty owner (leading slash)\n- throws for empty repo (trailing slash)\n- throws for empty ref after @ symbol\n- throws for extra slashes in path (three segments)\n- throws for empty string input\n- handles ref containing special characters (e.g., v2.0.0-beta.1)\n- splits on first @ only — ref can contain @ characters\n\n**Context**: Phase 1 implements GitHub shorthand only. The ParsedSource type uses a discriminant so Phase 3 can extend it as a union type. Manifest key is owner/repo; collection suffixes appended downstream. ref: null means HEAD.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:46:55Z","updated":"2026-02-18T20:46:55Z"}
{"id":"tick-3dff00","title":"cs-1-3: Git Shallow Clone","status":"open","priority":2,"description":"**Problem**: After parsing the source argument, the tool needs to fetch repo contents to a local temp directory before reading agntc.json or copying assets. No clone infrastructure exists yet.\n\n**Solution**: Create a cloneSource function that takes a ParsedSource, creates a temp directory, performs a shallow git clone (depth 1), and returns the temp dir path + resolved commit SHA. Retries transient failures, aborts immediately on auth errors, cleans up temp dir on failure.\n\n**Outcome**: Tested clone module that shallow-clones GitHub repos to temp dirs, retries transient failures up to 3 times, aborts on auth errors, cleans up on failure, returns temp path + commit SHA on success.\n\n**Do**:\n1. Create src/git-clone.ts with CloneResult type ({ tempDir, commit }) and cloneSource(parsed: ParsedSource) async function\n2. Build clone URL as https://github.com/{owner}/{repo}.git from ParsedSource fields\n3. Create temp dir using fs.mkdtemp(os.tmpdir() + '/agntc-')\n4. Shell out to git clone --depth 1 [--branch ref] \u003curl\u003e \u003ctempDir\u003e via child_process.execFile. ref null = omit --branch (HEAD). ref provided = --branch \u003cref\u003e.\n5. On success, resolve commit SHA via git -C \u003ctempDir\u003e rev-parse HEAD\n6. Return { tempDir, commit }\n7. Retry logic: max 3 attempts. Auth errors (exit 128 + stderr contains Authentication, Permission denied, could not read Username/Password) throw immediately. Otherwise retry with delay (500ms, 1000ms).\n8. On final failure, clean up temp dir (fs.rm recursive+force) before throwing\n9. Create tests/git-clone.test.ts — mock execFile for retry/auth/URL/ref/cleanup tests. Optional integration test behind RUN_INTEGRATION=1.\n10. Export cleanupTempDir(path) helper for callers. Thin wrapper around fs.rm recursive+force.\n\n**Acceptance Criteria**:\n- cloneSource constructs URL as https://github.com/{owner}/{repo}.git\n- ref: null clones HEAD (no --branch flag)\n- ref: \"v2.0\" passes --branch v2.0\n- Clone uses --depth 1 (shallow)\n- Returns { tempDir, commit } where commit is 40-char hex SHA\n- Temp dir under os.tmpdir() with agntc- prefix\n- Transient failures retried up to 3 times\n- Auth failures throw immediately, no retry\n- Temp dir cleaned up on failure (retries exhausted or auth error)\n- Temp dir NOT cleaned up on success (caller responsibility)\n- cleanupTempDir removes directory recursively\n- Error messages surface underlying git error clearly\n\n**Tests**:\n- constructs correct clone URL from owner and repo\n- calls git clone with --depth 1\n- omits --branch when ref is null\n- passes --branch \u003cref\u003e when ref is provided\n- returns tempDir and 40-char commit SHA on success\n- creates temp dir with agntc- prefix\n- retries up to 3 times on transient failure then throws\n- succeeds on second attempt after transient failure\n- does not retry on auth failure (throws immediately)\n- detects auth failure from stderr patterns\n- cleans up temp dir after failure\n- does not clean up temp dir on success\n- surfaces git error message in thrown error\n- cleanupTempDir removes directory recursively\n- cleanupTempDir does not throw if dir missing\n- clone failure for nonexistent repo produces clear error\n\n**Context**: Spec says retry 3 times on transient, no retry on auth. Phase 1 = GitHub shorthand only, so URL is always https://github.com/{owner}/{repo}.git. Phase 3 extends for other hosts/formats. Caller owns cleanup on success; cloneSource owns cleanup on failure.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:48:56Z","updated":"2026-02-18T20:48:56Z"}
{"id":"tick-5024dd","title":"cs-1-4: agntc.json Validation","status":"open","priority":2,"description":"**Problem**: After cloning a repo, the tool needs to read and validate agntc.json from the repo root. No config reading or validation logic exists yet. Each validation failure mode requires a specific error message per spec. Unknown agent identifiers must warn (not error) to future-proof.\n\n**Solution**: Create a readConfig function that reads agntc.json from a given directory, parses JSON, validates schema (agents field required, non-empty array, valid identifiers), returns typed AgntcConfig. Unknown agents trigger warning callback and are filtered out. Missing file returns null (valid signal for collection detection).\n\n**Outcome**: Tested config module that reads/validates agntc.json, returns null when absent, throws descriptive errors for invalid JSON / missing agents / empty agents, warns on unknown identifiers, returns typed config on success.\n\n**Do**:\n1. Create src/config.ts with types: AgntcConfig ({ agents: string[] }), KNOWN_AGENTS ([\"claude\", \"codex\"]), ReadConfigOptions ({ onWarn? })\n2. Implement readConfig(dir, options?) — read agntc.json, parse JSON, validate agents field, filter unknown agents with warnings, return typed config or null\n3. Error messages per spec: \"Invalid agntc.json: {parse error}\", \"agents field is required\", \"agents must not be empty\"\n4. Unknown agents: warn via onWarn callback, filter out. If all unknown after filter, throw empty error.\n5. Create ConfigError class (extends Error)\n6. Create tests/config.test.ts covering all validation paths\n7. Export AgntcConfig, KNOWN_AGENTS, readConfig, ConfigError\n\n**Acceptance Criteria**:\n- Returns null when agntc.json does not exist\n- Returns { agents: [\"claude\"] } for valid config\n- Returns { agents: [\"claude\", \"codex\"] } for multi-agent config\n- Throws ConfigError with parse error for malformed JSON\n- Throws ConfigError for missing agents field\n- Throws ConfigError for empty agents array\n- Unknown agents filtered out + onWarn called\n- Returns only known agents when mix of known/unknown\n- Throws when ALL agents unknown (empty after filter)\n- KNOWN_AGENTS contains [\"claude\", \"codex\"]\n- Non-ENOENT file errors propagate as-is\n\n**Tests**:\n- returns null when agntc.json does not exist\n- parses valid config with single agent\n- parses valid config with multiple agents\n- throws ConfigError for invalid JSON (truncated)\n- throws ConfigError for invalid JSON (trailing comma)\n- throws ConfigError with parse error detail\n- throws when agents field missing entirely\n- throws when agents is empty array\n- warns for unknown agent and filters it out\n- returns known agents when mix present\n- warns once per unknown agent\n- throws when all agents unknown\n- throws when agents is not an array\n- throws when agents contains non-string elements\n- does not call onWarn when all agents known\n- propagates permission denied errors\n- reads from correct path\n\n**Context**: Spec defines agntc.json as single required config. Missing file = null (type detection uses absence for collection scanning). Naming spec confirms filename is agntc.json.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:50:30Z","updated":"2026-02-18T20:50:30Z"}
{"id":"tick-3f9f32","title":"cs-1-5: Type Detection","status":"open","priority":2,"description":"**Problem**: After reading agntc.json (or discovering its absence), the tool must determine what kind of installable it is looking at — bare skill, plugin, collection, or not an agntc repo. Downstream operations depend on this classification.\n\n**Solution**: Create a detectType function applying the spec's 3-rule cascade: (1) root has agntc.json — check asset dirs vs SKILL.md, (2) no agntc.json — scan subdirs (collection), (3) nothing — not agntc. Returns a typed discriminated union (DetectedType). All paths implemented and tested.\n\n**Outcome**: Tested type detection module classifying directories as bare-skill, plugin, collection, or not-agntc. Warns on misconfigurations.\n\n**Do**:\n1. Create src/type-detection.ts with types: ASSET_DIRS ([\"skills\", \"agents\", \"hooks\"]), DetectedType union (bare-skill, plugin with assetDirs, collection with plugins, not-agntc)\n2. Implement detectType(dir, options?) — hasConfig boolean from caller, onWarn callback\n3. Rule 1 (hasConfig=true): check asset dirs → plugin; check SKILL.md → bare-skill; neither → warn + not-agntc. Warn if SKILL.md coexists with asset dirs.\n4. Rule 2 (hasConfig=false): scan immediate subdirs for agntc.json → collection; none → not-agntc\n5. Use fs.access for existence checks\n6. Create tests/type-detection.test.ts with real temp dir fixtures\n7. Export DetectedType, ASSET_DIRS, detectType\n\n**Acceptance Criteria**:\n- Returns bare-skill when hasConfig=true, SKILL.md exists, no asset dirs\n- Returns plugin with assetDirs when asset dirs found\n- Returns collection with plugin names when subdirs have agntc.json\n- Returns not-agntc when nothing recognisable\n- Returns not-agntc with warning when hasConfig=true but no SKILL.md/asset dirs\n- Warns when SKILL.md coexists with asset dirs\n- Collection scan checks immediate subdirs only (not recursive)\n- ASSET_DIRS = [\"skills\", \"agents\", \"hooks\"]\n\n**Tests**:\n- bare-skill with SKILL.md and no asset dirs\n- bare-skill with non-asset dirs alongside SKILL.md\n- plugin with each individual asset dir\n- plugin with all three asset dirs\n- plugin warns when SKILL.md coexists with asset dirs\n- not-agntc with warning when config but nothing to install\n- collection with multiple subdirs having agntc.json\n- collection skips subdirs without agntc.json\n- not-agntc when no config and no subdirs have config\n- not-agntc for empty directory\n- collection scan ignores files\n- collection scan not recursive\n\n**Context**: Spec defines type detection as structure-based with 3 ordered rules. hasConfig avoids re-reading agntc.json. Collections are structural, not declared.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:52:07Z","updated":"2026-02-18T20:52:07Z"}
{"id":"tick-cc248f","title":"cs-1-6: Agent Driver Interface and Claude Driver","status":"open","priority":2,"description":"**Problem**: The tool needs to ask \"is this agent present?\" and \"where do assets go for this agent?\" but no driver abstraction exists. Spec mandates driver/strategy pattern so adding agents requires only a new driver + registration.\n\n**Solution**: Define AgentDriver TypeScript interface (detect + getTargetDir). Implement Claude driver. Create registry mapping agent IDs to drivers. Detection: project-level first (.claude/), system fallback (which claude, ~/.claude/). Routing: static config map.\n\n**Outcome**: Tested AgentDriver interface, Claude driver with detection/routing, registry. getDriver(\"claude\") → driver, detect(projectDir) → boolean, getTargetDir(assetType) → string | null.\n\n**Do**:\n1. Create src/drivers/types.ts — AgentDriver interface (detect, getTargetDir), AgentId type (\"claude\" | \"codex\")\n2. Create src/drivers/claude-driver.ts — detect: check .claude/ in project → which claude → ~/.claude/. getTargetDir: { skills: \".claude/skills\", agents: \".claude/agents\", hooks: \".claude/hooks\" }, null for unknown.\n3. Create src/drivers/registry.ts — DRIVER_REGISTRY mapping \"claude\" → ClaudeDriver. getDriver(id), getRegisteredAgentIds().\n4. Create tests/drivers/claude-driver.test.ts — mock fs.access and child_process for detection, direct routing tests.\n5. Create tests/drivers/registry.test.ts — registry lookup and registered IDs.\n\n**Acceptance Criteria**:\n- AgentDriver interface with detect(projectDir) and getTargetDir(assetType)\n- AgentId type as \"claude\" | \"codex\"\n- ClaudeDriver.detect: true when .claude/ in project, skips system check on project match\n- ClaudeDriver.detect: fallback to which claude, then ~/.claude/, false when all fail\n- ClaudeDriver.getTargetDir: skills → .claude/skills, agents → .claude/agents, hooks → .claude/hooks, unknown → null\n- getDriver(\"claude\") returns Claude driver\n- getRegisteredAgentIds() returns [\"claude\"]\n- No Codex driver yet (Phase 3)\n\n**Tests**:\n- detect true when .claude/ exists in project\n- detect skips system fallback on project match\n- detect true when which claude succeeds\n- detect true when ~/.claude/ exists\n- detect false when all checks fail\n- detect does not throw on check failures\n- getTargetDir returns correct paths for skills, agents, hooks\n- getTargetDir returns null for unknown asset type\n- registry returns claude driver\n- registry lists registered IDs\n- registry does not contain codex yet\n\n**Context**: Spec: driver/strategy pattern, project-level first + system fallback, cheapest check first. Claude targets per spec table. Codex added Phase 3. KNOWN_AGENTS in config.ts and AgentId in drivers must stay in sync.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:53:49Z","updated":"2026-02-18T20:53:49Z"}
{"id":"tick-e86117","title":"cs-1-7: Agent Multiselect UI","status":"open","priority":2,"description":"**Problem**: After detecting agents (cs-1-6) and reading plugin's declared agents (cs-1-4), need to let user choose which agents to install for. Spec mandates always-shown @clack/prompts multiselect with smart pre-selection and unsupported warnings.\n\n**Solution**: Create selectAgents function taking declared and detected agents, presenting @clack/prompts multiselect of all registered agents. Pre-selection = declared ∩ detected. Unsupported agents get warning hint. Zero selection = cancel.\n\n**Outcome**: Tested agent selection module showing all registered agents, pre-selecting compatible+detected, warning on unsupported, returning AgentId[] or empty on cancel.\n\n**Do**:\n1. Create src/agent-select.ts with selectAgents({ declaredAgents, detectedAgents }) → Promise\u003cAgentId[]\u003e\n2. Get all agents from getRegisteredAgentIds()\n3. Build multiselect options: value (AgentId), label, hint (warning if not declared), initialValue (true if declared AND detected)\n4. Call @clack/prompts multiselect with required: false\n5. Handle clack cancel → return []\n6. Handle zero selection → brief cancel message, return []\n7. Return selected AgentId[]\n8. Create tests/agent-select.test.ts mocking @clack/prompts multiselect\n\n**Acceptance Criteria**:\n- Always shows all registered agents regardless of compatibility\n- Pre-selection = intersection of declared and detected\n- Warning hint on agents not in declared list\n- Clack cancel returns empty array\n- Zero selection returns empty array\n- Valid selection returns AgentId[]\n\n**Tests**:\n- pre-selects declared AND detected agents\n- does not pre-select declared-only agents\n- does not pre-select detected-only agents\n- shows all registered agents\n- warning hint on undeclared agents\n- no hint on declared agents\n- returns empty on cancel\n- returns empty on zero selection\n- returns selected AgentId[] on valid selection\n- correct options shape passed to multiselect\n- handles empty declaredAgents\n- handles empty detectedAgents\n- handles all agents declared and detected\n\n**Context**: Spec: multiselect always shown, never skipped. Pre-selection = plugin declares + agent detected. Unsupported agents still shown with warning. User can always select any agent. Zero = cancel, no error. Options from registry (Phase 1: Claude only; Phase 3 adds Codex).\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:55:16Z","updated":"2026-02-18T20:55:16Z"}
{"id":"tick-601f31","title":"cs-1-8: Bare Skill File Copy","status":"open","priority":2,"description":"**Problem**: After agent selection, the tool has a cloned bare-skill repo, selected agents, and driver routing, but no copy logic. Need to copy skill files to target dirs for each agent.\n\n**Solution**: Create copyBareSkill that for each agent resolves target via getTargetDir(\"skills\"), copies source dir to {targetDir}/{skillName}/ excluding agntc.json, returns copied file paths for manifest.\n\n**Outcome**: Tested copy module that copies bare skill files to each agent's target, excludes agntc.json, creates dirs, overwrites existing, returns paths for manifest tracking.\n\n**Do**:\n1. Create src/copy-bare-skill.ts with CopyBareSkillInput and CopyBareSkillResult types\n2. For each agent: getTargetDir(\"skills\") → null = skip. Compute destDir = projectDir/targetDir/skillName. mkdir recursive. Copy all files excluding agntc.json. Track paths.\n3. Use fs.cp recursive, then rm agntc.json from dest if present\n4. Record directory paths with trailing slash for manifest consistency\n5. Create tests/copy-bare-skill.test.ts with real temp dir fixtures\n\n**Acceptance Criteria**:\n- Copies all files from source to {targetDir}/{skillName}/ per agent\n- Excludes agntc.json from copy\n- Creates destination dir recursively if missing\n- Overwrites existing destination (rm + copy for clean state)\n- Returns copiedFiles with paths relative to projectDir, trailing slash for dirs\n- Skips agents where getTargetDir returns null\n- skillName = source directory basename\n- Subdirs copied recursively\n- Empty skill dir (only agntc.json) creates empty target, returns dir path\n- Works for multiple agents independently\n\n**Tests**:\n- copies SKILL.md and references to target\n- excludes agntc.json\n- preserves subdir structure\n- creates destination dir when missing\n- overwrites existing destination\n- returns correct relative paths with trailing slash\n- skips agent when getTargetDir null\n- copies to multiple agents independently\n- handles empty skill dir\n- skillName matches source basename\n- handles deeply nested subdirs\n\n**Context**: Spec rule 4: bare skill — copy entire dir as skill named after source, exclude agntc.json. Manifest shows dir paths with trailing slashes. Phase 2 extends for multi-asset plugin copy.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:56:41Z","updated":"2026-02-18T20:56:41Z"}
{"id":"tick-aaa446","title":"cs-1-9: Manifest Creation and Write","status":"open","priority":2,"description":"**Problem**: After copying files, the tool has install metadata but nowhere to persist it. Without a manifest, remove/update/list can't know what's installed. .agntc/ may or may not exist.\n\n**Solution**: Create manifest module with readManifest, writeManifest, addEntry. readManifest reads .agntc/manifest.json or returns {} if absent. addEntry merges new entry. writeManifest creates dir + writes atomically.\n\n**Outcome**: Tested manifest module handling first install (create dir+file), subsequent installs (merge preserving existing), and reinstall (overwrite entry).\n\n**Do**:\n1. Create src/manifest.ts with ManifestEntry type (ref, commit, installedAt, agents, files) and Manifest type (Record\u003cstring, ManifestEntry\u003e)\n2. readManifest(projectDir) — read .agntc/manifest.json, return {} on ENOENT, propagate other errors\n3. writeManifest(projectDir, manifest) — mkdir -p .agntc/, JSON.stringify 2-space indent + trailing newline\n4. addEntry(manifest, key, entry) — pure function, returns new manifest with entry added/replaced\n5. Create tests/manifest.test.ts with real temp dir fixtures\n6. Export all types and functions\n\n**Acceptance Criteria**:\n- readManifest returns {} when dir or file missing\n- readManifest parses valid manifest\n- readManifest propagates non-ENOENT errors\n- writeManifest creates .agntc/ and manifest.json if missing\n- writeManifest overwrites existing file\n- writeManifest uses 2-space indent + trailing newline\n- addEntry preserves existing entries, overwrites same key\n- addEntry is pure (no mutation)\n- ManifestEntry matches spec: ref, commit, installedAt, agents, files\n- Full round-trip works\n\n**Tests**:\n- readManifest empty when dir missing\n- readManifest empty when file missing but dir exists\n- readManifest parses single and multiple entries\n- readManifest propagates permission errors\n- readManifest throws on invalid JSON\n- writeManifest creates dir and file\n- writeManifest overwrites existing\n- writeManifest formats correctly\n- addEntry to empty manifest\n- addEntry preserving existing\n- addEntry overwrites same key (reinstall)\n- addEntry doesn't mutate input\n- round-trip write then read\n- entry stores null ref for HEAD, string commit, ISO timestamp, agent array, file array\n\n**Context**: Spec: .agntc/manifest.json, flat object keyed by manifest key. Created on first install. Naming spec confirms .agntc/ directory name.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:58:03Z","updated":"2026-02-18T20:58:03Z"}
{"id":"tick-d7ffd9","title":"cs-1-10: Add Command End-to-End Integration","status":"open","priority":2,"description":"**Problem**: All components exist in isolation but nothing wires them into the add command. User can't run npx agntc add owner/repo yet.\n\n**Solution**: Replace add stub with full Phase 1 pipeline: parse → clone → config → detect type → detect agents → select → copy → manifest → summary → cleanup. @clack/prompts for UI (intro, spinner, outro). Error handling with cleanup at each step. Non-bare-skill types show \"not yet supported\" and exit cleanly.\n\n**Outcome**: npx agntc add owner/repo against a bare-skill repo works end-to-end. Errors produce clear messages + cleanup. Non-bare-skill types handled gracefully.\n\n**Do**:\n1. Rewrite src/commands/add.ts with full pipeline\n2. @clack/prompts intro/outro, spinner for clone+copy\n3. Parse source → on error: cancel message, exit 1\n4. Clone → spinner, on error: git error message, cleanup, exit 1\n5. Read config → null: \"Collections not yet supported\", cleanup, exit 0. ConfigError: message, cleanup, exit 1\n6. Detect type → bare-skill: continue. plugin: \"not yet supported\", exit 0. not-agntc: warning, exit 0\n7. Detect agents → getRegisteredAgentIds + detect each\n8. Agent multiselect → empty: \"Cancelled\", cleanup, exit 0\n9. Copy bare skill → spinner, on error: cleanup, exit 1\n10. Write manifest → readManifest, addEntry, writeManifest. On error: cleanup, exit 1\n11. Summary → \"Installed {key}@{ref}\" with per-agent counts\n12. Cleanup → always in finally block, swallow cleanup errors\n13. Create tests/commands/add.test.ts mocking all deps\n\n**Acceptance Criteria**:\n- Full happy path works: parse → clone → config → detect → select → copy → manifest → summary → cleanup\n- @clack/prompts intro/outro and spinners shown\n- Errors at each step: clear message, cleanup, exit 1\n- Null config (collection) → not-yet-supported, cleanup, exit 0\n- Plugin type → not-yet-supported, cleanup, exit 0\n- Empty agent selection → cancelled, cleanup, exit 0\n- Summary shows key+ref and per-agent skill count\n- Temp dir cleaned in ALL paths (success, error, cancel)\n- Warnings forwarded to clack.log.warn\n- process.cwd() used as project dir\n\n**Tests**:\n- full happy path integration\n- intro/outro shown\n- spinners during clone and copy\n- error on invalid source (no clone attempted)\n- error + cleanup on clone failure\n- error + cleanup on invalid config\n- not-yet-supported for null config\n- not-yet-supported for plugin type\n- warning for not-agntc\n- forwards warnings to clack\n- detect called on all registered agents\n- correct args to selectAgents\n- cancel on empty selection + cleanup\n- correct args to copyBareSkill\n- error + cleanup on copy failure\n- reads existing manifest before adding\n- correct manifest entry fields\n- error + cleanup on manifest write failure\n- summary with key, ref, per-agent count\n- cleanup on success, error, and cancel\n- cleanup errors swallowed\n- skillName from parsed.repo\n\n**Context**: Capstone task of Phase 1. Wires components into spec's add flow. Phase 1 scope: bare-skill + GitHub shorthand only. Brackets deferred: collection select, reinstall, collision check, conflict check (Phases 2-3).\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T21:00:00Z","updated":"2026-02-18T21:00:00Z"}
{"id":"tick-15542a","title":"cs-1-11: List Command (Minimal)","status":"open","priority":2,"description":"**Problem**: No way for users to see installed plugins. Manifest exists on disk but nothing reads and displays it.\n\n**Solution**: Implement list command to read manifest via readManifest (cs-1-9) and display formatted table via @clack/prompts. Minimal Phase 1 version — no update checks, no detail view, no inline actions.\n\n**Outcome**: npx agntc list shows installed plugins with key, ref, agents, install date. Handles empty/missing/malformed manifest.\n\n**Do**:\n1. Replace list stub in src/commands/list.ts\n2. readManifest(process.cwd())\n3. Empty manifest: \"No plugins installed. Run npx agntc add owner/repo to get started.\" via outro, exit 0\n4. Entries: intro(\"Installed plugins\"), display each with key, version info, agents, date, outro\n5. Version display: @{ref} when set, \"HEAD\" when ref null + commit exists, \"local\" when both null\n6. Agents: comma-separated\n7. Malformed manifest: catch error, \"Failed to read manifest: {error}\", exit 1\n8. Create tests/commands/list.test.ts\n\n**Acceptance Criteria**:\n- Reads manifest from process.cwd()\n- Empty/missing manifest shows spec's empty state message, exits 0\n- Displays each plugin with key, ref, agents, date\n- Ref shown as @tag, HEAD, or local appropriately\n- Malformed manifest shows error, exits 1\n- @clack/prompts for all output\n- No update checks, spinners, or interactivity\n\n**Tests**:\n- empty state for empty manifest\n- empty state for missing manifest\n- single plugin display\n- multiple plugins display\n- ref as tag (@v2.1.6)\n- ref as branch (@main)\n- HEAD when ref null + commit exists\n- local when both null\n- comma-separated agents\n- single agent without comma\n- error on malformed JSON\n- calls readManifest with cwd\n- uses clack intro/outro\n- exits 0 on success and empty\n- exits 1 on error\n\n**Context**: Spec empty state text: \"No plugins installed. Run npx agntc add owner/repo to get started.\" Phase 5 adds full dashboard. Phase 1 list is read-only display only.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T21:01:34Z","updated":"2026-02-18T21:01:34Z"}
