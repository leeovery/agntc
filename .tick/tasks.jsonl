{"id":"tick-20aa13","title":"Core System","status":"open","priority":2,"created":"2026-02-18T20:38:55Z","updated":"2026-02-18T20:38:55Z"}
{"id":"tick-dea5ee","title":"Phase 1: Walking Skeleton - Add a Bare Skill from Git","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-18T20:39:00Z","updated":"2026-02-18T20:39:00Z"}
{"id":"tick-0ba43c","title":"cs-1-1: Project Scaffolding and CLI Entry Point","status":"done","priority":2,"description":"**Problem**: The agntc repo has no TypeScript setup, no build tooling, no test framework, and no CLI entry point. Every subsequent task depends on this.\n\n**Solution**: Scaffold a TypeScript project with tsup for bundling, Vitest for testing, and Commander for CLI argument parsing. Create the bin entry point with add and list as subcommand stubs.\n\n**Outcome**: A buildable, testable TypeScript project where npx agntc add owner/repo and npx agntc list print placeholders, help works, unknown commands error, and Vitest runs.\n\n**Do**:\n1. Scaffold TypeScript project: tsconfig.json (ES2022/NodeNext, strict), package.json (type: module, bin: dist/cli.js, build/test scripts), tsup.config.ts (esm, node20, dts, shebang), vitest.config.ts, .gitignore (dist/, node_modules/)\n2. Install dependencies: typescript, tsup, vitest (dev); commander, @clack/prompts (runtime)\n3. Create src/cli.ts with Commander program: add (required `\u003csource\u003e` arg) and list subcommands\n4. Create src/commands/add.ts and src/commands/list.ts as stubs with @clack/prompts intro/outro\n5. Create tests/cli.test.ts with smoke tests for CLI wiring, build and verify\n\n**Acceptance Criteria**:\n- npm run build produces dist/cli.js with shebang, executable\n- npx agntc --help shows help listing add and list\n- npx agntc add owner/repo exits 0 with placeholder output\n- npx agntc add (no source) exits non-zero\n- npx agntc list exits 0 with placeholder output\n- npx agntc (no command) shows help\n- npx agntc unknown-command exits non-zero\n- npm test runs vitest, all tests pass\n- package.json bin field points to dist/cli.js\n- TypeScript strict mode enabled\n\n**Tests**:\n- npx agntc --help includes add and list in output\n- npx agntc add \u003csource\u003e exits 0 and outputs placeholder message\n- npx agntc add with no source argument exits non-zero\n- npx agntc list exits 0 and outputs placeholder message\n- npx agntc with no arguments shows help\n- npx agntc with unknown command exits non-zero\n- build produces dist/cli.js with node shebang\n\n**Context**: Naming spec mandates agntc as CLI command and package name. Spec requires Commander + @clack/prompts. Phase 1 only stubs add and list — remove and update come later.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:39:09Z","updated":"2026-02-19T17:58:18Z","closed":"2026-02-19T17:58:18Z"}
{"id":"tick-be4c96","title":"cs-1-2: Source Argument Parsing (GitHub Shorthand)","status":"done","priority":2,"description":"**Problem**: The add command receives a raw string but needs structured data (owner, repo, ref) for downstream operations (clone, manifest key).\n\n**Solution**: Create a parseSource function returning a typed ParsedSource object with a type: \"github-shorthand\" discriminant for future union extension in Phase 3.\n\n**Outcome**: Tested parser that extracts owner, repo, and optional ref from owner/repo and owner/repo@ref, rejects malformed input with descriptive errors.\n\n**Do**:\n1. Create src/source-parser.ts with ParsedSource type (type, owner, repo, ref, manifestKey)\n2. Implement parseSource(raw) — trim, split on first @, split on /, validate segments\n3. Throw descriptive errors for: missing owner/repo, empty owner, empty repo, empty ref, extra slashes, empty string\n4. Create tests/source-parser.test.ts with all edge case tests\n5. Wire into src/commands/add.ts — call parseSource on source arg\n\n**Acceptance Criteria**:\n- parseSource(\"owner/repo\") returns { type: \"github-shorthand\", owner: \"owner\", repo: \"repo\", ref: null, manifestKey: \"owner/repo\" }\n- parseSource(\"owner/repo@v2.0\") returns ref: \"v2.0\"\n- parseSource(\"owner/repo@main\") returns ref: \"main\"\n- parseSource(\"repo\") throws with descriptive error (missing owner)\n- parseSource(\"/repo\") throws with descriptive error (empty owner)\n- parseSource(\"owner/\") throws with descriptive error (empty repo)\n- parseSource(\"owner/repo@\") throws with descriptive error (empty ref)\n- parseSource(\"a/b/c\") throws with descriptive error (extra slashes)\n- parseSource(\"\") throws with descriptive error\n- The add command calls parseSource on its source argument\n\n**Tests**:\n- parses owner/repo into structured source with null ref\n- parses owner/repo@ref with tag ref\n- parses owner/repo@ref with branch name ref\n- returns manifestKey as owner/repo\n- trims whitespace from input\n- throws for missing owner segment (bare repo name)\n- throws for empty owner (leading slash)\n- throws for empty repo (trailing slash)\n- throws for empty ref after @ symbol\n- throws for extra slashes in path (three segments)\n- throws for empty string input\n- handles ref containing special characters (e.g., v2.0.0-beta.1)\n- splits on first @ only — ref can contain @ characters\n\n**Context**: Phase 1 implements GitHub shorthand only. The ParsedSource type uses a discriminant so Phase 3 can extend it as a union type. Manifest key is owner/repo; collection suffixes appended downstream. ref: null means HEAD.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:46:55Z","updated":"2026-02-19T18:05:31Z","closed":"2026-02-19T18:05:31Z"}
{"id":"tick-3dff00","title":"cs-1-3: Git Shallow Clone","status":"done","priority":2,"description":"**Problem**: After parsing the source argument, the tool needs to fetch repo contents to a local temp directory before reading agntc.json or copying assets. No clone infrastructure exists yet.\n\n**Solution**: Create a cloneSource function that takes a ParsedSource, creates a temp directory, performs a shallow git clone (depth 1), and returns the temp dir path + resolved commit SHA. Retries transient failures, aborts immediately on auth errors, cleans up temp dir on failure.\n\n**Outcome**: Tested clone module that shallow-clones GitHub repos to temp dirs, retries transient failures up to 3 times, aborts on auth errors, cleans up on failure, returns temp path + commit SHA on success.\n\n**Do**:\n1. Create src/git-clone.ts with CloneResult type ({ tempDir, commit }) and cloneSource(parsed: ParsedSource) async function\n2. Build clone URL as https://github.com/{owner}/{repo}.git from ParsedSource fields\n3. Create temp dir using fs.mkdtemp(os.tmpdir() + '/agntc-')\n4. Shell out to git clone --depth 1 [--branch ref] \u003curl\u003e \u003ctempDir\u003e via child_process.execFile. ref null = omit --branch (HEAD). ref provided = --branch \u003cref\u003e.\n5. On success, resolve commit SHA via git -C \u003ctempDir\u003e rev-parse HEAD\n6. Return { tempDir, commit }\n7. Retry logic: max 3 attempts. Auth errors (exit 128 + stderr contains Authentication, Permission denied, could not read Username/Password) throw immediately. Otherwise retry with delay (500ms, 1000ms).\n8. On final failure, clean up temp dir (fs.rm recursive+force) before throwing\n9. Create tests/git-clone.test.ts — mock execFile for retry/auth/URL/ref/cleanup tests. Optional integration test behind RUN_INTEGRATION=1.\n10. Export cleanupTempDir(path) helper for callers. Thin wrapper around fs.rm recursive+force.\n\n**Acceptance Criteria**:\n- cloneSource constructs URL as https://github.com/{owner}/{repo}.git\n- ref: null clones HEAD (no --branch flag)\n- ref: \"v2.0\" passes --branch v2.0\n- Clone uses --depth 1 (shallow)\n- Returns { tempDir, commit } where commit is 40-char hex SHA\n- Temp dir under os.tmpdir() with agntc- prefix\n- Transient failures retried up to 3 times\n- Auth failures throw immediately, no retry\n- Temp dir cleaned up on failure (retries exhausted or auth error)\n- Temp dir NOT cleaned up on success (caller responsibility)\n- cleanupTempDir removes directory recursively\n- Error messages surface underlying git error clearly\n\n**Tests**:\n- constructs correct clone URL from owner and repo\n- calls git clone with --depth 1\n- omits --branch when ref is null\n- passes --branch \u003cref\u003e when ref is provided\n- returns tempDir and 40-char commit SHA on success\n- creates temp dir with agntc- prefix\n- retries up to 3 times on transient failure then throws\n- succeeds on second attempt after transient failure\n- does not retry on auth failure (throws immediately)\n- detects auth failure from stderr patterns\n- cleans up temp dir after failure\n- does not clean up temp dir on success\n- surfaces git error message in thrown error\n- cleanupTempDir removes directory recursively\n- cleanupTempDir does not throw if dir missing\n- clone failure for nonexistent repo produces clear error\n\n**Context**: Spec says retry 3 times on transient, no retry on auth. Phase 1 = GitHub shorthand only, so URL is always https://github.com/{owner}/{repo}.git. Phase 3 extends for other hosts/formats. Caller owns cleanup on success; cloneSource owns cleanup on failure. Git is a runtime prerequisite — the tool should surface a clear error if git is not found on the system.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:48:56Z","updated":"2026-02-19T18:52:27Z","closed":"2026-02-19T18:52:27Z"}
{"id":"tick-5024dd","title":"cs-1-4: agntc.json Validation","status":"done","priority":2,"description":"**Problem**: After cloning a repo, the tool needs to read and validate agntc.json from the repo root. No config reading or validation logic exists yet. Each validation failure mode requires a specific error message per spec. Unknown agent identifiers must warn (not error) to future-proof.\n\n**Solution**: Create a readConfig function that reads agntc.json from a given directory, parses JSON, validates schema (agents field required, non-empty array, valid identifiers), returns typed AgntcConfig. Unknown agents trigger warning callback and are filtered out. Missing file returns null (valid signal for collection detection).\n\n**Outcome**: Tested config module that reads/validates agntc.json, returns null when absent, throws descriptive errors for invalid JSON / missing agents / empty agents, warns on unknown identifiers, returns typed config on success.\n\n**Do**:\n1. Create src/config.ts with types: AgntcConfig ({ agents: string[] }), KNOWN_AGENTS ([\"claude\", \"codex\"]), ReadConfigOptions ({ onWarn? })\n2. Implement readConfig(dir, options?) — read agntc.json, parse JSON, validate agents field, filter unknown agents with warnings, return typed config or null\n3. Error messages per spec: \"Invalid agntc.json: {parse error}\", \"agents field is required\", \"agents must not be empty\"\n4. Unknown agents: warn via onWarn callback, filter out. Return only known agents.\n5. Create ConfigError class (extends Error)\n6. Create tests/config.test.ts covering all validation paths\n7. Export AgntcConfig, KNOWN_AGENTS, readConfig, ConfigError\n\n**Acceptance Criteria**:\n- Returns null when agntc.json does not exist\n- Returns { agents: [\"claude\"] } for valid config\n- Returns { agents: [\"claude\", \"codex\"] } for multi-agent config\n- Throws ConfigError with parse error for malformed JSON\n- Throws ConfigError for missing agents field\n- Throws ConfigError for empty agents array\n- Unknown agents filtered out + onWarn called\n- Returns only known agents when mix of known/unknown\n- Returns empty known agents array when all agents unknown (downstream handles no-valid-agents scenario)\n- KNOWN_AGENTS contains [\"claude\", \"codex\"]\n- Non-ENOENT file errors propagate as-is\n\n**Tests**:\n- returns null when agntc.json does not exist\n- parses valid config with single agent\n- parses valid config with multiple agents\n- throws ConfigError for invalid JSON (truncated)\n- throws ConfigError for invalid JSON (trailing comma)\n- throws ConfigError with parse error detail\n- throws when agents field missing entirely\n- throws when agents is empty array\n- warns for unknown agent and filters it out\n- returns known agents when mix present\n- warns once per unknown agent\n- returns empty known agents when all unknown (warns for each)\n- does not call onWarn when all agents known\n- propagates permission denied errors\n- reads from correct path\n\n**Context**: Spec defines agntc.json as single required config. Missing file = null (type detection uses absence for collection scanning). Naming spec confirms filename is agntc.json.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:50:30Z","updated":"2026-02-19T21:40:10Z","closed":"2026-02-19T21:40:10Z"}
{"id":"tick-3f9f32","title":"cs-1-5: Type Detection","status":"done","priority":2,"description":"**Problem**: After reading agntc.json (or discovering its absence), the tool must determine what kind of installable it is looking at — bare skill, plugin, collection, or not an agntc repo. Downstream operations depend on this classification.\n\n**Solution**: Create a detectType function applying the spec's 3-rule cascade: (1) root has agntc.json — check asset dirs vs SKILL.md, (2) no agntc.json — scan subdirs (collection), (3) nothing — not agntc. Returns a typed discriminated union (DetectedType). All paths implemented and tested.\n\n**Outcome**: Tested type detection module classifying directories as bare-skill, plugin, collection, or not-agntc. Warns on misconfigurations.\n\n**Do**:\n1. Create src/type-detection.ts with types: ASSET_DIRS ([\"skills\", \"agents\", \"hooks\"]), DetectedType union (bare-skill, plugin with assetDirs, collection with plugins, not-agntc)\n2. Implement detectType(dir, options?) — hasConfig boolean from caller, onWarn callback\n3. Rule 1 (hasConfig=true): check asset dirs → plugin; check SKILL.md → bare-skill; neither → warn + not-agntc. Warn if SKILL.md coexists with asset dirs.\n4. Rule 2 (hasConfig=false): scan immediate subdirs for agntc.json → collection; none → not-agntc\n5. Use fs.access for existence checks\n6. Create tests/type-detection.test.ts with real temp dir fixtures\n7. Export DetectedType, ASSET_DIRS, detectType\n\n**Acceptance Criteria**:\n- Returns bare-skill when hasConfig=true, SKILL.md exists, no asset dirs\n- Returns plugin with assetDirs when asset dirs found\n- Returns collection with plugin names when subdirs have agntc.json\n- Returns not-agntc when nothing recognisable\n- Returns not-agntc with warning when hasConfig=true but no SKILL.md/asset dirs\n- Warns when SKILL.md coexists with asset dirs\n- Collection scan checks immediate subdirs only (not recursive)\n- ASSET_DIRS = [\"skills\", \"agents\", \"hooks\"]\n\n**Tests**:\n- bare-skill with SKILL.md and no asset dirs\n- bare-skill with non-asset dirs alongside SKILL.md\n- plugin with each individual asset dir\n- plugin with all three asset dirs\n- plugin warns when SKILL.md coexists with asset dirs\n- not-agntc with warning when config but nothing to install\n- collection with multiple subdirs having agntc.json\n- collection skips subdirs without agntc.json\n- not-agntc when no config and no subdirs have config\n- not-agntc for empty directory\n- collection scan ignores files\n- collection scan not recursive\n\n**Context**: Spec defines type detection as structure-based with 3 ordered rules. hasConfig avoids re-reading agntc.json. Collections are structural, not declared.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:52:07Z","updated":"2026-02-19T21:44:20Z","closed":"2026-02-19T21:44:20Z"}
{"id":"tick-cc248f","title":"cs-1-6: Agent Driver Interface and Claude Driver","status":"done","priority":2,"description":"**Problem**: The tool needs to ask \"is this agent present?\" and \"where do assets go for this agent?\" but no driver abstraction exists. Spec mandates driver/strategy pattern so adding agents requires only a new driver + registration.\n\n**Solution**: Define AgentDriver TypeScript interface (detect + getTargetDir). Implement Claude driver. Create registry mapping agent IDs to drivers. Detection: project-level first (.claude/), system fallback (which claude, ~/.claude/). Routing: static config map.\n\n**Outcome**: Tested AgentDriver interface, Claude driver with detection/routing, registry. getDriver(\"claude\") → driver, detect(projectDir) → boolean, getTargetDir(assetType) → string | null.\n\n**Do**:\n1. Create src/drivers/types.ts — AgentDriver interface (detect, getTargetDir), AgentId type (\"claude\" | \"codex\")\n2. Create src/drivers/claude-driver.ts — detect: check .claude/ in project → which claude → ~/.claude/. getTargetDir: { skills: \".claude/skills\", agents: \".claude/agents\", hooks: \".claude/hooks\" }, null for unknown.\n3. Create src/drivers/registry.ts — DRIVER_REGISTRY mapping \"claude\" → ClaudeDriver. getDriver(id), getRegisteredAgentIds().\n4. Create tests/drivers/claude-driver.test.ts — mock fs.access and child_process for detection, direct routing tests.\n5. Create tests/drivers/registry.test.ts — registry lookup and registered IDs.\n\n**Acceptance Criteria**:\n- AgentDriver interface with detect(projectDir) and getTargetDir(assetType)\n- AgentId type as \"claude\" | \"codex\"\n- ClaudeDriver.detect: true when .claude/ in project, skips system check on project match\n- ClaudeDriver.detect: fallback to which claude, then ~/.claude/, false when all fail\n- ClaudeDriver.getTargetDir: skills → .claude/skills, agents → .claude/agents, hooks → .claude/hooks, unknown → null\n- getDriver(\"claude\") returns Claude driver\n- getRegisteredAgentIds() returns [\"claude\"]\n- No Codex driver yet (Phase 3)\n\n**Tests**:\n- detect true when .claude/ exists in project\n- detect skips system fallback on project match\n- detect true when which claude succeeds\n- detect true when ~/.claude/ exists\n- detect false when all checks fail\n- detect does not throw on check failures\n- getTargetDir returns correct paths for skills, agents, hooks\n- getTargetDir returns null for unknown asset type\n- registry returns claude driver\n- registry lists registered IDs\n- registry does not contain codex yet\n\n**Context**: Spec: driver/strategy pattern, project-level first + system fallback, cheapest check first. Claude targets per spec table. Codex added Phase 3. KNOWN_AGENTS in config.ts and AgentId in drivers must stay in sync.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:53:49Z","updated":"2026-02-19T21:48:51Z","closed":"2026-02-19T21:48:51Z"}
{"id":"tick-e86117","title":"cs-1-7: Agent Multiselect UI","status":"done","priority":2,"description":"**Problem**: After detecting agents (cs-1-6) and reading plugin's declared agents (cs-1-4), need to let user choose which agents to install for. Spec mandates always-shown @clack/prompts multiselect with smart pre-selection and unsupported warnings.\n\n**Solution**: Create selectAgents function taking declared and detected agents, presenting @clack/prompts multiselect of all registered agents. Pre-selection = declared ∩ detected. Unsupported agents get warning hint. Zero selection = cancel.\n\n**Outcome**: Tested agent selection module showing all registered agents, pre-selecting compatible+detected, warning on unsupported, returning AgentId[] or empty on cancel.\n\n**Do**:\n1. Create src/agent-select.ts with selectAgents({ declaredAgents, detectedAgents }) → Promise\u003cAgentId[]\u003e\n2. Get all agents from getRegisteredAgentIds()\n3. Build multiselect options: value (AgentId), label, hint (warning if not declared), initialValue (true if declared AND detected)\n4. Call @clack/prompts multiselect with required: false\n5. Handle clack cancel → return []\n6. Handle zero selection → brief cancel message, return []\n7. Return selected AgentId[]\n8. Create tests/agent-select.test.ts mocking @clack/prompts multiselect\n\n**Acceptance Criteria**:\n- Always shows all registered agents regardless of compatibility\n- Pre-selection = intersection of declared and detected\n- Warning hint on agents not in declared list\n- Clack cancel returns empty array\n- Zero selection returns empty array\n- Valid selection returns AgentId[]\n\n**Tests**:\n- pre-selects declared AND detected agents\n- does not pre-select declared-only agents\n- does not pre-select detected-only agents\n- shows all registered agents\n- warning hint on undeclared agents\n- no hint on declared agents\n- returns empty on cancel\n- returns empty on zero selection\n- returns selected AgentId[] on valid selection\n- correct options shape passed to multiselect\n- handles empty declaredAgents\n- handles empty detectedAgents\n- handles all agents declared and detected\n\n**Context**: Spec: multiselect always shown, never skipped. Pre-selection = plugin declares + agent detected. Unsupported agents still shown with warning. User can always select any agent. Zero = cancel, no error. Options from registry (Phase 1: Claude only; Phase 3 adds Codex).\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:55:16Z","updated":"2026-02-19T21:53:07Z","closed":"2026-02-19T21:53:07Z"}
{"id":"tick-601f31","title":"cs-1-8: Bare Skill File Copy","status":"done","priority":2,"description":"**Problem**: After agent selection, the tool has a cloned bare-skill repo, selected agents, and driver routing, but no copy logic. Need to copy skill files to target dirs for each agent.\n\n**Solution**: Create copyBareSkill that for each agent resolves target via getTargetDir(\"skills\"), copies source dir to {targetDir}/{skillName}/ excluding agntc.json, returns copied file paths for manifest.\n\n**Outcome**: Tested copy module that copies bare skill files to each agent's target, excludes agntc.json, creates dirs, returns paths for manifest tracking.\n\n**Do**:\n1. Create src/copy-bare-skill.ts with CopyBareSkillInput and CopyBareSkillResult types\n2. For each agent: getTargetDir(\"skills\") → null = skip. Compute destDir = projectDir/targetDir/skillName. mkdir recursive. Copy all files excluding agntc.json. Track paths.\n3. Use fs.cp recursive, then rm agntc.json from dest if present\n4. Record directory paths with trailing slash for manifest consistency\n5. Create tests/copy-bare-skill.test.ts with real temp dir fixtures\n\n**Acceptance Criteria**:\n- Copies all files from source to {targetDir}/{skillName}/ per agent\n- Excludes agntc.json from copy\n- Creates destination dir recursively if missing\n- Copies to destination (conflict handling in add flow ensures clean destination before copy)\n- Returns copiedFiles with paths relative to projectDir, trailing slash for dirs\n- Skips agents where getTargetDir returns null\n- skillName = source directory basename\n- Subdirs copied recursively\n- Empty skill dir (only agntc.json) creates empty target, returns dir path\n- Works for multiple agents independently\n\n**Tests**:\n- copies SKILL.md and references to target\n- excludes agntc.json\n- preserves subdir structure\n- creates destination dir when missing\n- returns correct relative paths with trailing slash\n- skips agent when getTargetDir null\n- copies to multiple agents independently\n- handles empty skill dir\n- skillName matches source basename\n- handles deeply nested subdirs\n\n**Context**: Spec rule 4: bare skill — copy entire dir as skill named after source, exclude agntc.json. Manifest shows dir paths with trailing slashes. Phase 2 extends for multi-asset plugin copy.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:56:41Z","updated":"2026-02-19T22:05:25Z","closed":"2026-02-19T22:05:25Z"}
{"id":"tick-aaa446","title":"cs-1-9: Manifest Creation and Write","status":"done","priority":2,"description":"**Problem**: After copying files, the tool has install metadata but nowhere to persist it. Without a manifest, remove/update/list can't know what's installed. .agntc/ may or may not exist.\n\n**Solution**: Create manifest module with readManifest, writeManifest, addEntry. readManifest reads .agntc/manifest.json or returns {} if absent. addEntry merges new entry. writeManifest creates dir + writes atomically.\n\n**Outcome**: Tested manifest module handling first install (create dir+file), subsequent installs (merge preserving existing), and reinstall (overwrite entry).\n\n**Do**:\n1. Create src/manifest.ts with ManifestEntry type (ref, commit, installedAt, agents, files) and Manifest type (Record\u003cstring, ManifestEntry\u003e)\n2. readManifest(projectDir) — read .agntc/manifest.json, return {} on ENOENT, propagate other errors\n3. writeManifest(projectDir, manifest) — mkdir -p .agntc/, JSON.stringify 2-space indent + trailing newline, atomic write (write to temp file in .agntc/ then rename to manifest.json to avoid partial writes)\n4. addEntry(manifest, key, entry) — pure function, returns new manifest with entry added/replaced\n5. Create tests/manifest.test.ts with real temp dir fixtures\n6. Export all types and functions\n\n**Acceptance Criteria**:\n- readManifest returns {} when dir or file missing\n- readManifest parses valid manifest\n- readManifest propagates non-ENOENT errors\n- writeManifest creates .agntc/ and manifest.json if missing\n- writeManifest overwrites existing file\n- writeManifest uses 2-space indent + trailing newline\n- writeManifest uses atomic write (temp file + rename)\n- addEntry preserves existing entries, overwrites same key\n- addEntry is pure (no mutation)\n- ManifestEntry matches spec: ref, commit, installedAt, agents, files\n- Full round-trip works\n\n**Tests**:\n- readManifest empty when dir missing\n- readManifest empty when file missing but dir exists\n- readManifest parses single and multiple entries\n- readManifest propagates permission errors\n- readManifest throws on invalid JSON\n- writeManifest creates dir and file\n- writeManifest overwrites existing\n- writeManifest formats correctly\n- writeManifest uses atomic write (no partial writes on crash)\n- addEntry to empty manifest\n- addEntry preserving existing\n- addEntry overwrites same key (reinstall)\n- addEntry doesn't mutate input\n- round-trip write then read\n- entry stores null ref for HEAD, string commit, ISO timestamp, agent array, file array\n\n**Context**: Spec: .agntc/manifest.json, flat object keyed by manifest key. Created on first install. Naming spec confirms .agntc/ directory name. Spec requires single atomic write.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:58:03Z","updated":"2026-02-19T22:09:09Z","closed":"2026-02-19T22:09:09Z"}
{"id":"tick-d7ffd9","title":"cs-1-10: Add Command End-to-End Integration","status":"done","priority":2,"description":"**Problem**: All components exist in isolation but nothing wires them into the add command. User can't run npx agntc add owner/repo yet.\n\n**Solution**: Replace add stub with full Phase 1 pipeline: parse → clone → config → detect type → detect agents → select → copy → manifest → summary → cleanup. @clack/prompts for UI (intro, spinner, outro). Error handling with cleanup at each step. Non-bare-skill types show \"not yet supported\" and exit cleanly.\n\n**Outcome**: npx agntc add owner/repo against a bare-skill repo works end-to-end. Errors produce clear messages + cleanup. Non-bare-skill types handled gracefully.\n\n**Do**:\n1. Rewrite src/commands/add.ts with full pipeline: parse → clone → config → detect type → detect agents → select agents → copy → manifest → summary. Use @clack/prompts intro/outro and spinners for clone+copy.\n2. Error handling at each step: cancel message + cleanup + exit 1. Null config or plugin type → \"not yet supported\" + cleanup + exit 0. Empty agent selection → \"Cancelled\" + cleanup + exit 0.\n3. Write manifest via readManifest + addEntry + writeManifest. Summary shows key, ref, per-agent skill count.\n4. Cleanup temp dir in finally block (swallow cleanup errors). Detect agents via getRegisteredAgentIds + per-agent detect().\n5. Create tests/commands/add.test.ts mocking all dependencies: full happy path, error at each step, cleanup on all paths.\n\n**Acceptance Criteria**:\n- Full happy path works: parse → clone → config → detect → select → copy → manifest → summary → cleanup\n- @clack/prompts intro/outro and spinners shown\n- Errors at each step: clear message, cleanup, exit 1\n- Null config (collection) → not-yet-supported, cleanup, exit 0\n- Plugin type → not-yet-supported, cleanup, exit 0\n- Empty agent selection → cancelled, cleanup, exit 0\n- Summary shows key+ref and per-agent skill count\n- Temp dir cleaned in ALL paths (success, error, cancel)\n- Warnings forwarded to clack.log.warn\n- process.cwd() used as project dir\n\n**Tests**:\n- full happy path integration\n- intro/outro shown\n- spinners during clone and copy\n- error on invalid source (no clone attempted)\n- error + cleanup on clone failure\n- error + cleanup on invalid config\n- not-yet-supported for null config\n- not-yet-supported for plugin type\n- warning for not-agntc\n- forwards warnings to clack\n- detect called on all registered agents\n- correct args to selectAgents\n- cancel on empty selection + cleanup\n- correct args to copyBareSkill\n- error + cleanup on copy failure\n- reads existing manifest before adding\n- correct manifest entry fields\n- error + cleanup on manifest write failure\n- summary with key, ref, per-agent count\n- cleanup on success, error, and cancel\n- cleanup errors swallowed\n- skillName from parsed.repo\n\n**Context**: Capstone task of Phase 1. Wires components into spec's add flow. Phase 1 scope: bare-skill + GitHub shorthand only. Brackets deferred: collection select, reinstall, collision check, conflict check (Phases 2-3).\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T21:00:00Z","updated":"2026-02-19T22:21:57Z","closed":"2026-02-19T22:21:57Z"}
{"id":"tick-15542a","title":"cs-1-11: List Command (Minimal)","status":"done","priority":2,"description":"**Problem**: No way for users to see installed plugins. Manifest exists on disk but nothing reads and displays it.\n\n**Solution**: Implement list command to read manifest via readManifest (cs-1-9) and display formatted table via @clack/prompts. Minimal Phase 1 version — no update checks, no detail view, no inline actions.\n\n**Outcome**: npx agntc list shows installed plugins with key, ref, agents, install date. Handles empty/missing/malformed manifest.\n\n**Do**:\n1. Replace list stub in src/commands/list.ts\n2. readManifest(process.cwd())\n3. Empty manifest: \"No plugins installed. Run npx agntc add owner/repo to get started.\" via outro, exit 0\n4. Entries: intro(\"Installed plugins\"), display each with key, version info, agents, date, outro\n5. Version display: @{ref} when set, \"HEAD\" when ref null + commit exists, \"local\" when both null\n6. Agents: comma-separated\n7. Malformed manifest: catch error, \"Failed to read manifest: {error}\", exit 1\n8. Create tests/commands/list.test.ts\n\n**Acceptance Criteria**:\n- Reads manifest from process.cwd()\n- Empty/missing manifest shows spec's empty state message, exits 0\n- Displays each plugin with key, ref, agents, date\n- Ref shown as @tag, HEAD, or local appropriately\n- Malformed manifest shows error, exits 1\n- @clack/prompts for all output\n- No update checks, spinners, or interactivity\n\n**Tests**:\n- empty state for empty manifest\n- empty state for missing manifest\n- single plugin display\n- multiple plugins display\n- ref as tag (@v2.1.6)\n- ref as branch (@main)\n- HEAD when ref null + commit exists\n- local when both null\n- comma-separated agents\n- single agent without comma\n- error on malformed JSON\n- calls readManifest with cwd\n- uses clack intro/outro\n- exits 0 on success and empty\n- exits 1 on error\n\n**Context**: Spec empty state text: \"No plugins installed. Run npx agntc add owner/repo to get started.\" Phase 5 adds full dashboard. Phase 1 list is read-only display only.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T21:01:34Z","updated":"2026-02-19T22:30:51Z","closed":"2026-02-19T22:30:51Z"}
{"id":"tick-aed71e","title":"Phase 2: Multi-Asset Plugins and Collection Support","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-18T21:09:03Z","updated":"2026-02-18T21:09:03Z"}
{"id":"tick-a4cc6d","title":"cs-2-1: Multi-Asset Plugin Asset Copier","status":"done","priority":2,"description":"**Problem**: Phase 1 built copyBareSkill for whole-directory copy. Multi-asset plugins have skills/, agents/, hooks/ dirs whose contents must be individually routed through driver.getTargetDir(assetType). No copy logic exists for this shape.\n\n**Solution**: Create copyPluginAssets that takes source dir, assetDirs list, selected agents, project dir. For each agent × each asset dir: getTargetDir → null = skip, otherwise copy contents to resolved target. Returns copiedFiles (for manifest) and assetCountsByAgent (for summary).\n\n**Outcome**: Tested copier routing multi-asset plugin contents to correct targets, skipping unsupported types, handling empty dirs and nested subdirs.\n\n**Do**:\n1. Create src/copy-plugin-assets.ts with CopyPluginAssetsInput, AssetCounts, CopyPluginAssetsResult types\n2. For each agent × assetDir: getTargetDir(assetDir) → null = skip. Copy contents of source/assetDir to projectDir/targetDir. Track paths and counts.\n3. Copies CONTENTS of asset dirs, not the dirs themselves (skills/planning/ → .claude/skills/planning/)\n4. Create target dirs recursively. Track dir paths with trailing slash, file paths without.\n5. Return copiedFiles (deduped across agents) and assetCountsByAgent\n6. Create tests/copy-plugin-assets.test.ts with real temp dir fixtures\n\n**Acceptance Criteria**:\n- Copies skills/ contents to driver's skills target per agent\n- Copies agents/ contents to driver's agents target per agent\n- Copies hooks/ contents to driver's hooks target per agent\n- Skips asset types where getTargetDir returns null\n- Only processes asset dirs in assetDirs input\n- Copies contents not dirs themselves (no extra nesting)\n- Creates target dirs recursively\n- copiedFiles relative to projectDir, trailing slash for dirs\n- assetCountsByAgent with correct counts\n- Empty asset dirs: zero count, no error\n- Nested subdirs preserved\n- Works per agent independently\n- Does not copy root-level files (only asset dir contents)\n\n**Tests**:\n- copies skills/agents/hooks contents to targets\n- no extra nesting level\n- skips null getTargetDir\n- only processes listed assetDirs\n- creates missing target dirs\n- correct relative paths with trailing slash convention\n- correct per-agent counts\n- empty asset dir handled\n- nested subdirs preserved\n- mixed files and dirs in asset dir\n- multiple agents with different targets\n- subset of asset types\n- single asset type\n\n**Context**: Spec: \"copy contents of each to the appropriate target dir per agent.\" assetDirs from DetectedType (cs-1-5). Routing via driver.getTargetDir (cs-1-6). Claude: all 3 types. Codex (Phase 3): skills only.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-aed71e","created":"2026-02-18T21:09:16Z","updated":"2026-02-19T22:36:52Z","closed":"2026-02-19T22:36:52Z"}
{"id":"tick-456e1a","title":"cs-2-2: Add Command: Multi-Asset Plugin Integration","status":"done","priority":2,"description":"**Problem**: Add command returns \"not yet supported\" for plugin type. Users can't install multi-asset plugins. copyPluginAssets exists but nothing calls it.\n\n**Solution**: Replace plugin stub in add command with real pipeline: copyPluginAssets → manifest write → per-agent summary. Surface type detection warnings through @clack/prompts.\n\n**Outcome**: npx agntc add owner/repo against multi-asset plugin works end-to-end. Warnings for misconfigured/empty plugins display clearly.\n\n**Do**:\n1. Replace plugin branch in add command with: copyPluginAssets({ sourceDir, assetDirs, agents, projectDir }) inside spinner\n2. Check empty copiedFiles → warn \"no files to install\", cleanup, exit 0\n3. Write manifest entry with copiedFiles\n4. Render summary: \"Installed {key}[@{ref}]\" + per-agent counts (only non-zero types)\n5. Verify onWarn callback surfaces root SKILL.md warning and not-agntc warning\n6. Handle not-agntc with config: warn + cleanup + exit 0\n\n**Acceptance Criteria**:\n- Plugin type triggers copyPluginAssets with correct args\n- Manifest entry written with copiedFiles\n- Summary shows per-agent counts, omits zero-count types and no-asset agents\n- Empty plugin warns and exits 0 without manifest write\n- Root SKILL.md ignored warning surfaces\n- not-agntc with config shows warning\n- Temp dir cleaned in all paths\n- Spinner during copy\n- Bare-skill path still works\n\n**Tests**:\n- multi-asset plugin e2e install\n- manifest entry with correct fields\n- summary per-agent counts\n- summary omits zero counts\n- summary with/without ref\n- empty plugin warn + exit 0\n- SKILL.md misconfiguration warning\n- not-agntc warning\n- spinner during copy\n- cleanup on success, empty, error\n- copy error → message + exit 1\n- manifest write error → cleanup + exit 1\n- passes detected assetDirs (not hardcoded)\n- bare-skill path unchanged\n\n**Context**: DetectedType plugin has assetDirs. copyPluginAssets returns copiedFiles + assetCountsByAgent. Spec summary: only show non-zero types per agent.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-aed71e","created":"2026-02-18T21:10:58Z","updated":"2026-02-19T22:43:15Z","closed":"2026-02-19T22:43:15Z"}
{"id":"tick-46b8a2","title":"cs-2-3: Collection Plugin Multiselect UI","status":"done","priority":2,"description":"**Problem**: Collection repos show \"not yet supported\". Need to let users select which plugins to install. Must indicate already-installed plugins and handle cancel.\n\n**Solution**: Create selectCollectionPlugins taking plugins list, manifest, and key prefix. @clack/prompts multiselect with installed hints. Zero selection/cancel = empty array. Single-plugin collections still show multiselect.\n\n**Outcome**: Tested multiselect presenting all collection plugins with installed status, handling cancel, returning selected names.\n\n**Do**:\n1. Create src/collection-select.ts with selectCollectionPlugins({ plugins, manifest, manifestKeyPrefix })\n2. For each plugin: derive key as prefix/pluginName, check manifest, add \"(installed)\" hint if found\n3. @clack/prompts multiselect, required: false. Already-installed NOT pre-selected.\n4. Handle isCancel → empty array. Zero selection → brief message + empty array.\n5. Return selected plugin names as string[]\n6. Create tests/collection-select.test.ts mocking clack multiselect\n\n**Acceptance Criteria**:\n- Presents all plugins as multiselect options\n- Manifest key = prefix/pluginName\n- Installed plugins show \"(installed)\" hint\n- Cancel returns empty array\n- Zero selection returns empty array\n- Valid selection returns string[]\n- Single-plugin collection still shows multiselect\n- All-installed collection still shows multiselect\n- Empty plugins array returns empty without showing multiselect\n\n**Tests**:\n- presents all plugins\n- correct manifest key construction\n- installed hint shown\n- no hint for not-installed\n- mixed installed/not\n- cancel returns empty\n- zero selection returns empty\n- valid selection returns names\n- single plugin still shows multiselect\n- all installed still shows multiselect\n- empty plugins returns empty\n- correct options shape to clack\n\n**Context**: Spec: collection multiselect, installed plugins marked but selectable (reinstall). Zero selection = cancel. Manifest key: owner/repo/plugin-name. UI only — per-plugin processing in cs-2-4.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-aed71e","created":"2026-02-18T21:12:48Z","updated":"2026-02-19T22:47:18Z","closed":"2026-02-19T22:47:18Z"}
{"id":"tick-f68023","title":"cs-2-4: Add Command: Collection Integration","status":"done","priority":2,"description":"**Problem**: Add command shows \"Collections not yet supported\" for collection repos. Need to orchestrate per-plugin pipeline.\n\n**Solution**: Replace collection stub with: selectCollectionPlugins → for each plugin: readConfig, detectType, copy by type → single manifest write with owner/repo/plugin-name keys → per-plugin summary. Plugin failures skip with warning.\n\n**Outcome**: Collection repos present multiselect, install each selected plugin by type, write per-plugin manifest entries, show per-plugin summary.\n\n**Do**:\n1. Replace collection branch in add command\n2. selectCollectionPlugins({ plugins, manifest, manifestKeyPrefix })\n3. Empty selection → cancel + cleanup\n4. Agent detection + multiselect ONCE for all plugins. Empty → cancel + cleanup.\n5. Per plugin: readConfig(pluginDir) — ConfigError → warn + skip. null → warn + skip.\n6. detectType per plugin: bare-skill → copyBareSkill (skillName=pluginName). plugin → copyPluginAssets. not-agntc → warn + skip.\n7. Manifest key: manifestKeyPrefix/pluginName\n8. Single manifest write after all plugins\n9. Per-plugin summary with counts. Note skipped plugins.\n10. Cleanup in finally\n\n**Acceptance Criteria**:\n- Collection triggers selectCollectionPlugins with correct args\n- Agent multiselect once for all plugins\n- Each plugin validated independently\n- ConfigError skips plugin with warning\n- Bare-skill and multi-asset plugins handled by type\n- Manifest keys: owner/repo/plugin-name\n- Single manifest write\n- Per-plugin summary with counts\n- Skipped plugins noted\n- Empty selections cancel cleanly\n- Temp dir cleaned in all paths\n\n**Tests**:\n- collection with bare-skill plugins\n- collection with multi-asset plugins\n- mixed types install each by type\n- manifest keys correct\n- agent multiselect called once\n- invalid agntc.json skips plugin\n- missing agntc.json skips plugin\n- not-agntc skips plugin\n- all plugins failing exits 0\n- empty plugin/agent selection cancels\n- single manifest write\n- per-plugin summary\n- cleanup on all paths\n- no regression on standalone add\n\n**Context**: Spec: collection multiselect, each plugin independent, per-plugin summary. Agent multiselect once, pre-selection uses union of declared agents. Reinstall deferred to cs-2-5.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-aed71e","created":"2026-02-18T21:15:06Z","updated":"2026-02-19T22:56:02Z","closed":"2026-02-19T22:56:02Z"}
{"id":"tick-5820dd","title":"cs-2-5: Reinstall on Reselect","status":"done","priority":2,"description":"**Problem**: Selecting an already-installed plugin installs on top of existing files, leaving orphaned files from previous versions. Spec requires nuke-and-reinstall.\n\n**Solution**: Create nukeManifestFiles that deletes files from manifest entry before copying. ENOENT silently skipped. Works for both collection and standalone plugins. Reusable by update/remove in later phases.\n\n**Outcome**: Already-installed plugins' files nuked before re-copy. Missing files skipped gracefully. Manifest entry replaced with fresh data.\n\n**Do**:\n1. Create src/nuke-files.ts with nukeManifestFiles(projectDir, files) → { removed, skipped }\n2. Dirs (trailing /) → fs.rm recursive+force. Files → fs.rm force. ENOENT → skipped. Other errors propagate.\n3. In add command: before copying, check if manifestKey exists in manifest. If so, nukeManifestFiles.\n4. Applies to standalone and collection plugins alike\n5. addEntry replaces old manifest entry after reinstall\n6. Create tests/nuke-files.test.ts with real temp dirs\n7. Update add command tests for reinstall flow\n\n**Acceptance Criteria**:\n- Files nuked before copy begins\n- Directories removed recursively\n- ENOENT silently skipped\n- Non-ENOENT errors propagate\n- Returns removed and skipped lists\n- Per-plugin nuke independent (collection)\n- Manifest entry replaced not duplicated\n- Works for standalone reinstall\n- Works for collection reinstall\n- Different agent selection: old files nuked, new files created\n- Empty files array is no-op\n\n**Tests**:\n- nukes files before copy\n- removes directories recursively\n- removes individual files\n- skips ENOENT\n- returns removed/skipped lists\n- propagates EACCES\n- empty files is no-op\n- mix of existing and missing\n- standalone reinstall nukes first\n- collection reinstall nukes first\n- different agents: old removed, new created\n- only installed plugins nuked\n- manifest entry replaced\n- nuke failure on one collection plugin doesn't block others\n\n**Context**: Spec step 6: delete all manifest files before proceeding. Same mechanics as update's nuke step. nukeManifestFiles reusable by Phase 4 update and remove commands.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-aed71e","created":"2026-02-18T21:15:17Z","updated":"2026-02-20T08:40:36Z","closed":"2026-02-20T08:40:36Z"}
{"id":"tick-ef070a","title":"Phase 3: Multi-Agent Support and Source Formats","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-18T21:17:31Z","updated":"2026-02-18T21:17:31Z"}
{"id":"tick-3f18d0","title":"cs-3-1: Codex Agent Driver","status":"done","priority":2,"description":"**Problem**: Only Claude driver exists. Can't route assets to Codex targets. Adding Codex validates driver/strategy architecture.\n\n**Solution**: Implement CodexDriver satisfying AgentDriver. detect: .agents/ in project → which codex fallback. getTargetDir: skills → .agents/skills/, agents → null, hooks → null. Register in registry. Verify agent multiselect works with both agents.\n\n**Outcome**: CodexDriver registered, detectable, routing skills to .agents/skills/. Registry returns both claude and codex. Agent multiselect pre-selection works correctly with both agents per spec examples.\n\n**Do**:\n1. Create src/drivers/codex-driver.ts implementing AgentDriver\n2. detect: check .agents/ in project → which codex fallback. No ~/.codex/ check.\n3. getTargetDir: skills → .agents/skills, agents → null, hooks → null\n4. Register in registry under \"codex\"\n5. Verify getRegisteredAgentIds returns [\"claude\", \"codex\"]\n6. Create tests/drivers/codex-driver.test.ts\n7. Add tests to agent-select.test.ts verifying two-agent pre-selection/warning combinations with both Claude and Codex registered\n\n**Acceptance Criteria**:\n- detect true when .agents/ exists, skips system fallback\n- detect falls back to which codex\n- detect false when both fail, no throw\n- getTargetDir: skills → .agents/skills, agents → null, hooks → null\n- Registry includes codex, Claude unchanged\n- Agent multiselect pre-selection works correctly with both agents registered per spec examples\n\n**Tests**: detect with/without .agents/, which codex success/failure, getTargetDir for all types, registry lookup, both agents registered, two-agent pre-selection combinations match spec examples, unsupported warning on undeclared agent with both registered, empty declaredAgents warns both agents\n\n**Context**: Spec routing: Codex skills → .agents/skills/, agents → null, hooks → null. Detection: .agents/ then which codex. Absorbs cs-3-3 (two-agent multiselect verification).\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:20:09Z","updated":"2026-02-20T08:46:14Z","closed":"2026-02-20T08:46:14Z"}
{"id":"tick-947bd2","title":"cs-3-2: Agent Detection System","status":"done","priority":2,"description":"**Problem**: Detection is inline in add command. Need reusable detectAgents function for multiple commands.\n\n**Solution**: Extract detectAgents(projectDir) that loops registered drivers, calls detect() in parallel, returns detected AgentId[].\n\n**Outcome**: Tested detectAgents function. Add command uses it instead of inline loop.\n\n**Do**:\n1. Create src/detect-agents.ts with detectAgents(projectDir) → AgentId[]\n2. Loop getRegisteredAgentIds, detect each in parallel (Promise.all)\n3. Return detected IDs (may be empty). Individual failures → not detected.\n4. Replace inline detection in add command\n5. Create tests/detect-agents.test.ts\n\n**Acceptance Criteria**:\n- Returns detected AgentId[]\n- Parallel detection\n- Empty when none detected\n- Individual failure → not detected (no throw)\n- Add command uses detectAgents\n\n**Tests**: both detected, only one, none, parallel, individual failure, add command integration\n\n**Context**: Spec: detection for pre-selection, not gating. Project-level first, system fallback per driver.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:20:09Z","updated":"2026-02-20T08:52:26Z","closed":"2026-02-20T08:52:26Z"}
{"id":"tick-1abe95","title":"cs-3-3: Agent Multiselect with Pre-Selection and Warnings","status":"cancelled","priority":2,"description":"**Problem**: Phase 1 selectAgents built with Claude only. Need to verify and enhance for two-agent scenarios.\n\n**Solution**: Validate selectAgents with both agents registered. Verify pre-selection (declared ∩ detected), unsupported warnings, edge cases.\n\n**Outcome**: Multiselect correctly handles all two-agent declared/detected combinations.\n\n**Do**:\n1. Review src/agent-select.ts for two-agent correctness\n2. Add/update tests for all two-agent combinations\n3. Verify spec examples work\n4. Fix any gaps found\n\n**Acceptance Criteria**:\n- Both agents shown\n- Pre-selection = declared ∩ detected for all combinations\n- Unsupported warning on undeclared agents\n- Empty declaredAgents → all get warning\n- Unsupported agent selectable (warn never block)\n- Zero selection returns empty\n\n**Tests**: all declared/detected combinations, unsupported warnings, empty declared, no agents detected, user selects unsupported\n\n**Context**: Spec pre-selection examples. Warn never block. Works with Codex driver now registered.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:20:09Z","updated":"2026-02-19T12:04:30Z","closed":"2026-02-19T12:04:30Z"}
{"id":"tick-d63c08","title":"cs-3-4: Source Parsing: HTTPS URL","status":"done","priority":2,"description":"**Problem**: parseSource only handles GitHub shorthand. Need HTTPS URL support for any git host.\n\n**Solution**: Extend parseSource to detect https:// URLs, extract owner/repo from path, support @ref, return type \"https-url\" with cloneUrl. Normalize trailing slash and .git suffix.\n\n**Outcome**: parseSource handles HTTPS URLs from any host with correct manifest key and clone URL.\n\n**Do**:\n1. Add ParsedSource variant: { type: \"https-url\", owner, repo, ref, manifestKey, cloneUrl }\n2. Detect https:// prefix after trim\n3. Parse URL path: strip trailing slash/.git, extract last 2 segments as owner/repo\n4. Build cloneUrl: https://{host}/{owner}/{repo}.git\n5. manifestKey: owner/repo (host-independent)\n6. Update cloneSource to use cloneUrl for https-url type\n7. Update tests\n\n**Acceptance Criteria**:\n- Parses any host (github, gitlab, bitbucket)\n- Extracts owner/repo from URL path\n- Supports @ref suffix\n- Strips trailing slash and .git\n- manifestKey = owner/repo\n- cloneUrl normalized with .git\n- Throws for invalid URLs (no path, single segment)\n- GitHub shorthand still works\n\n**Tests**: various hosts, @ref, trailing slash, .git suffix, invalid URLs, no regression on shorthand\n\n**Context**: Spec: HTTPS URL format from any git host. manifest key = owner/repo regardless of format. @ref suffix supported.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:20:09Z","updated":"2026-02-20T08:58:11Z","closed":"2026-02-20T08:58:11Z"}
{"id":"tick-448957","title":"cs-3-5: Source Parsing: SSH URL","status":"done","priority":2,"description":"**Problem**: parseSource doesn't handle SSH URLs. Users with SSH auth can't use agntc add.\n\n**Solution**: Add type: \"ssh-url\" variant. Detect git@ prefix, parse host:owner/repo.git, handle missing .git, support @ref.\n\n**Outcome**: parseSource handles git@host:owner/repo.git[@ref] with correct cloneUrl, owner, repo, manifestKey.\n\n**Do**:\n1. Add ParsedSource variant: { type: \"ssh-url\", owner, repo, ref, manifestKey, cloneUrl }\n2. Detect git@ prefix. Split ref on last @ after repo path.\n3. Parse host:path, strip .git, extract owner/repo\n4. cloneUrl: git@host:owner/repo.git (normalized)\n5. manifestKey: owner/repo\n6. Throw for malformed URLs\n7. Update tests\n\n**Acceptance Criteria**: Parses git@host:owner/repo.git with/without ref, any host, missing .git handled, cloneUrl normalized, manifestKey=owner/repo, errors for malformed, no regression.\n\n**Tests**: with/without ref, tag/branch refs, missing .git, non-GitHub hosts, malformed URLs, no regression\n\n**Context**: Spec: git@github.com:owner/repo.git for SSH auth. @ref supported. manifestKey = owner/repo.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:23:36Z","updated":"2026-02-20T09:02:33Z","closed":"2026-02-20T09:02:33Z"}
{"id":"tick-db20a7","title":"cs-3-6: Source Parsing: Local Path","status":"done","priority":2,"description":"**Problem**: parseSource only handles remote sources. Need local paths for development/testing.\n\n**Solution**: Add type: \"local-path\" variant. Detect ./ ../ / ~ prefixes. Resolve absolute, expand tilde, validate exists + is directory at parse time. ref=null, manifestKey=absolute path.\n\n**Outcome**: parseSource handles local paths, validates existence, returns resolved absolute path.\n\n**Do**:\n1. Add ParsedSource variant: { type: \"local-path\", resolvedPath, ref: null, manifestKey }\n2. Detect path prefixes (./ ../ / ~)\n3. Expand ~, resolve to absolute via path.resolve\n4. Validate: fs.stat, must exist and be directory. Throw spec error message.\n5. manifestKey = resolvedPath\n6. Make parseSource async (fs.stat needed for path validation). Update callers: src/commands/add.ts (await parseSource), and all parseSource tests in tests/source-parser.test.ts (async test functions, await calls). This is a signature change affecting the add command pipeline.\n7. Update tests\n\n**Acceptance Criteria**: Resolves relative/absolute/tilde paths, validates exists+directory, throws spec error for missing/file, ref=null, manifestKey=absolute, tilde expanded, no regression.\n\n**Tests**: relative, absolute, tilde, non-existent, file not dir, permission denied, no regression\n\n**Context**: Spec: local paths for dev/testing. No clone. ref+commit null. Key=absolute path. Error: \"Path {path} does not exist or is not a directory.\"\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:23:36Z","updated":"2026-02-20T09:10:15Z","closed":"2026-02-20T09:10:15Z"}
{"id":"tick-0b36b0","title":"cs-3-7: Source Parsing: Direct Collection Path","status":"done","priority":2,"description":"**Problem**: Can't install a specific plugin from a collection via tree URL. Must add whole collection and multiselect.\n\n**Solution**: Add type: \"direct-path\" variant. Detect /tree/ in HTTPS URLs. Extract ref and plugin name from path. cloneUrl for whole repo. targetPlugin for skipping multiselect. Reject @ref suffix on tree URLs.\n\n**Outcome**: parseSource handles tree URLs, extracts ref+plugin from path, returns direct-path type. Add command skips multiselect for direct-path sources.\n\n**Do**:\n1. Add ParsedSource variant: { type: \"direct-path\", owner, repo, ref, targetPlugin, manifestKey, cloneUrl }\n2. Detect /tree/ in HTTPS URL path (before plain HTTPS fallthrough)\n3. Parse: owner/repo from path, ref = first segment after /tree/, plugin = rest\n4. cloneUrl: https://host/owner/repo.git\n5. manifestKey: owner/repo/plugin-name\n6. Throw for @ref suffix on tree URL, missing ref/plugin\n7. Wire into add command: when source is direct-path, skip collection multiselect and install targetPlugin directly. Remainder of flow (agent selection, collision check, copy) proceeds as normal.\n8. Update tests\n\n**Acceptance Criteria**: Parses tree URLs with branch/tag refs, correct targetPlugin, cloneUrl, manifestKey=owner/repo/plugin, throws for @ref suffix and missing segments, no regression, add command skips collection multiselect when source is direct-path and installs targetPlugin directly, remainder of add flow (agent selection, collision check, copy) proceeds as normal for direct-path sources.\n\n**Tests**: branch/tag refs, nested plugin paths, non-GitHub hosts, @ref suffix rejected, missing segments, no regression, add command bypasses collection multiselect for direct-path source, direct-path installs only the specified plugin, direct-path proceeds through agent selection and conflict checks normally, direct-path with targetPlugin not found in collection errors clearly.\n\n**Context**: Spec: direct path = collection shortcut, skips multiselect. Ref embedded in URL. manifestKey = owner/repo/plugin-name. \"The tool skips the collection multiselect and installs that plugin directly. The remainder of the flow proceeds as normal.\"\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:23:36Z","updated":"2026-02-20T09:16:17Z","closed":"2026-02-20T09:16:17Z"}
{"id":"tick-d24318","title":"cs-3-8: Local Path Source Integration","status":"done","priority":2,"description":"**Problem**: cs-3-6 parses local paths but add command still assumes remote sources (clone + temp dir). Need to wire local path through pipeline.\n\n**Solution**: Branch on type=local-path in add command. Skip clone, use resolvedPath as sourceDir. No temp dir cleanup. commit=null in manifest. Collection keys = absolutePath/pluginName.\n\n**Outcome**: npx agntc add ./my-plugin works without cloning. Correct manifest entry. Collections from local paths supported.\n\n**Do**:\n1. Branch on local-path early in add command\n2. sourceDir = parsed.resolvedPath (skip clone)\n3. Skip temp dir cleanup (conditional)\n4. Proceed with readConfig, detectType, select, copy as normal\n5. Manifest: ref=null, commit=null, key=resolvedPath\n6. Collections: manifestKeyPrefix = resolvedPath, plugin key = path/pluginName\n7. Summary shows \"local\" instead of ref\n8. Update tests\n\n**Acceptance Criteria**: Skips clone, uses resolvedPath, no temp dir, manifest ref+commit null, key=absolute path, bare skill+plugin+collection from local path, collection keys correct, local path with no agntc.json and no collection subdirs surfaces clear error and aborts, unreadable local path surfaces clear error and aborts, no regression.\n\n**Tests**: skip clone, resolvedPath as source, no cleanup, null ref/commit, correct key, bare skill/plugin/collection from local, collection keys, no agntc.json surfaces error, unreadable path surfaces error, summary, no regression\n\n**Context**: Spec: local path = no clone, copy directly. ref+commit null. Key = absolute path. Collection plugins: absolutePath/pluginName. ~ expanded. Spec error handling: \"If the local path doesn't exist, isn't readable, or contains no agntc.json: surface the error clearly and abort.\"\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:23:36Z","updated":"2026-02-20T09:25:00Z","closed":"2026-02-20T09:25:00Z"}
{"id":"tick-400db7","title":"cs-3-9: File Path Collision Check","status":"done","priority":2,"description":"**Problem**: Two plugins can install to overlapping paths, silently corrupting the first. No collision detection exists.\n\n**Solution**: checkFileCollisions diffs incoming files against manifest entries (excluding own key for reinstall). resolveCollisions offers remove-conflicting-plugin or cancel. No install-anyway option.\n\n**Outcome**: Collisions hard-block with clear prompt. User removes conflicting plugin in-flow or cancels. Reinstalls excluded from collision check.\n\n**Do**:\n1. Create src/collision-check.ts: checkFileCollisions(incomingFiles, manifest, excludeKey?) → CollisionResult\n2. Group collisions by manifest key\n3. Create src/collision-resolve.ts: resolveCollisions with remove or cancel options\n4. Remove = nukeManifestFiles + delete entry. Cancel = resolved: false.\n5. Multiple colliding plugins resolved sequentially\n6. Create tests\n\n**Acceptance Criteria**: Empty when no overlap, detects overlap, groups by key, excludes own key (reinstall), no install-anyway option, remove triggers nuke + entry removal, cancel returns false, multiple collisions sequential.\n\n**Tests**: no overlap, single/multi collision, exclude own key, directory paths, resolve remove/cancel, multiple plugins sequential, stop on cancel\n\n**Context**: Spec step 7: hard block on cross-plugin overlap. Remove then continue, or cancel. Reinstall nuke (step 6) runs before this.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:26:45Z","updated":"2026-02-20T09:32:52Z","closed":"2026-02-20T09:32:52Z"}
{"id":"tick-081566","title":"cs-3-10: Unmanaged File Conflict Check","status":"done","priority":2,"description":"**Problem**: User may have manually placed files at destination paths. Overwriting silently loses work. Need detection and prompt.\n\n**Solution**: checkUnmanagedConflicts scans destination paths on disk, excluding manifest-tracked files. Asset-level detection. resolveUnmanagedConflicts offers per-plugin overwrite-all (double confirmation) or cancel-plugin.\n\n**Outcome**: Unmanaged files detected. Per-plugin prompt with double-confirmed overwrite or cancel. Collections check independently.\n\n**Do**:\n1. Create src/unmanaged-check.ts: checkUnmanagedConflicts(incomingFiles, manifest, projectDir) → UnmanagedConflict[]\n2. Check disk existence, exclude manifest-tracked paths\n3. Asset-level: skill dir, agent file, hook file\n4. Create src/unmanaged-resolve.ts: per-plugin overwrite-all + second confirm, or cancel\n5. Return approved/cancelled lists\n6. Create tests\n\n**Acceptance Criteria**: Empty when nothing on disk, empty when all tracked, detects unmanaged assets, empty dir = conflict, asset-level detection, overwrite needs double confirm, cancel → cancelled, collections independent, all cancelled → empty approved.\n\n**Tests**: no files on disk, all tracked, unmanaged skill/agent/hook, empty dir, asset level, overwrite + confirm, overwrite + decline confirm, cancel, mixed collection, all cancelled\n\n**Context**: Spec step 8: scan for unmanaged files. Asset-level. Overwrite-all with second confirmation or cancel-plugin. After collision check passes. Note: overwrite-on-conflict also serves as the migration path from other tools (e.g., previous plugin managers) — no special migration tooling needed per spec.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:26:45Z","updated":"2026-02-20T09:37:34Z","closed":"2026-02-20T09:37:34Z"}
{"id":"tick-f5b1ac","title":"cs-3-11: Add Command Full Conflict Flow Integration","status":"done","priority":2,"description":"**Problem**: Collision check and unmanaged check exist but aren't wired into add command. Goes straight from agent select to copy.\n\n**Solution**: Wire both checks between agent selection and copy. Order: compute incoming files → collision check → resolve → unmanaged check → resolve → copy. All resolution before copying. Summary notes skipped plugins.\n\n**Outcome**: Full conflict flow for every install. Cancelled plugins excluded. No rollback needed.\n\n**Do**:\n1. Create computeIncomingFiles helper mirroring copy path computation\n2. For standalone: collision check → unmanaged check → copy\n3. For collections: per-plugin checks, cancelled excluded from copy\n4. Collision removal persists even if later cancelled\n5. Summary notes skipped plugins with reason\n6. Update tests\n\n**Acceptance Criteria**: Collision before unmanaged before copy, cancel at any stage exits cleanly, collections independent, removal persists after cancel, summary notes skips, computeIncomingFiles matches copy paths, no regression.\n\n**Tests**: collision before copy, unmanaged after collision, cancel at each stage, resolve then install, collection independent, all cancelled, removal persists, incoming files correct, no conflict path, manifest reflects all changes, cleanup on cancel\n\n**Context**: Spec steps 7-8 before step 9. All resolution before copying = no rollback. computeIncomingFiles mirrors copy logic.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:26:45Z","updated":"2026-02-20T09:45:46Z","closed":"2026-02-20T09:45:46Z"}
{"id":"tick-d85f8a","title":"Phase 4: Remove and Update Commands","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-18T21:28:58Z","updated":"2026-02-18T21:28:58Z"}
{"id":"tick-35621c","title":"cs-4-1: Remove Command: Parameterized Mode","status":"done","priority":2,"description":"**Problem**: No way to remove installed plugins. Users must manually delete files and edit manifest.\n\n**Solution**: Implement parameterized remove: parse key argument, match against manifest (exact, collection prefix, or not found), show files, confirm, nuke via nukeManifestFiles, remove entry, write manifest, summary.\n\n**Outcome**: npx agntc remove owner/repo deletes tracked files and manifest entry after confirmation.\n\n**Do**:\n1. Create src/commands/remove.ts with optional [key] argument\n2. readManifest → empty → \"No plugins installed.\", exit 0\n3. Match: exact key → single target. No exact → collection prefix (keys starting with key/) → multiple. No match → error, exit 1.\n4. Confirm: list files, @clack/prompts confirm. Decline → cancel, exit 0.\n5. nukeManifestFiles per target plugin\n6. Remove entries from manifest, writeManifest\n7. Summary: \"Removed {key}\" with counts\n8. Register in cli.ts\n\n**Acceptance Criteria**: Exact key removes single, prefix removes all collection plugins, non-existent exits 1 with spec message, empty manifest exits 0, confirmation shown, declined cancels, files nuked, manifest updated, summary shown, empty directories left in place after file deletion (no directory cleanup).\n\n**Tests**: standalone remove, collection prefix, specific collection plugin, non-existent key, empty manifest, confirmation shown/declined, files nuked, manifest updated, summary, ENOENT tolerance, preserves unrelated entries, empty parent directories left in place after removal.\n\n**Context**: Spec: confirm → delete → remove entry → write. nukeManifestFiles from cs-2-5. Error: \"Plugin {key} is not installed.\" No modification detection — the tool does not track checksums. If user modified installed files, those changes are lost on remove. Git is the safety net.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:45:19Z","updated":"2026-02-20T09:52:02Z","closed":"2026-02-20T09:52:02Z"}
{"id":"tick-5bc8a9","title":"cs-4-2: Remove Command: Interactive Mode","status":"done","priority":2,"description":"**Problem**: Users must know exact manifest key. Need no-arg interactive mode.\n\n**Solution**: No-arg reads manifest, presents @clack/prompts multiselect, selected plugins flow into same confirm → nuke → remove → write → summary path.\n\n**Outcome**: npx agntc remove (no args) shows selectable list. Selected plugins removed after confirmation.\n\n**Do**:\n1. No-arg branch in remove command\n2. readManifest → empty → message, exit 0\n3. @clack/prompts multiselect with all keys + ref hints\n4. Cancel/zero → exit 0\n5. Selection flows to parameterized confirm → nuke → remove → write → summary\n\n**Acceptance Criteria**: No-arg shows multiselect, cancel exits 0, selected flow to confirm+remove, empty manifest handled, single plugin still shows multiselect.\n\n**Tests**: multiselect shown, ref hints, cancel, zero selection, single/multi selection, empty manifest, declined confirmation, correct nuke args.\n\n**Context**: Spec: no-arg presents all plugins. Shares infrastructure with cs-4-1.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:45:19Z","updated":"2026-02-20T09:57:43Z","closed":"2026-02-20T09:57:43Z"}
{"id":"tick-76e6c7","title":"cs-4-3: Update Check Logic","status":"done","priority":2,"description":"**Problem**: No way to determine if a plugin has newer version. Update and list dashboard both need this.\n\n**Solution**: Create checkForUpdate returning typed result: update-available, up-to-date, newer-tags, check-failed, or local. Uses git ls-remote for remote comparison.\n\n**Outcome**: Tested update check handling all ref types with correct git ls-remote invocations.\n\n**Do**:\n1. Create src/update-check.ts with UpdateCheckResult union\n2. Local (ref=null, commit=null) → { status: 'local' }\n3. null ref (HEAD): ls-remote HEAD SHA → compare to commit\n4. Branch ref: ls-remote refs/heads/{ref} → compare\n5. Tag ref: always up-to-date + ls-remote --tags for newer tags\n6. Derive cloneUrl from manifest key\n7. All ls-remote failures → check-failed\n8. Create tests mocking child_process\n\n**Acceptance Criteria**: HEAD/branch/tag/local all handled correctly, ls-remote failure → check-failed, branch gone → check-failed, newer tags detected, clone URL derived from key.\n\n**Tests**: HEAD update-available/up-to-date, branch update/match/gone, tag up-to-date/newer-tags, local returns immediately, ls-remote failure/timeout, URL derivation, ls-remote output parsing.\n\n**Context**: Spec update check table. Used by update command and list dashboard (Phase 5).\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:45:19Z","updated":"2026-02-20T10:07:23Z","closed":"2026-02-20T10:07:23Z"}
{"id":"tick-2a89a4","title":"cs-4-4: Update Command: Single Plugin Nuke-and-Reinstall","status":"done","priority":2,"description":"**Problem**: No update command. Users must remove and re-add to get newer versions.\n\n**Solution**: Implement update with single-plugin mode: checkForUpdate → clone to temp → readConfig from temp → agent compat check → if all dropped: abort (preserve files) → if proceeding: nuke existing → copy from temp → update manifest. No confirmation. No agent re-prompt. Clone before nuke so agent compat can abort without file loss.\n\n**Outcome**: npx agntc update owner/repo checks, clones new version, verifies agent compat, then nukes and re-copies. All-agents-dropped preserves existing files. Clone failure doesn't affect installed files.\n\n**Do**:\n1. Create src/commands/update.ts with optional [key] argument\n2. readManifest → empty → message, exit 0. No match → error, exit 1.\n3. checkForUpdate → up-to-date → message, exit 0. check-failed → error, exit 1.\n4. update-available: cloneSource(same ref) to temp dir → readConfig from temp → agent compat check (cs-4-7) → if all agents dropped: warn, cleanup temp, exit 0 (existing files preserved) → if proceeding: nukeManifestFiles → detectType → copy from temp (effective agents) → update manifest entry → writeManifest → cleanup temp\n5. Summary: old→new commit + per-agent counts\n6. Register in cli.ts\n7. Handle clone failure: catch cloneSource errors with clear message. No files have been modified at this point since nuke hasn't happened yet. Cleanup temp dir.\n\n**Acceptance Criteria**: Non-existent key exits 1, empty manifest exits 0, up-to-date message, check-failed error, clone-then-nuke pipeline (clone before nuke so agent compat can abort without file loss), no confirmation, uses entry.agents (or effective agents after compat check), manifest updated with new commit/files, temp dir cleaned on all paths, clone failure does not affect existing installed files (nuke has not occurred), temp dir cleaned on clone failure.\n\n**Tests**: non-existent key, empty manifest, up-to-date, check-failed, clone-then-nuke-and-reinstall flow, same agents used, manifest updated, temp dir cleanup, already-deleted files, collection prefix updates all, clone failure leaves existing files intact (no nuke occurred), all-plugins mode continues after one plugin's clone failure, all-agents-dropped aborts before nuke (files preserved).\n\n**Context**: Spec nuke-and-reinstall: delete → re-clone same ref → re-copy same agents → update manifest. No confirmation. No agent re-selection. Pipeline reordered to clone-then-check-then-nuke so all-agents-dropped can abort without file loss per spec (\"Existing files are left in place\"). Absorbs cs-4-9 (clone failure handling simplified since nuke hasn't happened yet).\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:45:19Z","updated":"2026-02-20T10:15:00Z","closed":"2026-02-20T10:15:00Z"}
{"id":"tick-a1ef32","title":"cs-4-5: Update Command: Local Path Re-Copy","status":"done","priority":2,"description":"**Problem**: Local path plugins can't use git update. Need always-re-copy from stored path.\n\n**Solution**: Detect local status from checkForUpdate. Re-read agntc.json from stored path, check agent compat (cs-4-7), nuke existing if proceeding, re-copy with effective agents, update manifest. Always copies unless all agents dropped.\n\n**Outcome**: npx agntc update /path/to/plugin re-copies from source. Handles missing path. Agent compat checked before nuke.\n\n**Do**:\n1. Local-path branch in update after checkForUpdate returns 'local'\n2. Validate source path exists + is directory. Missing → error, exit 1.\n3. readConfig from stored path → agent compat check (cs-4-7) → if all agents dropped: warn, exit 0 (existing files preserved) → if proceeding: nukeManifestFiles → copy from path using effective agents → update manifest\n4. Summary: \"refreshed\" with counts\n\n**Acceptance Criteria**: Local detected, always re-copies, validates path, missing path errors, no git, manifest updated with null ref/commit, works for standalone and collection local, agent compat checked before nuke (re-reads agntc.json from stored path), all-agents-dropped preserves existing files, partial drop uses effective agents.\n\n**Tests**: local triggers re-copy, copies even if unchanged, validates path, errors when gone, errors no agntc.json, agent compat checked from stored path, all-agents-dropped preserves files, partial drop uses effective agents, nukes then copies, manifest updated with effective agents, no git clone, no temp dir.\n\n**Context**: Spec: local always re-copy. No change detection. Agent compat applies to all update types. Same class of fix as cs-4-4 clone-before-nuke, adapted for local (re-read config directly, no clone needed).\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:45:19Z","updated":"2026-02-20T10:20:08Z","closed":"2026-02-20T10:20:08Z"}
{"id":"tick-496cae","title":"cs-4-6: Update Command: Tag-Pinned Behavior","status":"done","priority":2,"description":"**Problem**: Tag-pinned plugins should never auto-upgrade but user should be informed of newer tags.\n\n**Solution**: Handle 'newer-tags' and 'up-to-date' from checkForUpdate for tag-pinned plugins. Display tag list and re-add command. No file/manifest changes.\n\n**Outcome**: Tag-pinned shows up-to-date or lists newer tags with upgrade command. No files touched.\n\n**Do**:\n1. Handle 'newer-tags' status in update command\n2. Display: pinned to {ref}, newer tags available, tag list (newest first)\n3. Show re-add command: npx agntc add {source}@{tag}\n4. 'up-to-date' for tags: brief message\n5. No file/manifest changes, exit 0\n\n**Acceptance Criteria**: Newer tags listed newest-first, re-add command shown, no newer tags → up-to-date, no files/manifest modified, exits 0.\n\n**Tests**: newer tags shown, no newer tags, re-add command, newest first, no nuke/clone/manifest write.\n\n**Context**: Spec: tag-pinned never auto-upgraded. Show available tags, re-add command.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:46:08Z","updated":"2026-02-20T10:23:42Z","closed":"2026-02-20T10:23:42Z"}
{"id":"tick-027b1d","title":"cs-4-7: Update Command: Agent Compatibility Changes","status":"done","priority":2,"description":"**Problem**: Plugin update may change agents field. Need to handle dropped agents without re-prompting.\n\n**Solution**: During update, after cloning new version to temp (before nuke), compare new agntc.json agents against manifest agents. effectiveAgents = intersection. All dropped → warn + abort update (existing files preserved). Partial drop → signal to proceed with remaining agents. New agents ignored.\n\n**Outcome**: Agent compat changes detected: partial drops warned, total drops abort preserving files, new agents ignored.\n\n**Do**:\n1. After re-clone + readConfig from temp dir: compare newConfig.agents vs entry.agents\n2. effectiveAgents = intersection\n3. All dropped: warn with spec message (includes remove command), return signal to abort update. Caller (cs-4-4) skips nuke and copy, cleans up temp dir, exits 0. Existing files preserved per spec.\n4. Partial drop: warn, return effectiveAgents for cs-4-4 to use for copy. manifest.agents updated after copy.\n5. New agents in config: silently ignore\n6. Summary: \"Updated for {agents}. {dropped} support removed.\"\n\n**Acceptance Criteria**: Detects dropped agents, all dropped warns+aborts+preserves existing files, partial drop warns+proceeds with remaining, manifest agents updated, dropped files removed (part of nuke after compat check passes), new agents ignored, no change proceeds normally, effectiveAgents used for copy.\n\n**Tests**: no change normal, partial drop warns/uses effective/updates manifest, all dropped warns/aborts/preserves files/shows remove cmd, all dropped exits 0, new agents ignored, single agent dropped from multi, effectiveAgents intersection correct.\n\n**Context**: Spec: re-read agntc.json, compare agents. Dropped → warn + remove files. All dropped → skip update, leave files, user decides. New → ignore. Runs after clone but before nuke in cs-4-4's corrected pipeline.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:46:08Z","updated":"2026-02-20T10:29:18Z","closed":"2026-02-20T10:29:18Z"}
{"id":"tick-7c0be9","title":"cs-4-8: Update Command: All-Plugins Mode","status":"done","priority":2,"description":"**Problem**: npx agntc update (no args) should update all installed plugins.\n\n**Solution**: No-arg mode: read manifest → parallel checkForUpdate → categorize → sequential processing per type → single manifest write → aggregate summary. Partial failures continue.\n\n**Outcome**: Processes all plugins. Mixed types handled. Partial failures noted. Summary per-plugin.\n\n**Do**:\n1. No-arg branch: readManifest → empty → message, exit 0\n2. Spinner: parallel checkForUpdate for all\n3. Categorize: update-available, local, newer-tags, up-to-date, check-failed\n4. Process updatable sequentially (nuke-and-reinstall / local re-copy)\n5. Tag-pinned: info only. Check-failed: note. All up-to-date: brief message.\n6. Single manifest write. Partial failures caught per-plugin.\n7. Aggregate summary\n\n**Acceptance Criteria**: All entries checked in parallel, each type processed correctly, partial failure continues, single manifest write, all up-to-date message, per-plugin summary.\n\n**Tests**: all entries processed, empty manifest, parallel checks, mixed types, partial failure continues, failed noted, single write, all up-to-date, per-plugin summary, spinner shown.\n\n**Context**: Spec: no-arg updates all. npm/brew convention. Each plugin independent.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:46:08Z","updated":"2026-02-20T10:42:07Z","closed":"2026-02-20T10:42:07Z"}
{"id":"tick-4ec9ff","title":"cs-4-9: Update Command: Network Retry","status":"cancelled","priority":2,"description":"**Problem**: Clone failures during update have unique context: files already nuked. Need proper error handling for this state.\n\n**Solution**: Verify cloneSource retry applies during update. Handle post-nuke clone failure: surface git error clearly with context that files have been removed.\n\n**Outcome**: Transient failures retried. Auth aborts immediately. Post-nuke failure produces actionable error.\n\n**Do**:\n1. Ensure cloneSource errors after nuke caught with context message\n2. Post-nuke clone failure: surface git error clearly with context that files have been removed\n3. Verify 3x retry applies during update\n4. Verify auth failure immediate abort\n5. Create update-specific clone failure tests\n\n**Acceptance Criteria**: Transient retried 3x, retry success completes update, auth aborts immediately, post-nuke failure surfaces git error with context, temp dir cleaned, all-plugins mode continues after one failure.\n\n**Tests**: transient retry, retry succeeds, auth abort, post-nuke error with context, temp dir cleaned, all-plugins continues, failed noted in summary.\n\n**Context**: Spec: 3x retry transient, no retry auth. Update adds nuance: files nuked before clone. Failure = degraded state. Spec does not prescribe specific recovery behavior for post-nuke clone failure — surface the error clearly and let the user decide next steps.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:46:08Z","updated":"2026-02-19T12:05:12Z","closed":"2026-02-19T12:05:12Z"}
{"id":"tick-32d35f","title":"cs-4-10: Update and Remove Output Formatting","status":"done","priority":2,"description":"**Problem**: Remove and update have functional logic but output needs polishing to match spec examples.\n\n**Solution**: Consistent @clack/prompts formatting for both commands. Exact spec message strings for agent compat warnings. Per-agent asset counts matching add command style.\n\n**Outcome**: Both commands produce clear output matching spec. All status variants formatted.\n\n**Do**:\n1. Remove confirmation: files grouped by type (skill dirs, agent files, hook files)\n2. Remove summary: \"Removed {key}\" with counts\n3. Update single: \"Updated {key}[@{ref}]: {old} → {new}\" + per-agent counts (non-zero only)\n4. Update all summary: per-plugin result line per status variant\n5. Agent compat messages match spec exactly: \"Plugin {key} no longer declares support for {agent}...\" and \"Updated for Claude. Codex support removed by plugin author — Codex files removed.\"\n6. Tag info: available tags + re-add command\n7. Spinners during clone/copy, intro/outro bookends\n8. Collection remove: list all affected plugins\n\n**Acceptance Criteria**: Remove files grouped by type, remove summary with counts, update shows commit transition, per-agent counts (non-zero only), tag info with re-add, check-failed noted, local shows re-copy, agent drop warning matches spec text, all up-to-date brief, spinners, intro/outro.\n\n**Tests**: remove file grouping, remove summary, update commit transition, per-agent counts, zero-count omitted, all-plugins per-plugin lines, tag list + re-add, check-failed, local message, agent drop spec text, all up-to-date, spinners, intro/outro, collection lists affected, partial failure distinguished.\n\n**Context**: Spec output examples lines 426-437. Consistent with add command summary style. @clack/prompts throughout.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:46:08Z","updated":"2026-02-20T10:48:26Z","closed":"2026-02-20T10:48:26Z"}
{"id":"tick-71886c","title":"Phase 5: List Dashboard and Error Hardening","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-18T21:48:24Z","updated":"2026-02-18T21:48:24Z"}
{"id":"tick-0f3e21","title":"cs-5-1: Parallel Update Check for All Plugins","status":"done","priority":2,"description":"**Problem**: List dashboard needs update status for all plugins. checkForUpdate handles one at a time. Need parallel bulk check behind spinner.\n\n**Solution**: Create checkAllForUpdates running checkForUpdate in parallel. Returns Map\u003cstring, UpdateCheckResult\u003e. Local plugins return immediately.\n\n**Outcome**: Tested parallel checker. Individual failures yield check-failed without blocking others. Empty manifest returns empty map.\n\n**Do**:\n1. Create src/update-check-all.ts: checkAllForUpdates(manifest) → Map\u003cstring, UpdateCheckResult\u003e\n2. Promise.all for parallel checks. Individual check failures → check-failed.\n3. Local → immediate (no remote check).\n4. Create tests mocking checkForUpdate\n\n**Acceptance Criteria**: All checked in parallel, individual failures isolated, local skips remote, empty manifest → empty map, mixed statuses handled.\n\n**Tests**: update-available, up-to-date, check-failed on failure, local immediate, empty manifest, all failing, mixed statuses, parallel not sequential, newer-tags for tag-pinned.\n\n**Context**: Spec: spinner then parallel ls-remote. Used by list dashboard and potentially update-all.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:52:23Z","updated":"2026-02-20T10:51:52Z","closed":"2026-02-20T10:51:52Z"}
{"id":"tick-b0cb9a","title":"cs-5-2: List View: Plugin List with Status Indicators","status":"done","priority":2,"description":"**Problem**: Phase 1 list is static read-only. Spec requires interactive selectable list with status indicators.\n\n**Solution**: Rewrite list command: readManifest → empty state → checkAllForUpdates with spinner → @clack/prompts select with status indicators → Done exits → selection returns key.\n\n**Outcome**: Interactive list with coloured status indicators. Done exits. Plugin selection enters detail view. Replaces cs-1-11.\n\n**Do**:\n1. Rewrite src/commands/list.ts replacing Phase 1 implementation\n2. Empty manifest → spec message, exit 0\n3. Spinner → checkAllForUpdates → build select options with status indicators per spec table\n4. Done option at bottom. Cancel = Done.\n5. Return selected key for navigation loop\n\n**Acceptance Criteria**: Empty state message, spinner during checks, correct status indicators with colours, ref shown when pinned, Done exits, cancel exits, single plugin shows list.\n\n**Tests**: empty state, spinner, all 5 status indicators, ref display, Done, cancel, single plugin, all-local, long keys.\n\n**Context**: Spec: selectable list, status indicators table, Done at bottom. Replaces cs-1-11.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:52:24Z","updated":"2026-02-20T10:57:12Z","closed":"2026-02-20T10:57:12Z"}
{"id":"tick-d19707","title":"cs-5-3: Detail View: Plugin Information Display","status":"done","priority":2,"description":"**Problem**: No detail view when plugin selected. Need to show full info and action options.\n\n**Solution**: Create renderDetailView showing key, ref, commit (7 chars), date, agents, per-agent counts, file list. Actions vary by update status per spec table.\n\n**Outcome**: Detail view renders all info. Actions vary by status. Local/HEAD/tag refs displayed correctly.\n\n**Do**:\n1. Create src/commands/list-detail.ts: renderDetailView({ key, entry, updateStatus }) → Action\n2. Display all fields. Compute asset counts from files array.\n3. Action select per spec status table.\n4. Cancel = Back.\n\n**Acceptance Criteria**: All fields displayed, ref variants correct, commit truncated, counts computed, actions match spec table, cancel = Back.\n\n**Tests**: all fields, local/HEAD/tag refs, commit truncation, asset counts, each action set by status, cancel, many files.\n\n**Context**: Spec detail view: all fields listed. Actions per status table.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:52:24Z","updated":"2026-02-20T11:05:38Z","closed":"2026-02-20T11:05:38Z"}
{"id":"tick-9d07b8","title":"cs-5-4: Detail View: Update Action","status":"done","priority":2,"description":"**Problem**: Update action selected from detail view but not wired. Need inline update staying in detail view.\n\n**Solution**: Execute update pipeline inline. Remote: clone to temp → agent compat check → nuke → copy (reuse cs-4-4 pipeline). Local: nuke → re-copy. Refresh detail view with success indicator. Failure shows error, stays in detail.\n\n**Outcome**: Update from detail view works. Refreshes with new data. Handles failures gracefully. All-agents-dropped aborts before nuke.\n\n**Do**:\n1. Handle update action in list-detail.ts\n2. Remote: clone to temp → agent compat check → nuke → copy (reuse cs-4-4 pipeline). Local: nuke → re-copy from path. Reuse Phase 4 logic.\n3. Success: return updated entry for refresh. Failure: show error, stay in detail.\n4. Handle agent compat changes (all-agents-dropped aborts before nuke, preserving existing files). Spinner during operations.\n\n**Acceptance Criteria**: Clone-then-nuke for remote, re-copy for local, detail refreshes on success, error stays in detail, agent compat handled (all-dropped aborts before nuke), spinner shown, temp dir cleaned, manifest updated.\n\n**Tests**: remote update, local update, success refresh, failure stays, agent compat, clone failure before nuke (existing files preserved), all-agents-dropped aborts before nuke, temp dir cleanup.\n\n**Context**: Spec: after Update remain in detail with refreshed info + success indicator. Reuses cs-4-4's corrected clone-before-nuke pipeline. No confirmation prompt.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:52:24Z","updated":"2026-02-20T11:13:59Z","closed":"2026-02-20T11:13:59Z"}
{"id":"tick-ba9807","title":"cs-5-5: Detail View: Remove Action","status":"done","priority":2,"description":"**Problem**: Remove action from detail view not wired. Need confirm → nuke → remove entry → return to list.\n\n**Solution**: Show files, confirm, nuke, remove entry, write manifest, return to list with message. Reuse cs-4-1 logic.\n\n**Outcome**: Remove from detail confirms, deletes, returns to list. Last plugin → empty state.\n\n**Do**:\n1. Handle remove action in list-detail.ts\n2. List files, confirm. Declined → Back.\n3. nukeManifestFiles, remove entry, writeManifest.\n4. Return removed action for list navigation.\n\n**Acceptance Criteria**: Files shown, declined = Back, confirmed removes + returns to list, last plugin → empty state, ENOENT tolerance, manifest updated.\n\n**Tests**: confirmation shown, declined, confirmed removes, returns to list, last plugin empty state, ENOENT tolerance, manifest preserves others.\n\n**Context**: Spec: after Remove return to list. Always confirm. Reuses cs-4-1 mechanics.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:52:24Z","updated":"2026-02-20T11:18:45Z","closed":"2026-02-20T11:18:45Z"}
{"id":"tick-39a172","title":"cs-5-6: Detail View: Change Version Action","status":"done","priority":2,"description":"**Problem**: Tag-pinned plugins with newer tags need Change version action. Not wired yet.\n\n**Solution**: Fetch tags via ls-remote, present selectable list (newest first), selection triggers clone-before-nuke reinstall at new tag. Agent compat checked before nuke. Remain in detail view.\n\n**Outcome**: Tag list presented, selection installs new version with correct pipeline, detail refreshes. All-agents-dropped preserves files.\n\n**Do**:\n1. Handle change-version in list-detail.ts\n2. Fetch tags, sort newest first. No tags → message, Back. Cancel → Back. Same tag → message, Back.\n3. Different tag: clone at new tag to temp → re-read agntc.json → agent compat check (reuse cs-4-7) → if all agents dropped: warn, cleanup temp, Back → if proceeding: nuke → copy from temp → update manifest with new ref + commit → cleanup temp. Reuse cs-4-4 pipeline with new ref.\n\n**Acceptance Criteria**: Tags newest-first, no tags handled, cancel = Back, same tag message, different tag triggers clone-before-nuke reinstall, agent compat checked before nuke, all-agents-dropped aborts (preserves files), manifest updated with new ref and commit, detail refreshes, temp dir cleaned.\n\n**Tests**: tags displayed, no tags, cancel, same tag, different tag reinstall with clone-before-nuke, agent compat checked, all-agents-dropped preserves files, manifest updated, refreshed detail, network failure, temp dir cleanup.\n\n**Context**: Spec: Change version = same mechanics as update with new ref. Uses cs-4-4 corrected clone-before-nuke pipeline.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:53:06Z","updated":"2026-02-20T11:24:03Z","closed":"2026-02-20T11:24:03Z"}
{"id":"tick-bb6c3b","title":"cs-5-7: List Navigation Loop","status":"done","priority":2,"description":"**Problem**: List and detail views exist but no loop connects them. Must re-run command after every action.\n\n**Solution**: While loop: list view → selection → detail → action → route (stay/return/exit). Re-read manifest each iteration. Removing last plugin → empty state.\n\n**Outcome**: Continuous interactive loop. Update/remove/navigate without restarting.\n\n**Do**:\n1. While loop in list.ts\n2. renderListView → Done/cancel = exit. Selection → renderDetailView → action routing.\n3. Back → continue. Removed → re-read manifest, continue. Updated → refresh detail.\n4. Empty manifest after remove → empty state, break.\n\n**Acceptance Criteria**: Back → list, Remove → list (plugin gone), Update → detail refresh, Done exits, cancel exits, last removed → empty state, manifest re-read, successive actions work.\n\n**Tests**: Back to list, Done exits, cancel exits, Remove returns to list, Update refreshes, last plugin → empty, successive actions, no stale data.\n\n**Context**: Spec: post-action routing table. Loop ties cs-5-2 through cs-5-6 together.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:53:06Z","updated":"2026-02-20T11:39:05Z","closed":"2026-02-20T11:39:05Z"}
{"id":"tick-95a48e","title":"cs-5-8: Partial Copy Failure Rollback","status":"done","priority":2,"description":"**Problem**: Copy failure midway leaves half-installed plugin. Spec requires rollback.\n\n**Solution**: Track copied paths during copy. On error, delete all tracked paths. Best-effort rollback (ENOENT skip, log other errors). Re-throw original error.\n\n**Outcome**: Copy failure rolls back all files. No manifest entry. Clean state.\n\n**Do**:\n1. Modify copyBareSkill/copyPluginAssets to track copiedFiles progressively\n2. try/catch: on error → rollbackCopiedFiles(tracked, projectDir)\n3. Create src/copy-rollback.ts: delete each path, ENOENT skip, log other errors\n4. Re-throw original error after rollback\n\n**Acceptance Criteria**: Failure triggers rollback, tracked files deleted, ENOENT skipped, rollback failure logged not thrown, original error propagated, no manifest entry, both copy functions support rollback, rollback after overwriting another plugin's file deletes the new copy (previous plugin's asset unrecoverable — accepted edge case per spec, user can update that plugin to restore).\n\n**Tests**: rollback on failure, no manifest entry, original error propagated, ENOENT skipped, rollback failure logged, successful copy unaffected, progressive tracking, both copy functions, rollback after cross-plugin overwrite deletes new copy (accepted loss).\n\n**Context**: Spec: rollback to clean state. Half-installed worse than none. Rollback edge case (cross-plugin overwrite) accepted per spec: \"If a copy fails after overwriting a file owned by another plugin, rollback deletes the new copy but the previous plugin's asset is already gone. Accepted as a narrow edge case — user can update the previous plugin to restore its files.\"\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:53:06Z","updated":"2026-02-20T11:44:33Z","closed":"2026-02-20T11:44:33Z"}
{"id":"tick-e908a4","title":"cs-5-9: Multi-Plugin Independent Failure Handling","status":"done","priority":2,"description":"**Problem**: Collection plugin failure can affect others. Need independent processing.\n\n**Solution**: Wrap per-plugin processing in try/catch. Track outcomes (installed/failed/skipped). Failed plugins rolled back. Successful ones keep manifest entries. Single manifest write.\n\n**Outcome**: Fault-tolerant collection installs. Individual failures isolated. Summary shows outcomes.\n\n**Do**:\n1. try/catch per plugin in collection flow\n2. Track outcomes: installed/failed/skipped with details\n3. Failed: rollback (cs-5-8). Successful: collect entry.\n4. Single writeManifest with successful entries only.\n5. All-fail exits 0 with summary.\n\n**Acceptance Criteria**: Each plugin independent, failed rolled back, successful preserved, single manifest write, all-fail exits 0, summary distinguishes outcomes, first succeeds + second fails works.\n\n**Tests**: first succeeds second fails, all fail, rollback on failure, skipped alongside failed, single manifest write, three plugins mixed, all succeed normal.\n\n**Context**: Spec: each plugin independent. Success keeps entry, failure rolls back. Summary per-plugin outcome.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:53:06Z","updated":"2026-02-20T11:53:46Z","closed":"2026-02-20T11:53:46Z"}
{"id":"tick-1028ba","title":"cs-5-10: Comprehensive Summary Output","status":"done","priority":2,"description":"**Problem**: Summary output is implemented inline across add (cs-1-10, cs-2-2, cs-2-4), update (cs-4-10), and remove (cs-4-1, cs-4-2) commands. Code is duplicated and formatting may have diverged. Need to extract into a single module for consistency and maintainability.\n\n**Solution**: Extract existing inline summary formatting from all commands into a shared src/summary.ts module with renderAddSummary, renderUpdateSummary, renderRemoveSummary. Unify formatting patterns. Wire back into all commands, replacing inline code. No new output behaviour — this is a refactoring task ensuring consistency with spec examples.\n\n**Outcome**: All commands produce consistent spec-compliant summaries via shared module. Mixed outcomes clearly formatted.\n\n**Do**:\n1. Create src/summary.ts extracting existing formatting from add, update, remove commands\n2. renderAddSummary: key+ref, per-agent counts (non-zero), failed/skipped noted for collections\n3. renderUpdateSummary: commit transition, per-plugin status, tag info, agent compat messages\n4. renderRemoveSummary: key + counts\n5. Wire into all commands replacing inline summary code\n\n**Acceptance Criteria**: Add matches spec format, collections show per-plugin, update shows transitions, tag info, agent compat spec text, remove shows counts, no zero-count lines, no empty agent sections, consistent @clack usage, no new output behaviour (refactoring only).\n\n**Tests**: add format, zero-count omitted, collection summaries, failed/skipped noted, update transitions, tag re-add command, agent drop spec text, remove counts, mixed outcomes, all up-to-date, single plugin concise.\n\n**Context**: Refactoring extraction task. Inline formatting built across Phases 1-4. This task unifies for consistency. Spec summary examples lines 337-346, 426-437.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:53:06Z","updated":"2026-02-20T12:04:17Z","closed":"2026-02-20T12:04:17Z"}
{"id":"tick-9b3876","title":"Phase 6: Analysis (Cycle 1)","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-20T13:12:57Z","updated":"2026-02-20T13:12:57Z"}
{"id":"tick-7180d4","title":"cs-6-1: Extract shared nuke-and-reinstall pipeline","status":"done","priority":2,"description":"**Problem**: The core update pipeline (readConfig, computeEffectiveAgents, detectType, build agent+driver pairs, nukeManifestFiles, conditional copy, construct ManifestEntry) is independently implemented 6+ times across src/commands/update.ts, src/commands/list-update-action.ts, and src/commands/list-change-version-action.ts. This is ~250 lines of near-identical logic with minor variations in error handling style and ManifestEntry field construction. The dropped-agents warning message string is copy-pasted identically across all of them.\n\n**Solution**: Extract a shared function (e.g., executeNukeAndReinstall) in a new module (e.g., src/nuke-reinstall-pipeline.ts) that takes a sourceDir, manifest entry, key, projectDir, and an options bag (onWarn callback, new ref/commit values) and returns the new ManifestEntry + copiedFiles. Each call site reduces to: resolve sourceDir, call the shared pipeline, handle the result per its own error convention.\n\n**Outcome**: One canonical implementation of the nuke-and-reinstall pipeline. Call sites in update.ts (runGitUpdate, runLocalUpdate, processGitUpdateForAll, processLocalUpdateForAll), list-update-action.ts, and list-change-version-action.ts each become thin wrappers (~10 lines) that resolve the source directory and call the shared function. ~200 lines of duplicate code eliminated.\n\n**Do**:\n1. Create src/nuke-reinstall-pipeline.ts with a function that encapsulates the shared pipeline: readConfig from sourceDir, compute effective agents (intersection of manifest agents and new config agents), detect type, build agent+driver pairs, nuke existing manifest files, copy (plugin or bare-skill), construct new ManifestEntry\n2. Define an options interface for the function: { key: string; sourceDir: string; existingEntry: ManifestEntry; projectDir: string; newRef?: string | null; newCommit?: string | null; onAgentsDropped?: (dropped: string[], kept: string[]) =\u003e void }\n3. Return a result object: { entry: ManifestEntry; copiedFiles: string[]; droppedAgents: string[] }\n4. Refactor runGitUpdate and runLocalUpdate in update.ts to use the shared function\n5. Refactor processGitUpdateForAll and processLocalUpdateForAll in update.ts to use the shared function\n6. Refactor runRemoteUpdate and runLocalUpdate in list-update-action.ts to use the shared function\n7. Refactor executeChangeVersionAction in list-change-version-action.ts to use the shared function\n8. Consolidate the buildParsedSource/getSourceDir helpers that were only needed because the pipeline was duplicated (see also Task 10)\n9. Ensure all existing tests pass -- update mocks as needed to point at the new module\n\n**Acceptance Criteria**:\n- The nuke-and-reinstall sequence exists in exactly one function\n- All 6+ call sites delegate to the shared function\n- No behavioral changes -- same warnings, same manifest entries, same error handling at each call site\n- All existing unit tests pass (with updated mocks where needed)\n\n**Tests**:\n- Unit test the shared pipeline function with mocked dependencies: verify it calls nukeManifestFiles, readConfig, detectType, copy functions, and returns correct ManifestEntry\n- Test that dropped-agents warning callback is invoked when new config removes agents\n- Test that when all agents are dropped, the function returns appropriately (no copy, signal to caller)\n- Verify existing command-level tests still pass after refactor","parent":"tick-9b3876","created":"2026-02-20T13:13:23Z","updated":"2026-02-20T13:26:50Z","closed":"2026-02-20T13:26:50Z"}
{"id":"tick-cf8b24","title":"cs-6-2: Add collection prefix matching to update command","status":"done","priority":2,"description":"**Problem**: The spec defines three invocation modes for update: no-arg (all), owner/repo (specific plugin or all from collection), and owner/repo/plugin-name (specific collection plugin). The implementation does a direct manifest lookup (manifest[key]) which fails with \"Plugin {key} is not installed\" when owner/repo is passed but the manifest only contains collection entries like owner/repo/plugin-name. The remove command correctly implements this via resolveTargetKeys with prefix matching, but update lacks equivalent logic.\n\n**Solution**: Add prefix-matching logic to runUpdate in src/commands/update.ts (similar to resolveTargetKeys in src/commands/remove.ts) so that npx agntc update owner/repo resolves to all collection plugins under that prefix and updates them sequentially.\n\n**Outcome**: npx agntc update owner/repo correctly finds and updates all collection plugins whose keys start with owner/repo/, matching the spec and the behavior already implemented in the remove command.\n\n**Do**:\n1. Extract or reuse the resolveTargetKeys logic from src/commands/remove.ts -- either import it directly or extract to a shared manifest utility\n2. In runUpdate (src/commands/update.ts), replace the direct manifest[key] lookup with prefix-matching resolution\n3. When prefix matching finds multiple keys, iterate and update each one sequentially (same as remove does)\n4. When prefix matching finds zero keys, display \"Plugin {key} is not installed.\" and exit with non-zero code (existing behavior)\n5. Ensure the single-key exact match path still works as before\n\n**Acceptance Criteria**:\n- npx agntc update owner/repo updates all collection plugins under that prefix\n- npx agntc update owner/repo/plugin-name updates that specific plugin (exact match)\n- npx agntc update nonexistent/repo shows \"Plugin nonexistent/repo is not installed.\" error\n- Behavior matches the remove command's resolution logic\n\n**Tests**:\n- Test that update owner/repo resolves to multiple collection keys and updates each\n- Test that update owner/repo/plugin-name resolves to exact match\n- Test that update nonexistent/key produces the correct error message\n- Test edge case: owner/repo exists as both a standalone key and a collection prefix -- exact match takes priority","parent":"tick-9b3876","created":"2026-02-20T13:13:39Z","updated":"2026-02-20T13:36:18Z","closed":"2026-02-20T13:36:18Z"}
{"id":"tick-a00a08","title":"cs-6-3: Fix nuke-before-copy data loss risk on copy failure","status":"done","priority":2,"description":"**Problem**: In the update pipeline, the sequence is: nuke existing files -\u003e copy new files. If copy fails after nuke (disk full, permission error), the user's installed files are gone with no recovery path. The spec says \"Rollback to clean state\" for partial copy failures, but rollback only deletes newly-copied files -- it cannot restore the nuked originals. This is a latent data-loss risk.\n\n**Solution**: Before nuking, record the list of files that will be removed. If copy fails after nuke, log a clear recovery message: \"Update failed after removing old files. Run npx agntc update {key} to retry.\" This is the minimum viable safety net within the current nuke-and-reinstall architecture. A more robust fix (staging area + atomic swap) can be considered later.\n\n**Outcome**: Users who hit a copy failure during update get a clear, actionable message telling them how to recover, rather than being left in a silently broken state.\n\n**Do**:\n1. In the nuke-and-reinstall pipeline (whether in the shared function from Task 1 or in the current individual implementations), wrap the copy step in a try/catch\n2. If copy fails after nuke has completed, catch the error and log a prominent warning: \"Update failed for {key} after removing old files. The plugin is currently uninstalled. Run npx agntc update {key} to retry installation.\"\n3. Remove the plugin's manifest entry (since files are gone) so the state is consistent -- or alternatively, keep the entry so update can retry\n4. Re-throw or return the error so the caller can handle it appropriately\n5. This task is independent of Task 1 -- apply to whichever code structure exists at execution time\n\n**Acceptance Criteria**:\n- Copy failure after nuke produces a clear, user-facing recovery message\n- The manifest state is consistent with the filesystem state after failure\n- No silent data loss -- the user always knows what happened and how to fix it\n\n**Tests**:\n- Mock copy to throw after nuke succeeds, verify the recovery message is output\n- Verify manifest state is consistent after copy failure (entry removed or marked for retry)\n- Verify the error propagates to the caller","parent":"tick-9b3876","created":"2026-02-20T13:13:54Z","updated":"2026-02-20T13:48:59Z","closed":"2026-02-20T13:48:59Z"}
{"id":"tick-8387d9","title":"cs-6-4: Strengthen type safety for AssetType, AgentId, and AgentWithDriver","status":"done","priority":2,"description":"**Problem**: Three related type safety gaps: (1) AgentDriver.getTargetDir accepts string when the valid asset types are the known finite set \"skills\" | \"agents\" | \"hooks\". (2) ManifestEntry.agents and AgntcConfig.agents are typed as string[] instead of AgentId[], forcing as AgentId[] casts at ~12 call sites. (3) The AgentWithDriver interface is independently declared in 3 files (copy-bare-skill.ts, copy-plugin-assets.ts, compute-incoming-files.ts).\n\n**Solution**: (1) Define type AssetType = typeof ASSET_DIRS[number] and use it in getTargetDir(assetType: AssetType). (2) Change ManifestEntry.agents and AgntcConfig.agents to AgentId[]. (3) Export AgentWithDriver from src/drivers/types.ts and import in the three consuming files.\n\n**Outcome**: Compile-time validation catches invalid asset type strings and agent identifiers. No more as AgentId[] casts. AgentWithDriver defined once.\n\n**Do**:\n1. In src/type-detection.ts, export type AssetType = typeof ASSET_DIRS[number]\n2. In src/drivers/types.ts, change getTargetDir(assetType: string) to getTargetDir(assetType: AssetType) (import AssetType from type-detection)\n3. Update src/drivers/claude-driver.ts and src/drivers/codex-driver.ts internal TARGET_DIRS records to use Partial\u003cRecord\u003cAssetType, string\u003e\u003e\n4. In src/drivers/types.ts, add export interface AgentWithDriver { id: AgentId; driver: AgentDriver }\n5. Remove the local AgentWithDriver declarations from src/copy-bare-skill.ts, src/copy-plugin-assets.ts, src/compute-incoming-files.ts and import from src/drivers/types.ts\n6. In src/manifest.ts, change ManifestEntry.agents from string[] to AgentId[] (import AgentId from drivers/types)\n7. In src/config.ts, change AgntcConfig.agents from string[] to AgentId[]\n8. Remove all as AgentId[] casts across the codebase (at least 12 occurrences in add.ts, update.ts, list-update-action.ts, list-change-version-action.ts)\n9. Fix any resulting type errors -- the validation in readConfig already filters to known agents, so the return type naturally becomes AgentId[]\n10. Verify all tests compile and pass\n\n**Acceptance Criteria**:\n- getTargetDir only accepts \"skills\" | \"agents\" | \"hooks\" at compile time\n- ManifestEntry.agents and AgntcConfig.agents are typed AgentId[]\n- Zero as AgentId[] casts remain in the codebase\n- AgentWithDriver is defined in exactly one file and imported elsewhere\n- All tests pass\n\n**Tests**:\n- Existing unit tests should pass without modification (behavioral no-op)\n- Verify TypeScript compilation catches a test file that passes an invalid string to getTargetDir (manual check during development)","parent":"tick-9b3876","created":"2026-02-20T13:14:10Z","updated":"2026-02-20T14:01:44Z","closed":"2026-02-20T14:01:44Z"}
{"id":"tick-42ff1b","title":"cs-6-5: Store original clone URL in manifest to fix non-GitHub update flows","status":"done","priority":2,"description":"**Problem**: update-check.ts derives the clone URL from the manifest key by hardcoding https://github.com/${owner}/${repo}.git. The same pattern is repeated via buildParsedSource in update.ts and list-update-action.ts. Plugins originally installed via HTTPS from GitLab/Bitbucket or via SSH will have update checks and re-clones pointed at github.com instead of the original host. The manifest stores only owner/repo as the key -- the original host is lost during key derivation.\n\n**Solution**: Add a cloneUrl: string | null field to ManifestEntry. Populate it during add from the parsed source. Use it during update checks and re-clones instead of reconstructing from the key. null for local path installs.\n\n**Outcome**: Update checks and re-clones use the original clone URL, correctly handling non-GitHub git hosts and SSH URLs.\n\n**Do**:\n1. Add cloneUrl: string | null to the ManifestEntry interface in src/manifest.ts\n2. In the add command (src/commands/add.ts), populate cloneUrl from the parsed source (the full HTTPS/SSH URL, or null for local paths)\n3. In src/update-check.ts, use entry.cloneUrl instead of deriveCloneUrl(key) for git ls-remote. Fall back to the github.com derivation if cloneUrl is null (backward compatibility with existing manifests)\n4. In src/commands/update.ts, use entry.cloneUrl for re-cloning instead of rebuilding from key\n5. In src/commands/list-update-action.ts and src/commands/list-change-version-action.ts, use entry.cloneUrl for re-cloning\n6. Handle backward compatibility: existing manifests without cloneUrl fall back to current github.com derivation behavior\n7. Update all tests that construct ManifestEntry objects to include the new field\n\n**Acceptance Criteria**:\n- ManifestEntry has a cloneUrl field\n- New installs store the original clone URL\n- Update checks use the stored URL, not a reconstructed one\n- Existing manifests without cloneUrl still work (backward compatible)\n\n**Tests**:\n- Test that add from a GitLab HTTPS URL stores the correct cloneUrl\n- Test that add from SSH URL stores the correct cloneUrl\n- Test that add from local path stores null\n- Test that update-check uses entry.cloneUrl when available\n- Test backward compatibility: entry without cloneUrl falls back to github.com derivation","parent":"tick-9b3876","created":"2026-02-20T13:14:23Z","updated":"2026-02-20T14:18:55Z","closed":"2026-02-20T14:18:55Z"}
{"id":"tick-c04b35","title":"cs-6-6: Fix config validation error messages to include spec-required prefix","status":"done","priority":2,"description":"**Problem**: The spec defines error messages \"Invalid agntc.json: agents field is required\" and \"Invalid agntc.json: agents must not be empty\". The implementation throws ConfigError with messages \"agents field is required\" and \"agents must not be empty\" -- missing the \"Invalid agntc.json:\" prefix. The JSON parse error correctly includes the prefix, but the structural validation errors do not.\n\n**Solution**: Add the \"Invalid agntc.json: \" prefix to the two structural validation error messages in src/config.ts.\n\n**Outcome**: All config validation errors consistently include the spec-required prefix.\n\n**Do**:\n1. In src/config.ts line 50, change the error message from \"agents field is required\" to \"Invalid agntc.json: agents field is required\"\n2. In src/config.ts line 56, change the error message from \"agents must not be empty\" to \"Invalid agntc.json: agents must not be empty\"\n3. Update any tests that assert on these exact error message strings\n\n**Acceptance Criteria**:\n- Missing agents field error: \"Invalid agntc.json: agents field is required\"\n- Empty agents array error: \"Invalid agntc.json: agents must not be empty\"\n- Matches the spec exactly\n\n**Tests**:\n- Test that missing agents field produces error with \"Invalid agntc.json:\" prefix\n- Test that empty agents array produces error with \"Invalid agntc.json:\" prefix","parent":"tick-9b3876","created":"2026-02-20T13:14:29Z","updated":"2026-02-20T14:21:59Z","closed":"2026-02-20T14:21:59Z"}
{"id":"tick-a4046d","title":"cs-6-7: Fix computeIncomingFiles granularity for plugin collision/unmanaged checks","status":"done","priority":2,"description":"**Problem**: The spec states unmanaged conflict detection operates at the \"asset level\" -- each skill directory, each agent file, each hook file is one conflict. The computePluginFiles function in src/compute-incoming-files.ts produces parent target directory paths (e.g., .claude/skills/, .claude/agents/) rather than individual asset paths within those directories. This means collision and unmanaged checks operate at the wrong granularity for plugin mode. Bare-skill mode is correct.\n\n**Solution**: computePluginFiles should scan the source asset directories and produce individual asset-level paths (e.g., .claude/skills/planning/, .claude/agents/executor.md) rather than parent directory paths.\n\n**Outcome**: Collision and unmanaged conflict checks operate at the correct asset-level granularity as specified, enabling accurate per-asset conflict detection for plugins.\n\n**Do**:\n1. Modify computePluginFiles in src/compute-incoming-files.ts to accept the source directory as an additional parameter\n2. For each asset type directory found (skills/, agents/, hooks/), scan its contents to enumerate individual assets\n3. For skills: each subdirectory becomes a path entry (e.g., .claude/skills/planning/)\n4. For agents: each file becomes a path entry (e.g., .claude/agents/executor.md)\n5. For hooks: each file becomes a path entry (e.g., .claude/hooks/pre-commit.sh)\n6. Update all call sites of computePluginFiles to pass the source directory\n7. Verify that checkFileCollisions and checkUnmanagedFiles work correctly with the new fine-grained paths\n8. Update existing tests for compute-incoming-files\n\n**Acceptance Criteria**:\n- Plugin incoming files are enumerated at individual asset level, not parent directory level\n- Skill directories, agent files, and hook files each produce their own path entry\n- Collision checks match at asset granularity\n- Bare-skill mode behavior unchanged\n\n**Tests**:\n- Test computePluginFiles with a source dir containing skills/planning/, skills/review/, agents/executor.md -- verify all individual paths are produced\n- Test that collision check correctly identifies overlapping individual assets between plugins\n- Test that unmanaged check correctly identifies individual existing assets","parent":"tick-9b3876","created":"2026-02-20T13:14:45Z","updated":"2026-02-20T14:27:59Z","closed":"2026-02-20T14:27:59Z"}
{"id":"tick-a3306f","title":"cs-6-8: Extract shared isNodeError type guard","status":"done","priority":2,"description":"**Problem**: The identical function isNodeError(err: unknown): err is NodeJS.ErrnoException checking err instanceof Error \u0026\u0026 \"code\" in err is defined independently in src/config.ts, src/manifest.ts, and src/nuke-files.ts.\n\n**Solution**: Extract to a shared utility module and import from the three consuming files.\n\n**Outcome**: One definition of isNodeError, imported by all consumers. Eliminates copy-paste drift risk.\n\n**Do**:\n1. Create src/errors.ts (or add to an existing utils module) with the exported isNodeError function\n2. Remove the local isNodeError from src/config.ts, src/manifest.ts, and src/nuke-files.ts\n3. Add import { isNodeError } from \"./errors\" to each file\n4. Verify all tests pass\n\n**Acceptance Criteria**:\n- isNodeError is defined in exactly one file\n- All three consumers import from the shared location\n- No behavioral change\n\n**Tests**:\n- Existing tests should pass without modification","parent":"tick-9b3876","created":"2026-02-20T13:14:52Z","updated":"2026-02-20T14:31:10Z","closed":"2026-02-20T14:31:10Z"}
{"id":"tick-6b7df4","title":"cs-6-9: Extract shared execGit helper","status":"done","priority":2,"description":"**Problem**: Both src/git-clone.ts and src/update-check.ts define their own execGit wrapper around child_process.execFile. The implementations are structurally identical -- promise wrapper, git error with stderr, resolve/reject. Only the timeout differs (60s for clone, 15s for update-check).\n\n**Solution**: Extract a shared execGit(args, options?) into src/git-utils.ts that accepts an optional timeout parameter with a sensible default.\n\n**Outcome**: One execGit implementation, two call sites passing their desired timeouts.\n\n**Do**:\n1. Create src/git-utils.ts with execGit(args: string[], options?: { timeout?: number; cwd?: string }): Promise\u003cstring\u003e\n2. Move the promise-wrapped execFile logic from either file into the shared module\n3. Update src/git-clone.ts to import and use the shared execGit with { timeout: 60_000 }\n4. Update src/update-check.ts to import and use the shared execGit with { timeout: 15_000 }\n5. Verify all tests pass\n\n**Acceptance Criteria**:\n- execGit is defined in exactly one file\n- Both consumers import from the shared location and pass their own timeouts\n- No behavioral change\n\n**Tests**:\n- Existing git-clone and update-check tests should pass without modification","parent":"tick-9b3876","created":"2026-02-20T13:14:58Z","updated":"2026-02-20T14:36:01Z","closed":"2026-02-20T14:36:01Z"}
{"id":"tick-8fe97c","title":"cs-6-10: Extract shared buildParsedSource and getSourceDir helpers","status":"done","priority":2,"description":"**Problem**: Both buildParsedSource(key, ...) and getSourceDir(tempDir, key) are independently implemented in src/commands/update.ts, src/commands/list-update-action.ts, and src/commands/list-change-version-action.ts. The implementations are nearly identical -- buildParsedSource splits the key on \"/\" to extract owner/repo and constructs a ParsedSource, getSourceDir joins remaining key segments onto tempDir.\n\n**Solution**: Extract both into a shared module (e.g., add to src/source-parser.ts or create src/manifest-key-utils.ts). Normalize buildParsedSource to accept (key: string, ref: string | null) to cover both calling conventions.\n\n**Outcome**: One implementation of each helper, imported by three consuming files. ~60 lines of duplication eliminated.\n\n**Do**:\n1. Add buildParsedSourceFromKey(key: string, ref: string | null): ParsedSource to src/source-parser.ts (or create a new module)\n2. Add getSourceDirFromKey(tempDir: string, key: string): string to the same module\n3. Remove local implementations from src/commands/update.ts, src/commands/list-update-action.ts, and src/commands/list-change-version-action.ts\n4. Update imports in all three files\n5. Verify all tests pass\n\n**Acceptance Criteria**:\n- buildParsedSource and getSourceDir each defined in exactly one file\n- All three consumers import from the shared location\n- No behavioral change\n\n**Tests**:\n- Unit test buildParsedSourceFromKey with standalone key (\"owner/repo\") and collection key (\"owner/repo/plugin\")\n- Unit test getSourceDirFromKey with both key formats\n- Existing command tests should pass without modification","parent":"tick-9b3876","created":"2026-02-20T13:15:07Z","updated":"2026-02-20T14:40:50Z","closed":"2026-02-20T14:40:50Z"}
{"id":"tick-ed706d","title":"cs-6-11: Add filesystem-based integration tests for core workflows","status":"done","priority":2,"description":"**Problem**: All command-level tests mock every dependency, verifying orchestration in isolation. There are no tests exercising real interaction between modules (e.g., computeIncomingFiles -\u003e checkFileCollisions -\u003e copyPluginAssets -\u003e writeManifest). Seam defects like path-format mismatches between modules would go undetected.\n\n**Solution**: Add a small set of filesystem-based integration tests that exercise the add/update/remove pipelines end-to-end against temp directories. Mock only interactive prompts (clack) and git operations (network). Use real file operations.\n\n**Outcome**: Cross-module path format consistency is validated. Seam defects between compute, check, copy, and manifest modules are caught.\n\n**Do**:\n1. Create tests/integration/ directory\n2. Create test helper that sets up a temp directory with a fake project structure and a fake plugin source directory\n3. Write integration test: bare skill add -- real computeIncomingFiles, real copyBareSkill, real writeManifest, verify files on disk match manifest\n4. Write integration test: plugin add with collision -- real file operations, verify collision detection works with actual file paths\n5. Write integration test: update with agent drop -- add a plugin, modify the source agntc.json to drop an agent, update, verify correct files removed/kept\n6. Write integration test: remove -- add a plugin, remove it, verify files deleted and manifest cleaned\n7. Mock only: clack prompts (return predetermined selections), git clone (copy from local fixture instead)\n8. Clean up temp directories in afterEach\n\n**Acceptance Criteria**:\n- At least 4 integration tests covering add (bare skill), add (plugin with collision), update, and remove\n- Tests use real filesystem operations against temp directories\n- Tests verify both file-on-disk state and manifest state\n- Tests run in the existing test suite (vitest)\n\n**Tests**:\n- The integration tests themselves are the deliverable","parent":"tick-9b3876","created":"2026-02-20T13:15:20Z","updated":"2026-02-20T14:46:02Z","closed":"2026-02-20T14:46:02Z"}
{"id":"tick-d00910","title":"Phase 7: Analysis (Cycle 2)","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-20T15:31:28Z","updated":"2026-02-20T15:31:28Z"}
{"id":"tick-b51c55","title":"cs-7-1: Extract shared clone-and-reinstall orchestration","status":"done","priority":2,"description":"**Problem**: The clone-then-nuke-and-reinstall-then-handle-result orchestration is duplicated across 5 call sites in update.ts (runGitUpdate, runLocalUpdate, processGitUpdateForAll, processLocalUpdateForAll), list-update-action.ts (runRemoteUpdate, runLocalUpdate), and list-change-version-action.ts (executeChangeVersionAction). Each site repeats ~60-80 lines of the same structure: buildParsedSourceFromKey, spinner start, cloneSource with try/catch, getSourceDirFromKey, executeNukeAndReinstall with onAgentsDropped callback, 4-way if-chain for NukeReinstallResult statuses, write manifest, cleanupTempDir in finally. The onAgentsDropped warning message is also duplicated verbatim 5 times. Any behavioral change to the pipeline (e.g. adding a new result variant) requires updating all sites.\n\n**Solution**: Extract a shared `cloneAndReinstall` function that encapsulates: (1) buildParsedSourceFromKey, (2) cloneSource with spinner, (3) getSourceDirFromKey, (4) executeNukeAndReinstall with a standard onAgentsDropped handler, (5) NukeReinstallResult status mapping to a discriminated success/failure union, (6) cleanupTempDir in finally. Each call site then maps the shared result to its own return type (ExitSignal for single update, PluginOutcome for batch, UpdateActionResult/ChangeVersionResult for list actions). Place in `src/clone-reinstall.ts` or extend `nuke-reinstall-pipeline.ts`.\n\n**Outcome**: The clone-pipeline-outcome orchestration exists in one place. Adding a new NukeReinstallResult variant requires changes in one location. The agents-dropped warning template is defined once. Each consumer is a thin mapper (~5-10 lines) over the shared result.\n\n**Do**:\n1. Create `src/clone-reinstall.ts` with a `cloneAndReinstall` function that accepts: key, entry, projectDir, optional newRef/newCommit, and returns a discriminated union of `{ status: 'success', manifestEntry: ManifestEntry, copiedFiles: string[], droppedAgents: string[] }` or `{ status: 'failed', message: string }`.\n2. Move the onAgentsDropped warning template into this module as a helper (e.g., `formatAgentsDroppedWarning`).\n3. Encapsulate the full sequence: build parsed source, clone (with spinner), get source dir, execute nuke-and-reinstall, map result statuses, cleanup temp dir in finally.\n4. Refactor `runGitUpdate` and `processGitUpdateForAll` in update.ts to call `cloneAndReinstall` and map the result to their existing return types.\n5. Refactor `runLocalUpdate` and `processLocalUpdateForAll` in update.ts similarly (local path variant skips clone, uses path directly).\n6. Refactor `runRemoteUpdate` and `runLocalUpdate` in list-update-action.ts to use `cloneAndReinstall`.\n7. Refactor `executeChangeVersionAction` in list-change-version-action.ts to use `cloneAndReinstall`.\n8. Remove the now-unused duplicated code from all call sites.\n9. Verify all existing tests pass without modification.\n\n**Acceptance Criteria**:\n- The 4-way NukeReinstallResult status handling exists in exactly one location\n- The onAgentsDropped warning message template exists in exactly one location\n- All update/list-update/list-change-version flows produce identical user-visible output as before\n- No call site directly imports or calls cloneSource + executeNukeAndReinstall + cleanupTempDir individually for the update pipeline\n\n**Tests**:\n- Existing update command tests pass (single git update, single local update, batch update all)\n- Existing list-update-action tests pass (remote update, local update)\n- Existing list-change-version-action tests pass\n- Each NukeReinstallResult status (no-config, no-agents, invalid-type, copy-failed, success) produces the same error messages/behavior as before","parent":"tick-d00910","created":"2026-02-20T15:31:56Z","updated":"2026-02-20T15:41:36Z","closed":"2026-02-20T15:41:36Z"}
{"id":"tick-dc4981","title":"cs-7-2: Centralize clone URL derivation and add cloneUrl to GitHubShorthandSource","status":"done","priority":2,"description":"**Problem**: Clone URL derivation is implemented independently in three places: `commands/add.ts:33-40` (handles all ParsedSource variants), `update-check.ts:12-17` (constructs `https://github.com/{owner}/{repo}.git` from a manifest key), and `git-clone.ts:29-37` (resolveCloneUrl). The `GitHubShorthandSource` type lacks a `cloneUrl` field, unlike all other git-based ParsedSource variants, forcing every consumer to special-case it with `https://github.com/${owner}/${repo}.git` construction.\n\n**Solution**: (1) Add `cloneUrl: string` to `GitHubShorthandSource` in source-parser.ts, computed as `https://github.com/${owner}/${repo}.git` during parsing. (2) Centralize clone URL resolution into source-parser.ts with two functions: `resolveCloneUrl(parsed: ParsedSource): string` for ParsedSource-based resolution, and `deriveCloneUrlFromKey(key: string, cloneUrl: string | null): string` for manifest-key-based resolution. (3) Remove the independent implementations in add.ts, update-check.ts, and git-clone.ts.\n\n**Outcome**: Clone URL derivation logic exists in one module. All git-based ParsedSource variants carry a `cloneUrl` field, eliminating special-case branches. If the fallback URL template changes, only one location needs updating.\n\n**Do**:\n1. In `src/source-parser.ts`, add `cloneUrl: string` to the `GitHubShorthandSource` interface.\n2. In the parsing function that creates `GitHubShorthandSource`, compute and set `cloneUrl: \\`https://github.com/${owner}/${repo}.git\\``.\n3. Add a `resolveCloneUrl(parsed: ParsedSource): string` function in source-parser.ts that returns `parsed.cloneUrl` for all git-based variants (now including github-shorthand) and throws for local-path.\n4. Add a `deriveCloneUrlFromKey(key: string, cloneUrl: string | null): string` function in source-parser.ts that returns `cloneUrl` if non-null, otherwise constructs from key as `https://github.com/${key}.git`.\n5. Replace `deriveCloneUrl` in `commands/add.ts` with the centralized function.\n6. Replace `deriveCloneUrl` in `update-check.ts` with `deriveCloneUrlFromKey`.\n7. Replace `resolveCloneUrl` in `git-clone.ts` with the centralized function (or import it).\n8. Remove the now-unused local implementations.\n\n**Acceptance Criteria**:\n- No file outside source-parser.ts contains clone URL construction logic (no `https://github.com/` template strings)\n- All ParsedSource git-based variants have a `cloneUrl` field\n- All existing tests pass\n\n**Tests**:\n- Source parser tests verify GitHubShorthandSource now includes correct cloneUrl\n- Add command tests pass with centralized URL derivation\n- Update check tests pass with centralized URL derivation\n- Git clone tests pass with centralized URL resolution","parent":"tick-d00910","created":"2026-02-20T15:32:14Z","updated":"2026-02-20T15:49:51Z","closed":"2026-02-20T15:49:51Z"}
{"id":"tick-b999e1","title":"cs-7-3: Fix collection add to enforce per-plugin agent compatibility warnings","status":"done","priority":2,"description":"**Problem**: The collection add flow unions all declared agents across all selected plugins and passes that union to a single `selectAgents` call. This means if plugin A declares `[\"claude\"]` and plugin B declares `[\"codex\"]`, both agents appear without any unsupported warning. The resulting selected agents are applied uniformly to ALL plugins -- plugin A gets installed for codex (which it never declared) and plugin B gets installed for claude (which it never declared). The spec states: \"No inheritance -- every installable unit declares its own `agents`, even within collections\" and \"Agents not listed in the plugin's `agents` field are still shown in the multiselect but display a warning.\"\n\n**Solution**: During the copy phase for collections, filter each plugin's agents to only include what the user selected AND emit a warning for any selected agent not in that plugin's declared agents list. This preserves the current single-prompt UX while aligning with spec intent. Specifically: after agent multiselect, for each plugin, compute `effectiveAgents = selectedAgents intersect plugin.agents` and `unsupportedSelected = selectedAgents - plugin.agents`. If unsupportedSelected is non-empty, show a warning per the spec. Install each plugin only for its effective agents plus any unsupported agents the user explicitly selected (with the warning shown).\n\n**Outcome**: Each plugin in a collection is installed respecting its own agent declarations. Users see per-plugin warnings when a selected agent is not declared by that plugin.\n\n**Do**:\n1. In `src/commands/add.ts`, locate the collection add flow (around line 319-365).\n2. After the agent multiselect, iterate over each selected plugin.\n3. For each plugin, compare the selected agents against that plugin's `agents` field from its `agntc.json`.\n4. For agents selected but not declared by the plugin, emit a warning: \"Plugin {plugin-name} does not declare support for {agent}. Installing at your own risk.\"\n5. Install each plugin for ALL selected agents (matching the spec's \"warn, never block\" approach), but with the warning displayed.\n6. Update the agent multiselect to show unsupported warnings based on per-plugin declarations rather than the union.\n\n**Acceptance Criteria**:\n- When adding a collection, each plugin shows unsupported-agent warnings based on its own `agents` field, not the union\n- The user can still select any agent for any plugin (warn, never block)\n- Each plugin's manifest entry `agents` field reflects what was actually installed for that plugin\n\n**Tests**:\n- Collection with plugin A (claude-only) and plugin B (codex-only): selecting both agents shows unsupported warnings for each plugin\n- Collection where all plugins declare the same agents: no warnings shown\n- Single-plugin (non-collection) flow remains unchanged","parent":"tick-d00910","created":"2026-02-20T15:32:34Z","updated":"2026-02-20T15:55:54Z","closed":"2026-02-20T15:55:54Z"}
{"id":"tick-56138f","title":"cs-7-4: Extract shared readDirEntries utility","status":"done","priority":2,"description":"**Problem**: `readSourceAssetDir` in `src/compute-incoming-files.ts:88-95` and `readTopEntries` in `src/copy-plugin-assets.ts:90-97` are near-identical functions. Both read a directory and map entries to `{name: string, isDirectory: boolean}` objects. The interfaces `SourceEntry` and `DirEntry` are structurally identical. Both handle errors by returning an empty array.\n\n**Solution**: Extract a shared `readDirEntries` function into `src/fs-utils.ts` with a single `DirEntry` interface. Both `compute-incoming-files.ts` and `copy-plugin-assets.ts` import from it.\n\n**Outcome**: Directory entry reading logic exists in one place with one interface definition. Both consumers share the same implementation and error handling.\n\n**Do**:\n1. Create `src/fs-utils.ts` (or add to an existing utility module if one exists).\n2. Define `export interface DirEntry { name: string; isDirectory: boolean }`.\n3. Export `readDirEntries(dirPath: string): Promise\u003cDirEntry[]\u003e` that reads the directory with `withFileTypes`, maps to `DirEntry`, and returns `[]` on error.\n4. In `src/compute-incoming-files.ts`, replace `readSourceAssetDir` and `SourceEntry` with imports from fs-utils.ts.\n5. In `src/copy-plugin-assets.ts`, replace `readTopEntries` and `DirEntry` with imports from fs-utils.ts.\n6. Remove the now-unused local implementations and interfaces.\n\n**Acceptance Criteria**:\n- `readSourceAssetDir` and `readTopEntries` no longer exist as separate functions\n- Both modules import and use the shared `readDirEntries` from fs-utils.ts\n- Only one `DirEntry` interface definition exists\n\n**Tests**:\n- Existing tests for compute-incoming-files pass\n- Existing tests for copy-plugin-assets pass\n- readDirEntries returns empty array for non-existent directory\n- readDirEntries correctly maps entries with name and isDirectory","parent":"tick-d00910","created":"2026-02-20T15:32:46Z","updated":"2026-02-20T15:59:56Z","closed":"2026-02-20T15:59:56Z"}
{"id":"tick-e6bbde","title":"cs-7-5: Consolidate findDroppedAgents as complement of computeEffectiveAgents","status":"done","priority":2,"description":"**Problem**: `computeEffectiveAgents` in `src/agent-compat.ts` returns `entryAgents.filter(a =\u003e newSet.has(a))` and `findDroppedAgents` returns `entryAgents.filter(a =\u003e \\!newSet.has(a))`. These are logical inverses computed independently. If the effective-agents logic becomes more nuanced, the dropped-agents logic must be updated in lockstep or they will drift. Both are called together in `nuke-reinstall-pipeline.ts` lines 80-87.\n\n**Solution**: Replace the two independent functions with a single function that returns both results: `computeAgentChanges(entryAgents: string[], newConfigAgents: string[]): { effective: string[], dropped: string[] }`. Derive dropped as `entryAgents.filter(a =\u003e \\!effective.includes(a))` so it is always the complement of effective. Alternatively, keep `computeEffectiveAgents` as the primary and derive dropped at the call site.\n\n**Outcome**: Dropped agents are always the exact complement of effective agents by construction, not by independent implementation. The logic cannot drift.\n\n**Do**:\n1. In `src/agent-compat.ts`, replace both functions with a single `computeAgentChanges(entryAgents: string[], newConfigAgents: string[]): { effective: string[], dropped: string[] }`.\n2. Compute `effective` using the existing logic.\n3. Derive `dropped` as `entryAgents.filter(a =\u003e \\!effective.includes(a))`.\n4. Update `src/nuke-reinstall-pipeline.ts` (lines 80-87) to destructure the single call: `const { effective, dropped } = computeAgentChanges(...)`.\n5. Update any other callers of `computeEffectiveAgents` or `findDroppedAgents`.\n6. Remove the old individual exports.\n\n**Acceptance Criteria**:\n- `findDroppedAgents` no longer exists as a standalone function\n- Dropped agents are derived from effective agents, not computed independently\n- All callers updated to use the new unified function\n\n**Tests**:\n- Existing agent-compat tests pass (adapted to new function signature)\n- nuke-reinstall-pipeline tests pass with identical behavior\n- When effective agents change, dropped agents are always the exact complement","parent":"tick-d00910","created":"2026-02-20T15:33:00Z","updated":"2026-02-20T16:03:37Z","closed":"2026-02-20T16:03:37Z"}
{"id":"tick-72799f","title":"cs-7-6: Align summary output format with spec","status":"done","priority":2,"description":"**Problem**: The spec defines the add summary format as multi-line with per-agent blocks on separate indented lines (e.g., \"Claude:\\n    12 skills, 3 agents, 2 hooks\"). The implementation in `src/summary.ts:63-71` produces a compact single-line format: \"Installed owner/repo@ref -- claude: 2 skill(s)\". Agent names use lowercase where the spec uses capitalized (\"Claude\" vs \"claude\").\n\n**Solution**: Update the summary formatting in `src/summary.ts` to produce multi-line per-agent output with capitalized agent names matching the spec example. Only show asset types that were actually installed (no \"0 hooks\" lines).\n\n**Outcome**: Summary output matches the spec format: multi-line, per-agent blocks with indentation, capitalized agent names, only non-zero asset types shown.\n\n**Do**:\n1. In `src/summary.ts`, locate the summary formatting logic (around line 63-71).\n2. Change the output to use multi-line format per the spec:\n   Installed owner/repo@ref\n\n     Claude:\n       12 skills, 3 agents, 2 hooks\n\n     Codex:\n       12 skills\n3. Capitalize agent names in output (e.g., \"Claude\" not \"claude\", \"Codex\" not \"codex\").\n4. Only include asset types with non-zero counts.\n5. For collections, repeat per plugin.\n\n**Acceptance Criteria**:\n- Summary output uses multi-line per-agent format matching spec example\n- Agent names are capitalized in output\n- Zero-count asset types are omitted\n- Collection installs show per-plugin summaries\n\n**Tests**:\n- Summary for single-agent install shows correct multi-line format\n- Summary for multi-agent install shows separate blocks per agent\n- Summary omits \"0 hooks\" or similar zero-count lines\n- Agent names appear capitalized in output","parent":"tick-d00910","created":"2026-02-20T15:33:13Z","updated":"2026-02-20T16:10:29Z","closed":"2026-02-20T16:10:29Z"}
{"id":"tick-64fe90","title":"Phase 8: Analysis (Cycle 3)","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-20T16:43:03Z","updated":"2026-02-20T16:43:03Z"}
{"id":"tick-e16f38","title":"cs-8-1: Extract failure-reason mapper and unify update orchestration functions","status":"done","priority":2,"description":"**Problem**: Every consumer of cloneAndReinstall() independently dispatches on result.failureReason with an if-chain checking \"clone-failed\", \"no-config\", \"no-agents\", \"invalid-type\", \"copy-failed\", and a fallback. This chain is ~30 lines and appears 6 times across src/commands/update.ts (runGitUpdate:112-141, runLocalUpdate:192-219, processGitUpdateForAll:253-291, processLocalUpdateForAll:340-377), src/commands/list-update-action.ts (runRemoteUpdate:37-68, runLocalUpdate:112-142), and src/commands/list-change-version-action.ts (53-84). Additionally, update.ts has four near-identical functions (runGitUpdate, runLocalUpdate, processGitUpdateForAll, processLocalUpdateForAll) that differ only in how they surface outcomes (throw ExitSignal vs return PluginOutcome) and whether they validate local paths. Adding a new failure reason requires updating all 6 sites. This was flagged in c2 but remains unaddressed at the consumer level.\n\n**Solution**: Define a generic mapCloneFailure\u003cT\u003e function in src/clone-reinstall.ts that accepts a CloneReinstallFailed result and a handler record with one callback per failure reason, returning T. Each call site provides its thin handler record (e.g., messages and return-type wrappers). Additionally, unify the four update functions in update.ts into a single processUpdate function that returns PluginOutcome, with the single-plugin path (runUpdate with a key) calling it and mapping PluginOutcome to throws/logs. The git vs local distinction is already handled inside cloneAndReinstall via the sourceDir parameter.\n\n**Outcome**: The failure-reason dispatch exists in one location. Adding a new failure reason requires changes in one place and produces a compile error if any handler is missing. Each consumer is reduced from ~30 lines of if-chains to ~5-10 lines of handler definitions. The four update functions in update.ts are reduced to one or two.\n\n**Do**:\n1. In src/clone-reinstall.ts, define a handler interface: CloneFailureHandlers\u003cT\u003e = { onCloneFailed: (msg: string) =\u003e T, onNoConfig: (msg: string) =\u003e T, onNoAgents: (msg: string) =\u003e T, onInvalidType: (msg: string) =\u003e T, onCopyFailed: (msg: string) =\u003e T, onUnknown: (msg: string) =\u003e T }.\n2. Export mapCloneFailure\u003cT\u003e(result: CloneReinstallFailed, handlers: CloneFailureHandlers\u003cT\u003e): T that dispatches to the appropriate handler based on result.failureReason.\n3. In src/commands/update.ts, replace the if-chains in runGitUpdate and runLocalUpdate with calls to mapCloneFailure providing handlers that throw ExitSignal or return null as appropriate.\n4. In src/commands/update.ts, replace processGitUpdateForAll and processLocalUpdateForAll with a single processUpdateForAll(key, entry, projectDir) function that calls cloneAndReinstall (with sourceDir for local paths) and uses mapCloneFailure to return PluginOutcome. Keep the local-path validation inline for the batch path.\n5. In src/commands/list-update-action.ts, replace the if-chains in runRemoteUpdate and runLocalUpdate with calls to mapCloneFailure providing handlers that return UpdateActionResult.\n6. In src/commands/list-change-version-action.ts, replace the if-chain with a call to mapCloneFailure providing handlers that return ChangeVersionResult.\n7. Remove all now-unused duplicated if-chain code.\n8. Verify all existing tests pass without modification.\n\n**Acceptance Criteria**:\n- The failure-reason if-chain exists in exactly one location (the mapCloneFailure function)\n- All consumers use mapCloneFailure with typed handler records\n- All update/list-update/list-change-version flows produce identical user-visible output as before\n- update.ts has at most 2 update orchestration functions (single + batch), down from 4\n\n**Tests**:\n- Existing update command tests pass (single git update, single local update, batch update all)\n- Existing list-update-action tests pass (remote update, local update)\n- Existing list-change-version-action tests pass\n- Each failure reason (no-config, no-agents, invalid-type, copy-failed, clone-failed, unknown) produces the same error messages/behavior as before","parent":"tick-64fe90","created":"2026-02-20T16:43:37Z","updated":"2026-02-20T16:54:08Z","closed":"2026-02-20T16:54:08Z"}
{"id":"tick-90df13","title":"cs-8-2: Extract local path validation helper","status":"done","priority":2,"description":"**Problem**: The pattern of calling stat(sourcePath), checking isDirectory(), and producing a \"does not exist or is not a directory\" error is repeated in 3 places: src/commands/update.ts:158-174 (validateLocalPath), src/commands/update.ts:316-331 (inline in processLocalUpdateForAll), and src/commands/list-update-action.ts:90-103 (inline in runLocalUpdate). Each is ~15 lines with identical structure. The update.ts version throws ExitSignal while the other two return error results, but the core validation logic is the same.\n\n**Solution**: Extract a validateLocalSourcePath(path: string): Promise\u003c{ valid: true } | { valid: false; reason: string }\u003e helper into src/fs-utils.ts (or extend an existing utility module). The function performs the stat + isDirectory check and returns a result type. Each call site maps the result to its own error handling (throw or return).\n\n**Outcome**: Local path validation logic exists in one place. The 3 call sites become thin wrappers that map the validation result to their context-specific error handling.\n\n**Do**:\n1. Create or extend src/fs-utils.ts with validateLocalSourcePath(path: string): Promise\u003c{ valid: true } | { valid: false; reason: string }\u003e.\n2. Implement: call stat(path), check isDirectory(). Return { valid: false, reason: \"path is not a directory\" } if not a directory, { valid: false, reason: \"path does not exist\" } if stat throws.\n3. In src/commands/update.ts, replace validateLocalPath (lines 158-174) to call validateLocalSourcePath and throw ExitSignal on invalid.\n4. In src/commands/update.ts, replace inline validation in processLocalUpdateForAll (lines 316-331) to call validateLocalSourcePath and return PluginOutcome on invalid.\n5. In src/commands/list-update-action.ts, replace inline validation in runLocalUpdate (lines 90-103) to call validateLocalSourcePath and return UpdateActionResult on invalid.\n6. Remove now-unused inline validation code.\n\n**Acceptance Criteria**:\n- Local path stat+isDirectory validation exists in exactly one function\n- All 3 call sites use the shared function\n- Error messages remain consistent with current behavior\n\n**Tests**:\n- Existing update tests pass for local path validation failures\n- Existing list-update-action tests pass for local path validation failures\n- validateLocalSourcePath returns valid:true for existing directories\n- validateLocalSourcePath returns valid:false for non-existent paths\n- validateLocalSourcePath returns valid:false for file paths (not directories)","parent":"tick-64fe90","created":"2026-02-20T16:43:52Z","updated":"2026-02-20T16:59:11Z","closed":"2026-02-20T16:59:11Z"}
{"id":"tick-902b4f","title":"cs-8-3: Extract readManifestOrExit helper","status":"done","priority":2,"description":"**Problem**: Three commands read the manifest with an identical .catch() block that extracts the error message, logs it via p.log.error, and throws ExitSignal(1). This 5-line pattern appears in src/commands/update.ts:34-38, src/commands/list.ts:76-80, and src/commands/remove.ts:72-76. The structure is identical each time.\n\n**Solution**: Extract a readManifestOrExit(projectDir: string): Promise\u003cManifest\u003e helper that encapsulates the .catch() + ExitSignal pattern. Place in src/manifest.ts alongside the existing readManifest.\n\n**Outcome**: Manifest-read-with-error-handling exists in one place. Each command calls readManifestOrExit instead of duplicating the catch block.\n\n**Do**:\n1. In src/manifest.ts, add readManifestOrExit(projectDir: string): Promise\u003cManifest\u003e that calls readManifest(projectDir) and catches errors with the standard pattern: extract message, p.log.error(\"Failed to read manifest: {message}\"), throw ExitSignal(1).\n2. In src/commands/update.ts, replace lines 34-38 with const manifest = await readManifestOrExit(projectDir).\n3. In src/commands/list.ts, replace the equivalent catch block with readManifestOrExit.\n4. In src/commands/remove.ts, replace the equivalent catch block with readManifestOrExit.\n5. Update imports in all three files.\n\n**Acceptance Criteria**:\n- No command file contains a .catch() block that logs manifest read errors and throws ExitSignal\n- All three commands use readManifestOrExit\n- Error messages remain identical to current behavior\n\n**Tests**:\n- Existing tests for update, list, and remove pass with manifest read errors\n- readManifestOrExit throws ExitSignal(1) when manifest cannot be read","parent":"tick-64fe90","created":"2026-02-20T16:44:01Z","updated":"2026-02-20T17:13:10Z","closed":"2026-02-20T17:13:10Z"}
{"id":"tick-99a33c","title":"cs-8-4: Extract errorMessage utility function","status":"done","priority":2,"description":"**Problem**: The expression err instanceof Error ? err.message : String(err) appears 13 times across the codebase: src/clone-reinstall.ts:88, src/config.ts:43, src/commands/update.ts:35,391,404, src/commands/list.ts:77, src/commands/list-update-action.ts:154, src/commands/add.ts:251,513, src/commands/remove.ts:73, src/nuke-reinstall-pipeline.ts:128, src/copy-rollback.ts:15, src/update-check-all.ts:20. Each is a single expression but the sheer repetition indicates a missing utility.\n\n**Solution**: Extract function errorMessage(err: unknown): string into src/errors.ts (alongside the existing isNodeError if present, or as a new file). Replace all 13 occurrences.\n\n**Outcome**: Error message extraction is a single utility function. All catch blocks use it consistently.\n\n**Do**:\n1. Create or extend src/errors.ts with export function errorMessage(err: unknown): string { return err instanceof Error ? err.message : String(err); }.\n2. Replace all 13 occurrences of err instanceof Error ? err.message : String(err) with errorMessage(err).\n3. Add the import to each affected file.\n\n**Acceptance Criteria**:\n- No file contains the inline err instanceof Error ? err.message : String(err) expression\n- All 13 sites use the shared errorMessage function\n- No behavioral change\n\n**Tests**:\n- All existing tests pass\n- errorMessage returns the message property for Error instances\n- errorMessage returns String(err) for non-Error values","parent":"tick-64fe90","created":"2026-02-20T16:44:09Z","updated":"2026-02-20T17:18:14Z","closed":"2026-02-20T17:18:14Z"}
{"id":"tick-a36a34","title":"cs-8-5: Narrow tree URL @ref rejection to path portion only","status":"done","priority":2,"description":"**Problem**: parseDirectPath in src/source-parser.ts:134-137 rejects any tree URL containing @ anywhere in the string (if (input.includes(\"@\"))). This would incorrectly reject legitimate URLs containing @ in non-ref positions, such as https://user@github.com/owner/repo/tree/main/plugin (authenticated URLs). The spec intent is to reject @ref suffixes appended after the URL, not @ characters within the URL structure.\n\n**Solution**: Narrow the check to only reject @ after the hostname/path portion. Since tree URLs have the structure https://{host}/{owner}/{repo}/tree/{ref}/{plugin}, check whether @ appears after the /tree/ segment or as a suffix to the overall URL, rather than anywhere in the string.\n\n**Outcome**: Tree URLs with @ in the authentication portion or hostname are accepted. Only @ref suffixes meant for version pinning are rejected, matching spec intent.\n\n**Do**:\n1. In src/source-parser.ts, locate parseDirectPath (line 133).\n2. Replace if (input.includes(\"@\")) with a check that only examines the portion after the hostname. For example: extract the path after https://{host}/ and check if that path portion contains @.\n3. Alternatively, check if @ appears after the last /tree/... segment, which would be the suffix position.\n4. Ensure the existing test for @ref rejection on tree URLs still passes.\n\n**Acceptance Criteria**:\n- https://github.com/owner/repo/tree/main/plugin is accepted (no @)\n- https://github.com/owner/repo/tree/main/plugin@v2 is rejected (@ as ref suffix in path)\n- https://user@github.com/owner/repo/tree/main/plugin would not be rejected by the @ check (@ is in auth portion)\n- Existing source-parser tests pass\n\n**Tests**:\n- Existing tree URL parsing tests pass\n- Tree URL with @ref suffix after path is still rejected\n- Standard tree URLs without @ continue to parse correctly","parent":"tick-64fe90","created":"2026-02-20T16:44:21Z","updated":"2026-02-20T17:40:04Z","closed":"2026-02-20T17:40:04Z"}
{"id":"tick-f05a59","title":"Phase 9: Analysis (Cycle 4)","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-20T18:40:10Z","updated":"2026-02-20T18:40:10Z"}
{"id":"tick-6c1630","title":"Unify runRemoteUpdate and runLocalUpdate in list-update-action.ts and internalize copy-failed manifest removal","status":"open","priority":2,"description":"**Problem**: `runRemoteUpdate` (lines 26-79) and `runLocalUpdate` (lines 81-149) in `src/commands/list-update-action.ts` are structurally identical. Both call `cloneAndReinstall`, check for copy-failed and remove the manifest entry, then call `mapCloneFailure` with near-identical handler records (~25 lines duplicated within the same file). The only differences are: (1) `runLocalUpdate` adds a `validateLocalSourcePath` guard and passes `sourceDir`, and (2) two of six message strings differ slightly (\"has no agntc.json\" vs \"New version of ... has no agntc.json\"). Additionally, the copy-failed manifest removal check (`result.failureReason === \"copy-failed\"` then `writeManifest(projectDir, removeEntry(manifest, key))`) is a 3-line block repeated at 4 call sites across 3 files -- this is a pipeline concern that leaks into every consumer of `cloneAndReinstall`.\n\n**Solution**: (1) Unify `runRemoteUpdate` and `runLocalUpdate` into a single `runUpdate(key, entry, manifest, projectDir)` function that determines local vs remote mode from `entry.commit === null`. Parameterize the two differing message strings via a local flag. (2) Move the copy-failed manifest removal into `cloneAndReinstall` itself (it already has access to key and projectDir), or into the `mapCloneFailure` `onCopyFailed` handler defined once in the shared function, eliminating the check from all 4 external call sites.\n\n**Outcome**: list-update-action.ts has one update function instead of two. The copy-failed manifest cleanup is handled in one location rather than repeated at every call site. ~50 lines eliminated from list-update-action.ts and ~9 lines from other files.\n\n**Do**:\n1. In `src/commands/list-update-action.ts`, create a single `runUpdate(key: string, entry: ManifestEntry, manifest: Manifest, projectDir: string): Promise\u003cUpdateActionResult\u003e` function.\n2. Inside `runUpdate`, check `entry.commit === null` to determine local vs remote mode. For local mode, call `validateLocalSourcePath` first and return early on failure. For remote mode, proceed directly.\n3. Call `cloneAndReinstall` with the appropriate parameters (sourceDir for local, ref/commit for remote).\n4. Extract a single `mapCloneFailure` handler record that parameterizes the two message-string differences based on a `isLocal` flag.\n5. In `src/clone-reinstall.ts` (or wherever `cloneAndReinstall` is defined), move the copy-failed manifest removal logic into the function itself, so consumers do not need to check for copy-failed and call `writeManifest(removeEntry(...))` independently.\n6. Remove the copy-failed manifest removal checks from `src/commands/update.ts`, `src/commands/list-update-action.ts`, and `src/commands/list-change-version-action.ts` (all 4 external sites).\n7. Remove the now-unused `runRemoteUpdate` and `runLocalUpdate` functions.\n8. Update all call sites that invoked `runRemoteUpdate` or `runLocalUpdate` to call the unified `runUpdate`.\n9. Verify all existing tests pass.\n\n**Acceptance Criteria**:\n- `runRemoteUpdate` and `runLocalUpdate` no longer exist as separate functions in list-update-action.ts\n- A single `runUpdate` function handles both local and remote update flows\n- The copy-failed manifest removal check does not appear at any external call site of `cloneAndReinstall`\n- All existing list-update-action tests pass with identical behavior\n- All existing update and list-change-version-action tests pass\n\n**Tests**:\n- Existing list-update-action tests for remote updates pass\n- Existing list-update-action tests for local updates pass\n- Existing update command tests pass (copy-failed handling still works)\n- Existing list-change-version-action tests pass\n- Copy-failed scenario correctly removes the manifest entry (verified via existing or updated tests)","parent":"tick-f05a59","created":"2026-02-20T18:40:37Z","updated":"2026-02-20T18:40:37Z"}
{"id":"tick-75db2e","title":"Extract shared conflict-check pipeline in add.ts","status":"open","priority":2,"description":"**Problem**: The standalone add path (lines ~151-187) and the collection per-plugin loop (lines ~428-470) in `src/commands/add.ts` both implement the same 6-step sequence: computeIncomingFiles, checkFileCollisions, resolveCollisions (with manifest update), checkUnmanagedConflicts, resolveUnmanagedConflicts (with skip handling). Each is ~35 lines. The collection version wraps the cancel path in a `continue` instead of a `throw`, but the core pipeline is identical.\n\n**Solution**: Extract a shared function like `runConflictChecks({ incomingFiles, manifest, pluginKey, projectDir }): Promise\u003c{ updatedManifest: Manifest, proceed: boolean }\u003e` that encapsulates the full collision and unmanaged-conflict pipeline. The standalone path throws on `\\!proceed`, the collection path continues.\n\n**Outcome**: The 6-step conflict pipeline exists in one place. Any change to the collision/unmanaged resolution flow is made once. ~35 lines of duplication eliminated.\n\n**Do**:\n1. In `src/commands/add.ts`, define a function `runConflictChecks(opts: { incomingFiles: string[], manifest: Manifest, pluginKey: string, projectDir: string }): Promise\u003c{ updatedManifest: Manifest, proceed: boolean }\u003e`.\n2. Move the 6-step sequence into this function: computeIncomingFiles, checkFileCollisions, resolveCollisions, checkUnmanagedConflicts, resolveUnmanagedConflicts, return updated manifest and whether to proceed.\n3. In the standalone add path, call `runConflictChecks` and throw on `\\!proceed`.\n4. In the collection per-plugin loop, call `runConflictChecks` and `continue` on `\\!proceed`.\n5. Ensure both paths pass the correct parameters and handle the result appropriately.\n6. Verify all existing tests pass.\n\n**Acceptance Criteria**:\n- The collision-check + unmanaged-check sequence exists in exactly one function\n- Both the standalone and collection add paths use the shared function\n- Cancel behavior is preserved: standalone throws, collection continues to next plugin\n- All existing add command tests pass\n\n**Tests**:\n- Existing add tests for collision detection and resolution pass\n- Existing add tests for unmanaged conflict detection pass\n- Existing collection add tests pass\n- Cancel during standalone add still aborts the command\n- Cancel during collection add still skips to the next plugin","parent":"tick-f05a59","created":"2026-02-20T18:40:49Z","updated":"2026-02-20T18:40:49Z"}
{"id":"tick-cfe67a","title":"Extract withExitSignal wrapper for command actions","status":"open","priority":2,"description":"**Problem**: All four commands (add, remove, update, list) wrap their `.action()` handler in an identical try/catch block that checks for ExitSignal and calls `process.exit(signal.code)`. The block is 7 lines, repeated 4 times with zero variation across `src/commands/add.ts:558-567`, `src/commands/remove.ts:161-170`, `src/commands/update.ts:461-470`, and `src/commands/list.ts:151-160`.\n\n**Solution**: Extract a `withExitSignal(fn: (...args: any[]) =\u003e Promise\u003cvoid\u003e): (...args: any[]) =\u003e Promise\u003cvoid\u003e` wrapper that returns an async function handling the ExitSignal catch pattern. Place in `src/exit-signal.ts` alongside the ExitSignal class definition.\n\n**Outcome**: Each command's `.action()` call becomes a one-liner: `.action(withExitSignal(async (source) =\u003e runAdd(source)))`. The ExitSignal catch boilerplate exists in one place.\n\n**Do**:\n1. In `src/exit-signal.ts` (or wherever ExitSignal is defined), add `export function withExitSignal\u003cT extends (...args: any[]) =\u003e Promise\u003cvoid\u003e\u003e(fn: T): T`.\n2. Implement: return an async function that wraps `fn` in try/catch, checking `if (err instanceof ExitSignal) process.exit(err.code)` and re-throwing otherwise.\n3. In `src/commands/add.ts`, replace the try/catch action wrapper with `withExitSignal(async (source) =\u003e { ... })`.\n4. In `src/commands/remove.ts`, replace the try/catch action wrapper with `withExitSignal(async (key) =\u003e { ... })`.\n5. In `src/commands/update.ts`, replace the try/catch action wrapper with `withExitSignal(async (key) =\u003e { ... })`.\n6. In `src/commands/list.ts`, replace the try/catch action wrapper with `withExitSignal(async () =\u003e { ... })`.\n7. Remove the now-unused try/catch blocks from all four files.\n8. Verify all existing tests pass.\n\n**Acceptance Criteria**:\n- No command file contains an inline try/catch block checking for ExitSignal\n- All four commands use `withExitSignal` to wrap their action handlers\n- ExitSignal handling behavior is identical to current (calls process.exit with the signal's code)\n- All existing tests pass\n\n**Tests**:\n- Existing tests for all four commands pass\n- withExitSignal calls process.exit when ExitSignal is thrown\n- withExitSignal re-throws non-ExitSignal errors","parent":"tick-f05a59","created":"2026-02-20T18:41:02Z","updated":"2026-02-20T18:41:02Z"}
