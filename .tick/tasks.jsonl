{"id":"tick-20aa13","title":"Core System","status":"open","priority":2,"created":"2026-02-18T20:38:55Z","updated":"2026-02-18T20:38:55Z"}
{"id":"tick-dea5ee","title":"Phase 1: Walking Skeleton - Add a Bare Skill from Git","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-18T20:39:00Z","updated":"2026-02-18T20:39:00Z"}
{"id":"tick-0ba43c","title":"cs-1-1: Project Scaffolding and CLI Entry Point","status":"done","priority":2,"description":"**Problem**: The agntc repo has no TypeScript setup, no build tooling, no test framework, and no CLI entry point. Every subsequent task depends on this.\n\n**Solution**: Scaffold a TypeScript project with tsup for bundling, Vitest for testing, and Commander for CLI argument parsing. Create the bin entry point with add and list as subcommand stubs.\n\n**Outcome**: A buildable, testable TypeScript project where npx agntc add owner/repo and npx agntc list print placeholders, help works, unknown commands error, and Vitest runs.\n\n**Do**:\n1. Scaffold TypeScript project: tsconfig.json (ES2022/NodeNext, strict), package.json (type: module, bin: dist/cli.js, build/test scripts), tsup.config.ts (esm, node20, dts, shebang), vitest.config.ts, .gitignore (dist/, node_modules/)\n2. Install dependencies: typescript, tsup, vitest (dev); commander, @clack/prompts (runtime)\n3. Create src/cli.ts with Commander program: add (required `\u003csource\u003e` arg) and list subcommands\n4. Create src/commands/add.ts and src/commands/list.ts as stubs with @clack/prompts intro/outro\n5. Create tests/cli.test.ts with smoke tests for CLI wiring, build and verify\n\n**Acceptance Criteria**:\n- npm run build produces dist/cli.js with shebang, executable\n- npx agntc --help shows help listing add and list\n- npx agntc add owner/repo exits 0 with placeholder output\n- npx agntc add (no source) exits non-zero\n- npx agntc list exits 0 with placeholder output\n- npx agntc (no command) shows help\n- npx agntc unknown-command exits non-zero\n- npm test runs vitest, all tests pass\n- package.json bin field points to dist/cli.js\n- TypeScript strict mode enabled\n\n**Tests**:\n- npx agntc --help includes add and list in output\n- npx agntc add \u003csource\u003e exits 0 and outputs placeholder message\n- npx agntc add with no source argument exits non-zero\n- npx agntc list exits 0 and outputs placeholder message\n- npx agntc with no arguments shows help\n- npx agntc with unknown command exits non-zero\n- build produces dist/cli.js with node shebang\n\n**Context**: Naming spec mandates agntc as CLI command and package name. Spec requires Commander + @clack/prompts. Phase 1 only stubs add and list — remove and update come later.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:39:09Z","updated":"2026-02-19T17:58:18Z","closed":"2026-02-19T17:58:18Z"}
{"id":"tick-be4c96","title":"cs-1-2: Source Argument Parsing (GitHub Shorthand)","status":"done","priority":2,"description":"**Problem**: The add command receives a raw string but needs structured data (owner, repo, ref) for downstream operations (clone, manifest key).\n\n**Solution**: Create a parseSource function returning a typed ParsedSource object with a type: \"github-shorthand\" discriminant for future union extension in Phase 3.\n\n**Outcome**: Tested parser that extracts owner, repo, and optional ref from owner/repo and owner/repo@ref, rejects malformed input with descriptive errors.\n\n**Do**:\n1. Create src/source-parser.ts with ParsedSource type (type, owner, repo, ref, manifestKey)\n2. Implement parseSource(raw) — trim, split on first @, split on /, validate segments\n3. Throw descriptive errors for: missing owner/repo, empty owner, empty repo, empty ref, extra slashes, empty string\n4. Create tests/source-parser.test.ts with all edge case tests\n5. Wire into src/commands/add.ts — call parseSource on source arg\n\n**Acceptance Criteria**:\n- parseSource(\"owner/repo\") returns { type: \"github-shorthand\", owner: \"owner\", repo: \"repo\", ref: null, manifestKey: \"owner/repo\" }\n- parseSource(\"owner/repo@v2.0\") returns ref: \"v2.0\"\n- parseSource(\"owner/repo@main\") returns ref: \"main\"\n- parseSource(\"repo\") throws with descriptive error (missing owner)\n- parseSource(\"/repo\") throws with descriptive error (empty owner)\n- parseSource(\"owner/\") throws with descriptive error (empty repo)\n- parseSource(\"owner/repo@\") throws with descriptive error (empty ref)\n- parseSource(\"a/b/c\") throws with descriptive error (extra slashes)\n- parseSource(\"\") throws with descriptive error\n- The add command calls parseSource on its source argument\n\n**Tests**:\n- parses owner/repo into structured source with null ref\n- parses owner/repo@ref with tag ref\n- parses owner/repo@ref with branch name ref\n- returns manifestKey as owner/repo\n- trims whitespace from input\n- throws for missing owner segment (bare repo name)\n- throws for empty owner (leading slash)\n- throws for empty repo (trailing slash)\n- throws for empty ref after @ symbol\n- throws for extra slashes in path (three segments)\n- throws for empty string input\n- handles ref containing special characters (e.g., v2.0.0-beta.1)\n- splits on first @ only — ref can contain @ characters\n\n**Context**: Phase 1 implements GitHub shorthand only. The ParsedSource type uses a discriminant so Phase 3 can extend it as a union type. Manifest key is owner/repo; collection suffixes appended downstream. ref: null means HEAD.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:46:55Z","updated":"2026-02-19T18:05:31Z","closed":"2026-02-19T18:05:31Z"}
{"id":"tick-3dff00","title":"cs-1-3: Git Shallow Clone","status":"done","priority":2,"description":"**Problem**: After parsing the source argument, the tool needs to fetch repo contents to a local temp directory before reading agntc.json or copying assets. No clone infrastructure exists yet.\n\n**Solution**: Create a cloneSource function that takes a ParsedSource, creates a temp directory, performs a shallow git clone (depth 1), and returns the temp dir path + resolved commit SHA. Retries transient failures, aborts immediately on auth errors, cleans up temp dir on failure.\n\n**Outcome**: Tested clone module that shallow-clones GitHub repos to temp dirs, retries transient failures up to 3 times, aborts on auth errors, cleans up on failure, returns temp path + commit SHA on success.\n\n**Do**:\n1. Create src/git-clone.ts with CloneResult type ({ tempDir, commit }) and cloneSource(parsed: ParsedSource) async function\n2. Build clone URL as https://github.com/{owner}/{repo}.git from ParsedSource fields\n3. Create temp dir using fs.mkdtemp(os.tmpdir() + '/agntc-')\n4. Shell out to git clone --depth 1 [--branch ref] \u003curl\u003e \u003ctempDir\u003e via child_process.execFile. ref null = omit --branch (HEAD). ref provided = --branch \u003cref\u003e.\n5. On success, resolve commit SHA via git -C \u003ctempDir\u003e rev-parse HEAD\n6. Return { tempDir, commit }\n7. Retry logic: max 3 attempts. Auth errors (exit 128 + stderr contains Authentication, Permission denied, could not read Username/Password) throw immediately. Otherwise retry with delay (500ms, 1000ms).\n8. On final failure, clean up temp dir (fs.rm recursive+force) before throwing\n9. Create tests/git-clone.test.ts — mock execFile for retry/auth/URL/ref/cleanup tests. Optional integration test behind RUN_INTEGRATION=1.\n10. Export cleanupTempDir(path) helper for callers. Thin wrapper around fs.rm recursive+force.\n\n**Acceptance Criteria**:\n- cloneSource constructs URL as https://github.com/{owner}/{repo}.git\n- ref: null clones HEAD (no --branch flag)\n- ref: \"v2.0\" passes --branch v2.0\n- Clone uses --depth 1 (shallow)\n- Returns { tempDir, commit } where commit is 40-char hex SHA\n- Temp dir under os.tmpdir() with agntc- prefix\n- Transient failures retried up to 3 times\n- Auth failures throw immediately, no retry\n- Temp dir cleaned up on failure (retries exhausted or auth error)\n- Temp dir NOT cleaned up on success (caller responsibility)\n- cleanupTempDir removes directory recursively\n- Error messages surface underlying git error clearly\n\n**Tests**:\n- constructs correct clone URL from owner and repo\n- calls git clone with --depth 1\n- omits --branch when ref is null\n- passes --branch \u003cref\u003e when ref is provided\n- returns tempDir and 40-char commit SHA on success\n- creates temp dir with agntc- prefix\n- retries up to 3 times on transient failure then throws\n- succeeds on second attempt after transient failure\n- does not retry on auth failure (throws immediately)\n- detects auth failure from stderr patterns\n- cleans up temp dir after failure\n- does not clean up temp dir on success\n- surfaces git error message in thrown error\n- cleanupTempDir removes directory recursively\n- cleanupTempDir does not throw if dir missing\n- clone failure for nonexistent repo produces clear error\n\n**Context**: Spec says retry 3 times on transient, no retry on auth. Phase 1 = GitHub shorthand only, so URL is always https://github.com/{owner}/{repo}.git. Phase 3 extends for other hosts/formats. Caller owns cleanup on success; cloneSource owns cleanup on failure. Git is a runtime prerequisite — the tool should surface a clear error if git is not found on the system.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:48:56Z","updated":"2026-02-19T18:52:27Z","closed":"2026-02-19T18:52:27Z"}
{"id":"tick-5024dd","title":"cs-1-4: agntc.json Validation","status":"done","priority":2,"description":"**Problem**: After cloning a repo, the tool needs to read and validate agntc.json from the repo root. No config reading or validation logic exists yet. Each validation failure mode requires a specific error message per spec. Unknown agent identifiers must warn (not error) to future-proof.\n\n**Solution**: Create a readConfig function that reads agntc.json from a given directory, parses JSON, validates schema (agents field required, non-empty array, valid identifiers), returns typed AgntcConfig. Unknown agents trigger warning callback and are filtered out. Missing file returns null (valid signal for collection detection).\n\n**Outcome**: Tested config module that reads/validates agntc.json, returns null when absent, throws descriptive errors for invalid JSON / missing agents / empty agents, warns on unknown identifiers, returns typed config on success.\n\n**Do**:\n1. Create src/config.ts with types: AgntcConfig ({ agents: string[] }), KNOWN_AGENTS ([\"claude\", \"codex\"]), ReadConfigOptions ({ onWarn? })\n2. Implement readConfig(dir, options?) — read agntc.json, parse JSON, validate agents field, filter unknown agents with warnings, return typed config or null\n3. Error messages per spec: \"Invalid agntc.json: {parse error}\", \"agents field is required\", \"agents must not be empty\"\n4. Unknown agents: warn via onWarn callback, filter out. Return only known agents.\n5. Create ConfigError class (extends Error)\n6. Create tests/config.test.ts covering all validation paths\n7. Export AgntcConfig, KNOWN_AGENTS, readConfig, ConfigError\n\n**Acceptance Criteria**:\n- Returns null when agntc.json does not exist\n- Returns { agents: [\"claude\"] } for valid config\n- Returns { agents: [\"claude\", \"codex\"] } for multi-agent config\n- Throws ConfigError with parse error for malformed JSON\n- Throws ConfigError for missing agents field\n- Throws ConfigError for empty agents array\n- Unknown agents filtered out + onWarn called\n- Returns only known agents when mix of known/unknown\n- Returns empty known agents array when all agents unknown (downstream handles no-valid-agents scenario)\n- KNOWN_AGENTS contains [\"claude\", \"codex\"]\n- Non-ENOENT file errors propagate as-is\n\n**Tests**:\n- returns null when agntc.json does not exist\n- parses valid config with single agent\n- parses valid config with multiple agents\n- throws ConfigError for invalid JSON (truncated)\n- throws ConfigError for invalid JSON (trailing comma)\n- throws ConfigError with parse error detail\n- throws when agents field missing entirely\n- throws when agents is empty array\n- warns for unknown agent and filters it out\n- returns known agents when mix present\n- warns once per unknown agent\n- returns empty known agents when all unknown (warns for each)\n- does not call onWarn when all agents known\n- propagates permission denied errors\n- reads from correct path\n\n**Context**: Spec defines agntc.json as single required config. Missing file = null (type detection uses absence for collection scanning). Naming spec confirms filename is agntc.json.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:50:30Z","updated":"2026-02-19T21:40:10Z","closed":"2026-02-19T21:40:10Z"}
{"id":"tick-3f9f32","title":"cs-1-5: Type Detection","status":"done","priority":2,"description":"**Problem**: After reading agntc.json (or discovering its absence), the tool must determine what kind of installable it is looking at — bare skill, plugin, collection, or not an agntc repo. Downstream operations depend on this classification.\n\n**Solution**: Create a detectType function applying the spec's 3-rule cascade: (1) root has agntc.json — check asset dirs vs SKILL.md, (2) no agntc.json — scan subdirs (collection), (3) nothing — not agntc. Returns a typed discriminated union (DetectedType). All paths implemented and tested.\n\n**Outcome**: Tested type detection module classifying directories as bare-skill, plugin, collection, or not-agntc. Warns on misconfigurations.\n\n**Do**:\n1. Create src/type-detection.ts with types: ASSET_DIRS ([\"skills\", \"agents\", \"hooks\"]), DetectedType union (bare-skill, plugin with assetDirs, collection with plugins, not-agntc)\n2. Implement detectType(dir, options?) — hasConfig boolean from caller, onWarn callback\n3. Rule 1 (hasConfig=true): check asset dirs → plugin; check SKILL.md → bare-skill; neither → warn + not-agntc. Warn if SKILL.md coexists with asset dirs.\n4. Rule 2 (hasConfig=false): scan immediate subdirs for agntc.json → collection; none → not-agntc\n5. Use fs.access for existence checks\n6. Create tests/type-detection.test.ts with real temp dir fixtures\n7. Export DetectedType, ASSET_DIRS, detectType\n\n**Acceptance Criteria**:\n- Returns bare-skill when hasConfig=true, SKILL.md exists, no asset dirs\n- Returns plugin with assetDirs when asset dirs found\n- Returns collection with plugin names when subdirs have agntc.json\n- Returns not-agntc when nothing recognisable\n- Returns not-agntc with warning when hasConfig=true but no SKILL.md/asset dirs\n- Warns when SKILL.md coexists with asset dirs\n- Collection scan checks immediate subdirs only (not recursive)\n- ASSET_DIRS = [\"skills\", \"agents\", \"hooks\"]\n\n**Tests**:\n- bare-skill with SKILL.md and no asset dirs\n- bare-skill with non-asset dirs alongside SKILL.md\n- plugin with each individual asset dir\n- plugin with all three asset dirs\n- plugin warns when SKILL.md coexists with asset dirs\n- not-agntc with warning when config but nothing to install\n- collection with multiple subdirs having agntc.json\n- collection skips subdirs without agntc.json\n- not-agntc when no config and no subdirs have config\n- not-agntc for empty directory\n- collection scan ignores files\n- collection scan not recursive\n\n**Context**: Spec defines type detection as structure-based with 3 ordered rules. hasConfig avoids re-reading agntc.json. Collections are structural, not declared.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:52:07Z","updated":"2026-02-19T21:44:20Z","closed":"2026-02-19T21:44:20Z"}
{"id":"tick-cc248f","title":"cs-1-6: Agent Driver Interface and Claude Driver","status":"done","priority":2,"description":"**Problem**: The tool needs to ask \"is this agent present?\" and \"where do assets go for this agent?\" but no driver abstraction exists. Spec mandates driver/strategy pattern so adding agents requires only a new driver + registration.\n\n**Solution**: Define AgentDriver TypeScript interface (detect + getTargetDir). Implement Claude driver. Create registry mapping agent IDs to drivers. Detection: project-level first (.claude/), system fallback (which claude, ~/.claude/). Routing: static config map.\n\n**Outcome**: Tested AgentDriver interface, Claude driver with detection/routing, registry. getDriver(\"claude\") → driver, detect(projectDir) → boolean, getTargetDir(assetType) → string | null.\n\n**Do**:\n1. Create src/drivers/types.ts — AgentDriver interface (detect, getTargetDir), AgentId type (\"claude\" | \"codex\")\n2. Create src/drivers/claude-driver.ts — detect: check .claude/ in project → which claude → ~/.claude/. getTargetDir: { skills: \".claude/skills\", agents: \".claude/agents\", hooks: \".claude/hooks\" }, null for unknown.\n3. Create src/drivers/registry.ts — DRIVER_REGISTRY mapping \"claude\" → ClaudeDriver. getDriver(id), getRegisteredAgentIds().\n4. Create tests/drivers/claude-driver.test.ts — mock fs.access and child_process for detection, direct routing tests.\n5. Create tests/drivers/registry.test.ts — registry lookup and registered IDs.\n\n**Acceptance Criteria**:\n- AgentDriver interface with detect(projectDir) and getTargetDir(assetType)\n- AgentId type as \"claude\" | \"codex\"\n- ClaudeDriver.detect: true when .claude/ in project, skips system check on project match\n- ClaudeDriver.detect: fallback to which claude, then ~/.claude/, false when all fail\n- ClaudeDriver.getTargetDir: skills → .claude/skills, agents → .claude/agents, hooks → .claude/hooks, unknown → null\n- getDriver(\"claude\") returns Claude driver\n- getRegisteredAgentIds() returns [\"claude\"]\n- No Codex driver yet (Phase 3)\n\n**Tests**:\n- detect true when .claude/ exists in project\n- detect skips system fallback on project match\n- detect true when which claude succeeds\n- detect true when ~/.claude/ exists\n- detect false when all checks fail\n- detect does not throw on check failures\n- getTargetDir returns correct paths for skills, agents, hooks\n- getTargetDir returns null for unknown asset type\n- registry returns claude driver\n- registry lists registered IDs\n- registry does not contain codex yet\n\n**Context**: Spec: driver/strategy pattern, project-level first + system fallback, cheapest check first. Claude targets per spec table. Codex added Phase 3. KNOWN_AGENTS in config.ts and AgentId in drivers must stay in sync.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:53:49Z","updated":"2026-02-19T21:48:51Z","closed":"2026-02-19T21:48:51Z"}
{"id":"tick-e86117","title":"cs-1-7: Agent Multiselect UI","status":"done","priority":2,"description":"**Problem**: After detecting agents (cs-1-6) and reading plugin's declared agents (cs-1-4), need to let user choose which agents to install for. Spec mandates always-shown @clack/prompts multiselect with smart pre-selection and unsupported warnings.\n\n**Solution**: Create selectAgents function taking declared and detected agents, presenting @clack/prompts multiselect of all registered agents. Pre-selection = declared ∩ detected. Unsupported agents get warning hint. Zero selection = cancel.\n\n**Outcome**: Tested agent selection module showing all registered agents, pre-selecting compatible+detected, warning on unsupported, returning AgentId[] or empty on cancel.\n\n**Do**:\n1. Create src/agent-select.ts with selectAgents({ declaredAgents, detectedAgents }) → Promise\u003cAgentId[]\u003e\n2. Get all agents from getRegisteredAgentIds()\n3. Build multiselect options: value (AgentId), label, hint (warning if not declared), initialValue (true if declared AND detected)\n4. Call @clack/prompts multiselect with required: false\n5. Handle clack cancel → return []\n6. Handle zero selection → brief cancel message, return []\n7. Return selected AgentId[]\n8. Create tests/agent-select.test.ts mocking @clack/prompts multiselect\n\n**Acceptance Criteria**:\n- Always shows all registered agents regardless of compatibility\n- Pre-selection = intersection of declared and detected\n- Warning hint on agents not in declared list\n- Clack cancel returns empty array\n- Zero selection returns empty array\n- Valid selection returns AgentId[]\n\n**Tests**:\n- pre-selects declared AND detected agents\n- does not pre-select declared-only agents\n- does not pre-select detected-only agents\n- shows all registered agents\n- warning hint on undeclared agents\n- no hint on declared agents\n- returns empty on cancel\n- returns empty on zero selection\n- returns selected AgentId[] on valid selection\n- correct options shape passed to multiselect\n- handles empty declaredAgents\n- handles empty detectedAgents\n- handles all agents declared and detected\n\n**Context**: Spec: multiselect always shown, never skipped. Pre-selection = plugin declares + agent detected. Unsupported agents still shown with warning. User can always select any agent. Zero = cancel, no error. Options from registry (Phase 1: Claude only; Phase 3 adds Codex).\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:55:16Z","updated":"2026-02-19T21:53:07Z","closed":"2026-02-19T21:53:07Z"}
{"id":"tick-601f31","title":"cs-1-8: Bare Skill File Copy","status":"done","priority":2,"description":"**Problem**: After agent selection, the tool has a cloned bare-skill repo, selected agents, and driver routing, but no copy logic. Need to copy skill files to target dirs for each agent.\n\n**Solution**: Create copyBareSkill that for each agent resolves target via getTargetDir(\"skills\"), copies source dir to {targetDir}/{skillName}/ excluding agntc.json, returns copied file paths for manifest.\n\n**Outcome**: Tested copy module that copies bare skill files to each agent's target, excludes agntc.json, creates dirs, returns paths for manifest tracking.\n\n**Do**:\n1. Create src/copy-bare-skill.ts with CopyBareSkillInput and CopyBareSkillResult types\n2. For each agent: getTargetDir(\"skills\") → null = skip. Compute destDir = projectDir/targetDir/skillName. mkdir recursive. Copy all files excluding agntc.json. Track paths.\n3. Use fs.cp recursive, then rm agntc.json from dest if present\n4. Record directory paths with trailing slash for manifest consistency\n5. Create tests/copy-bare-skill.test.ts with real temp dir fixtures\n\n**Acceptance Criteria**:\n- Copies all files from source to {targetDir}/{skillName}/ per agent\n- Excludes agntc.json from copy\n- Creates destination dir recursively if missing\n- Copies to destination (conflict handling in add flow ensures clean destination before copy)\n- Returns copiedFiles with paths relative to projectDir, trailing slash for dirs\n- Skips agents where getTargetDir returns null\n- skillName = source directory basename\n- Subdirs copied recursively\n- Empty skill dir (only agntc.json) creates empty target, returns dir path\n- Works for multiple agents independently\n\n**Tests**:\n- copies SKILL.md and references to target\n- excludes agntc.json\n- preserves subdir structure\n- creates destination dir when missing\n- returns correct relative paths with trailing slash\n- skips agent when getTargetDir null\n- copies to multiple agents independently\n- handles empty skill dir\n- skillName matches source basename\n- handles deeply nested subdirs\n\n**Context**: Spec rule 4: bare skill — copy entire dir as skill named after source, exclude agntc.json. Manifest shows dir paths with trailing slashes. Phase 2 extends for multi-asset plugin copy.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:56:41Z","updated":"2026-02-19T22:05:25Z","closed":"2026-02-19T22:05:25Z"}
{"id":"tick-aaa446","title":"cs-1-9: Manifest Creation and Write","status":"done","priority":2,"description":"**Problem**: After copying files, the tool has install metadata but nowhere to persist it. Without a manifest, remove/update/list can't know what's installed. .agntc/ may or may not exist.\n\n**Solution**: Create manifest module with readManifest, writeManifest, addEntry. readManifest reads .agntc/manifest.json or returns {} if absent. addEntry merges new entry. writeManifest creates dir + writes atomically.\n\n**Outcome**: Tested manifest module handling first install (create dir+file), subsequent installs (merge preserving existing), and reinstall (overwrite entry).\n\n**Do**:\n1. Create src/manifest.ts with ManifestEntry type (ref, commit, installedAt, agents, files) and Manifest type (Record\u003cstring, ManifestEntry\u003e)\n2. readManifest(projectDir) — read .agntc/manifest.json, return {} on ENOENT, propagate other errors\n3. writeManifest(projectDir, manifest) — mkdir -p .agntc/, JSON.stringify 2-space indent + trailing newline, atomic write (write to temp file in .agntc/ then rename to manifest.json to avoid partial writes)\n4. addEntry(manifest, key, entry) — pure function, returns new manifest with entry added/replaced\n5. Create tests/manifest.test.ts with real temp dir fixtures\n6. Export all types and functions\n\n**Acceptance Criteria**:\n- readManifest returns {} when dir or file missing\n- readManifest parses valid manifest\n- readManifest propagates non-ENOENT errors\n- writeManifest creates .agntc/ and manifest.json if missing\n- writeManifest overwrites existing file\n- writeManifest uses 2-space indent + trailing newline\n- writeManifest uses atomic write (temp file + rename)\n- addEntry preserves existing entries, overwrites same key\n- addEntry is pure (no mutation)\n- ManifestEntry matches spec: ref, commit, installedAt, agents, files\n- Full round-trip works\n\n**Tests**:\n- readManifest empty when dir missing\n- readManifest empty when file missing but dir exists\n- readManifest parses single and multiple entries\n- readManifest propagates permission errors\n- readManifest throws on invalid JSON\n- writeManifest creates dir and file\n- writeManifest overwrites existing\n- writeManifest formats correctly\n- writeManifest uses atomic write (no partial writes on crash)\n- addEntry to empty manifest\n- addEntry preserving existing\n- addEntry overwrites same key (reinstall)\n- addEntry doesn't mutate input\n- round-trip write then read\n- entry stores null ref for HEAD, string commit, ISO timestamp, agent array, file array\n\n**Context**: Spec: .agntc/manifest.json, flat object keyed by manifest key. Created on first install. Naming spec confirms .agntc/ directory name. Spec requires single atomic write.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:58:03Z","updated":"2026-02-19T22:09:09Z","closed":"2026-02-19T22:09:09Z"}
{"id":"tick-d7ffd9","title":"cs-1-10: Add Command End-to-End Integration","status":"done","priority":2,"description":"**Problem**: All components exist in isolation but nothing wires them into the add command. User can't run npx agntc add owner/repo yet.\n\n**Solution**: Replace add stub with full Phase 1 pipeline: parse → clone → config → detect type → detect agents → select → copy → manifest → summary → cleanup. @clack/prompts for UI (intro, spinner, outro). Error handling with cleanup at each step. Non-bare-skill types show \"not yet supported\" and exit cleanly.\n\n**Outcome**: npx agntc add owner/repo against a bare-skill repo works end-to-end. Errors produce clear messages + cleanup. Non-bare-skill types handled gracefully.\n\n**Do**:\n1. Rewrite src/commands/add.ts with full pipeline: parse → clone → config → detect type → detect agents → select agents → copy → manifest → summary. Use @clack/prompts intro/outro and spinners for clone+copy.\n2. Error handling at each step: cancel message + cleanup + exit 1. Null config or plugin type → \"not yet supported\" + cleanup + exit 0. Empty agent selection → \"Cancelled\" + cleanup + exit 0.\n3. Write manifest via readManifest + addEntry + writeManifest. Summary shows key, ref, per-agent skill count.\n4. Cleanup temp dir in finally block (swallow cleanup errors). Detect agents via getRegisteredAgentIds + per-agent detect().\n5. Create tests/commands/add.test.ts mocking all dependencies: full happy path, error at each step, cleanup on all paths.\n\n**Acceptance Criteria**:\n- Full happy path works: parse → clone → config → detect → select → copy → manifest → summary → cleanup\n- @clack/prompts intro/outro and spinners shown\n- Errors at each step: clear message, cleanup, exit 1\n- Null config (collection) → not-yet-supported, cleanup, exit 0\n- Plugin type → not-yet-supported, cleanup, exit 0\n- Empty agent selection → cancelled, cleanup, exit 0\n- Summary shows key+ref and per-agent skill count\n- Temp dir cleaned in ALL paths (success, error, cancel)\n- Warnings forwarded to clack.log.warn\n- process.cwd() used as project dir\n\n**Tests**:\n- full happy path integration\n- intro/outro shown\n- spinners during clone and copy\n- error on invalid source (no clone attempted)\n- error + cleanup on clone failure\n- error + cleanup on invalid config\n- not-yet-supported for null config\n- not-yet-supported for plugin type\n- warning for not-agntc\n- forwards warnings to clack\n- detect called on all registered agents\n- correct args to selectAgents\n- cancel on empty selection + cleanup\n- correct args to copyBareSkill\n- error + cleanup on copy failure\n- reads existing manifest before adding\n- correct manifest entry fields\n- error + cleanup on manifest write failure\n- summary with key, ref, per-agent count\n- cleanup on success, error, and cancel\n- cleanup errors swallowed\n- skillName from parsed.repo\n\n**Context**: Capstone task of Phase 1. Wires components into spec's add flow. Phase 1 scope: bare-skill + GitHub shorthand only. Brackets deferred: collection select, reinstall, collision check, conflict check (Phases 2-3).\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T21:00:00Z","updated":"2026-02-19T22:21:57Z","closed":"2026-02-19T22:21:57Z"}
{"id":"tick-15542a","title":"cs-1-11: List Command (Minimal)","status":"done","priority":2,"description":"**Problem**: No way for users to see installed plugins. Manifest exists on disk but nothing reads and displays it.\n\n**Solution**: Implement list command to read manifest via readManifest (cs-1-9) and display formatted table via @clack/prompts. Minimal Phase 1 version — no update checks, no detail view, no inline actions.\n\n**Outcome**: npx agntc list shows installed plugins with key, ref, agents, install date. Handles empty/missing/malformed manifest.\n\n**Do**:\n1. Replace list stub in src/commands/list.ts\n2. readManifest(process.cwd())\n3. Empty manifest: \"No plugins installed. Run npx agntc add owner/repo to get started.\" via outro, exit 0\n4. Entries: intro(\"Installed plugins\"), display each with key, version info, agents, date, outro\n5. Version display: @{ref} when set, \"HEAD\" when ref null + commit exists, \"local\" when both null\n6. Agents: comma-separated\n7. Malformed manifest: catch error, \"Failed to read manifest: {error}\", exit 1\n8. Create tests/commands/list.test.ts\n\n**Acceptance Criteria**:\n- Reads manifest from process.cwd()\n- Empty/missing manifest shows spec's empty state message, exits 0\n- Displays each plugin with key, ref, agents, date\n- Ref shown as @tag, HEAD, or local appropriately\n- Malformed manifest shows error, exits 1\n- @clack/prompts for all output\n- No update checks, spinners, or interactivity\n\n**Tests**:\n- empty state for empty manifest\n- empty state for missing manifest\n- single plugin display\n- multiple plugins display\n- ref as tag (@v2.1.6)\n- ref as branch (@main)\n- HEAD when ref null + commit exists\n- local when both null\n- comma-separated agents\n- single agent without comma\n- error on malformed JSON\n- calls readManifest with cwd\n- uses clack intro/outro\n- exits 0 on success and empty\n- exits 1 on error\n\n**Context**: Spec empty state text: \"No plugins installed. Run npx agntc add owner/repo to get started.\" Phase 5 adds full dashboard. Phase 1 list is read-only display only.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T21:01:34Z","updated":"2026-02-19T22:30:51Z","closed":"2026-02-19T22:30:51Z"}
{"id":"tick-aed71e","title":"Phase 2: Multi-Asset Plugins and Collection Support","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-18T21:09:03Z","updated":"2026-02-18T21:09:03Z"}
{"id":"tick-a4cc6d","title":"cs-2-1: Multi-Asset Plugin Asset Copier","status":"done","priority":2,"description":"**Problem**: Phase 1 built copyBareSkill for whole-directory copy. Multi-asset plugins have skills/, agents/, hooks/ dirs whose contents must be individually routed through driver.getTargetDir(assetType). No copy logic exists for this shape.\n\n**Solution**: Create copyPluginAssets that takes source dir, assetDirs list, selected agents, project dir. For each agent × each asset dir: getTargetDir → null = skip, otherwise copy contents to resolved target. Returns copiedFiles (for manifest) and assetCountsByAgent (for summary).\n\n**Outcome**: Tested copier routing multi-asset plugin contents to correct targets, skipping unsupported types, handling empty dirs and nested subdirs.\n\n**Do**:\n1. Create src/copy-plugin-assets.ts with CopyPluginAssetsInput, AssetCounts, CopyPluginAssetsResult types\n2. For each agent × assetDir: getTargetDir(assetDir) → null = skip. Copy contents of source/assetDir to projectDir/targetDir. Track paths and counts.\n3. Copies CONTENTS of asset dirs, not the dirs themselves (skills/planning/ → .claude/skills/planning/)\n4. Create target dirs recursively. Track dir paths with trailing slash, file paths without.\n5. Return copiedFiles (deduped across agents) and assetCountsByAgent\n6. Create tests/copy-plugin-assets.test.ts with real temp dir fixtures\n\n**Acceptance Criteria**:\n- Copies skills/ contents to driver's skills target per agent\n- Copies agents/ contents to driver's agents target per agent\n- Copies hooks/ contents to driver's hooks target per agent\n- Skips asset types where getTargetDir returns null\n- Only processes asset dirs in assetDirs input\n- Copies contents not dirs themselves (no extra nesting)\n- Creates target dirs recursively\n- copiedFiles relative to projectDir, trailing slash for dirs\n- assetCountsByAgent with correct counts\n- Empty asset dirs: zero count, no error\n- Nested subdirs preserved\n- Works per agent independently\n- Does not copy root-level files (only asset dir contents)\n\n**Tests**:\n- copies skills/agents/hooks contents to targets\n- no extra nesting level\n- skips null getTargetDir\n- only processes listed assetDirs\n- creates missing target dirs\n- correct relative paths with trailing slash convention\n- correct per-agent counts\n- empty asset dir handled\n- nested subdirs preserved\n- mixed files and dirs in asset dir\n- multiple agents with different targets\n- subset of asset types\n- single asset type\n\n**Context**: Spec: \"copy contents of each to the appropriate target dir per agent.\" assetDirs from DetectedType (cs-1-5). Routing via driver.getTargetDir (cs-1-6). Claude: all 3 types. Codex (Phase 3): skills only.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-aed71e","created":"2026-02-18T21:09:16Z","updated":"2026-02-19T22:36:52Z","closed":"2026-02-19T22:36:52Z"}
{"id":"tick-456e1a","title":"cs-2-2: Add Command: Multi-Asset Plugin Integration","status":"done","priority":2,"description":"**Problem**: Add command returns \"not yet supported\" for plugin type. Users can't install multi-asset plugins. copyPluginAssets exists but nothing calls it.\n\n**Solution**: Replace plugin stub in add command with real pipeline: copyPluginAssets → manifest write → per-agent summary. Surface type detection warnings through @clack/prompts.\n\n**Outcome**: npx agntc add owner/repo against multi-asset plugin works end-to-end. Warnings for misconfigured/empty plugins display clearly.\n\n**Do**:\n1. Replace plugin branch in add command with: copyPluginAssets({ sourceDir, assetDirs, agents, projectDir }) inside spinner\n2. Check empty copiedFiles → warn \"no files to install\", cleanup, exit 0\n3. Write manifest entry with copiedFiles\n4. Render summary: \"Installed {key}[@{ref}]\" + per-agent counts (only non-zero types)\n5. Verify onWarn callback surfaces root SKILL.md warning and not-agntc warning\n6. Handle not-agntc with config: warn + cleanup + exit 0\n\n**Acceptance Criteria**:\n- Plugin type triggers copyPluginAssets with correct args\n- Manifest entry written with copiedFiles\n- Summary shows per-agent counts, omits zero-count types and no-asset agents\n- Empty plugin warns and exits 0 without manifest write\n- Root SKILL.md ignored warning surfaces\n- not-agntc with config shows warning\n- Temp dir cleaned in all paths\n- Spinner during copy\n- Bare-skill path still works\n\n**Tests**:\n- multi-asset plugin e2e install\n- manifest entry with correct fields\n- summary per-agent counts\n- summary omits zero counts\n- summary with/without ref\n- empty plugin warn + exit 0\n- SKILL.md misconfiguration warning\n- not-agntc warning\n- spinner during copy\n- cleanup on success, empty, error\n- copy error → message + exit 1\n- manifest write error → cleanup + exit 1\n- passes detected assetDirs (not hardcoded)\n- bare-skill path unchanged\n\n**Context**: DetectedType plugin has assetDirs. copyPluginAssets returns copiedFiles + assetCountsByAgent. Spec summary: only show non-zero types per agent.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-aed71e","created":"2026-02-18T21:10:58Z","updated":"2026-02-19T22:43:15Z","closed":"2026-02-19T22:43:15Z"}
{"id":"tick-46b8a2","title":"cs-2-3: Collection Plugin Multiselect UI","status":"done","priority":2,"description":"**Problem**: Collection repos show \"not yet supported\". Need to let users select which plugins to install. Must indicate already-installed plugins and handle cancel.\n\n**Solution**: Create selectCollectionPlugins taking plugins list, manifest, and key prefix. @clack/prompts multiselect with installed hints. Zero selection/cancel = empty array. Single-plugin collections still show multiselect.\n\n**Outcome**: Tested multiselect presenting all collection plugins with installed status, handling cancel, returning selected names.\n\n**Do**:\n1. Create src/collection-select.ts with selectCollectionPlugins({ plugins, manifest, manifestKeyPrefix })\n2. For each plugin: derive key as prefix/pluginName, check manifest, add \"(installed)\" hint if found\n3. @clack/prompts multiselect, required: false. Already-installed NOT pre-selected.\n4. Handle isCancel → empty array. Zero selection → brief message + empty array.\n5. Return selected plugin names as string[]\n6. Create tests/collection-select.test.ts mocking clack multiselect\n\n**Acceptance Criteria**:\n- Presents all plugins as multiselect options\n- Manifest key = prefix/pluginName\n- Installed plugins show \"(installed)\" hint\n- Cancel returns empty array\n- Zero selection returns empty array\n- Valid selection returns string[]\n- Single-plugin collection still shows multiselect\n- All-installed collection still shows multiselect\n- Empty plugins array returns empty without showing multiselect\n\n**Tests**:\n- presents all plugins\n- correct manifest key construction\n- installed hint shown\n- no hint for not-installed\n- mixed installed/not\n- cancel returns empty\n- zero selection returns empty\n- valid selection returns names\n- single plugin still shows multiselect\n- all installed still shows multiselect\n- empty plugins returns empty\n- correct options shape to clack\n\n**Context**: Spec: collection multiselect, installed plugins marked but selectable (reinstall). Zero selection = cancel. Manifest key: owner/repo/plugin-name. UI only — per-plugin processing in cs-2-4.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-aed71e","created":"2026-02-18T21:12:48Z","updated":"2026-02-19T22:47:18Z","closed":"2026-02-19T22:47:18Z"}
{"id":"tick-f68023","title":"cs-2-4: Add Command: Collection Integration","status":"done","priority":2,"description":"**Problem**: Add command shows \"Collections not yet supported\" for collection repos. Need to orchestrate per-plugin pipeline.\n\n**Solution**: Replace collection stub with: selectCollectionPlugins → for each plugin: readConfig, detectType, copy by type → single manifest write with owner/repo/plugin-name keys → per-plugin summary. Plugin failures skip with warning.\n\n**Outcome**: Collection repos present multiselect, install each selected plugin by type, write per-plugin manifest entries, show per-plugin summary.\n\n**Do**:\n1. Replace collection branch in add command\n2. selectCollectionPlugins({ plugins, manifest, manifestKeyPrefix })\n3. Empty selection → cancel + cleanup\n4. Agent detection + multiselect ONCE for all plugins. Empty → cancel + cleanup.\n5. Per plugin: readConfig(pluginDir) — ConfigError → warn + skip. null → warn + skip.\n6. detectType per plugin: bare-skill → copyBareSkill (skillName=pluginName). plugin → copyPluginAssets. not-agntc → warn + skip.\n7. Manifest key: manifestKeyPrefix/pluginName\n8. Single manifest write after all plugins\n9. Per-plugin summary with counts. Note skipped plugins.\n10. Cleanup in finally\n\n**Acceptance Criteria**:\n- Collection triggers selectCollectionPlugins with correct args\n- Agent multiselect once for all plugins\n- Each plugin validated independently\n- ConfigError skips plugin with warning\n- Bare-skill and multi-asset plugins handled by type\n- Manifest keys: owner/repo/plugin-name\n- Single manifest write\n- Per-plugin summary with counts\n- Skipped plugins noted\n- Empty selections cancel cleanly\n- Temp dir cleaned in all paths\n\n**Tests**:\n- collection with bare-skill plugins\n- collection with multi-asset plugins\n- mixed types install each by type\n- manifest keys correct\n- agent multiselect called once\n- invalid agntc.json skips plugin\n- missing agntc.json skips plugin\n- not-agntc skips plugin\n- all plugins failing exits 0\n- empty plugin/agent selection cancels\n- single manifest write\n- per-plugin summary\n- cleanup on all paths\n- no regression on standalone add\n\n**Context**: Spec: collection multiselect, each plugin independent, per-plugin summary. Agent multiselect once, pre-selection uses union of declared agents. Reinstall deferred to cs-2-5.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-aed71e","created":"2026-02-18T21:15:06Z","updated":"2026-02-19T22:56:02Z","closed":"2026-02-19T22:56:02Z"}
{"id":"tick-5820dd","title":"cs-2-5: Reinstall on Reselect","status":"done","priority":2,"description":"**Problem**: Selecting an already-installed plugin installs on top of existing files, leaving orphaned files from previous versions. Spec requires nuke-and-reinstall.\n\n**Solution**: Create nukeManifestFiles that deletes files from manifest entry before copying. ENOENT silently skipped. Works for both collection and standalone plugins. Reusable by update/remove in later phases.\n\n**Outcome**: Already-installed plugins' files nuked before re-copy. Missing files skipped gracefully. Manifest entry replaced with fresh data.\n\n**Do**:\n1. Create src/nuke-files.ts with nukeManifestFiles(projectDir, files) → { removed, skipped }\n2. Dirs (trailing /) → fs.rm recursive+force. Files → fs.rm force. ENOENT → skipped. Other errors propagate.\n3. In add command: before copying, check if manifestKey exists in manifest. If so, nukeManifestFiles.\n4. Applies to standalone and collection plugins alike\n5. addEntry replaces old manifest entry after reinstall\n6. Create tests/nuke-files.test.ts with real temp dirs\n7. Update add command tests for reinstall flow\n\n**Acceptance Criteria**:\n- Files nuked before copy begins\n- Directories removed recursively\n- ENOENT silently skipped\n- Non-ENOENT errors propagate\n- Returns removed and skipped lists\n- Per-plugin nuke independent (collection)\n- Manifest entry replaced not duplicated\n- Works for standalone reinstall\n- Works for collection reinstall\n- Different agent selection: old files nuked, new files created\n- Empty files array is no-op\n\n**Tests**:\n- nukes files before copy\n- removes directories recursively\n- removes individual files\n- skips ENOENT\n- returns removed/skipped lists\n- propagates EACCES\n- empty files is no-op\n- mix of existing and missing\n- standalone reinstall nukes first\n- collection reinstall nukes first\n- different agents: old removed, new created\n- only installed plugins nuked\n- manifest entry replaced\n- nuke failure on one collection plugin doesn't block others\n\n**Context**: Spec step 6: delete all manifest files before proceeding. Same mechanics as update's nuke step. nukeManifestFiles reusable by Phase 4 update and remove commands.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-aed71e","created":"2026-02-18T21:15:17Z","updated":"2026-02-20T08:40:36Z","closed":"2026-02-20T08:40:36Z"}
{"id":"tick-ef070a","title":"Phase 3: Multi-Agent Support and Source Formats","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-18T21:17:31Z","updated":"2026-02-18T21:17:31Z"}
{"id":"tick-3f18d0","title":"cs-3-1: Codex Agent Driver","status":"done","priority":2,"description":"**Problem**: Only Claude driver exists. Can't route assets to Codex targets. Adding Codex validates driver/strategy architecture.\n\n**Solution**: Implement CodexDriver satisfying AgentDriver. detect: .agents/ in project → which codex fallback. getTargetDir: skills → .agents/skills/, agents → null, hooks → null. Register in registry. Verify agent multiselect works with both agents.\n\n**Outcome**: CodexDriver registered, detectable, routing skills to .agents/skills/. Registry returns both claude and codex. Agent multiselect pre-selection works correctly with both agents per spec examples.\n\n**Do**:\n1. Create src/drivers/codex-driver.ts implementing AgentDriver\n2. detect: check .agents/ in project → which codex fallback. No ~/.codex/ check.\n3. getTargetDir: skills → .agents/skills, agents → null, hooks → null\n4. Register in registry under \"codex\"\n5. Verify getRegisteredAgentIds returns [\"claude\", \"codex\"]\n6. Create tests/drivers/codex-driver.test.ts\n7. Add tests to agent-select.test.ts verifying two-agent pre-selection/warning combinations with both Claude and Codex registered\n\n**Acceptance Criteria**:\n- detect true when .agents/ exists, skips system fallback\n- detect falls back to which codex\n- detect false when both fail, no throw\n- getTargetDir: skills → .agents/skills, agents → null, hooks → null\n- Registry includes codex, Claude unchanged\n- Agent multiselect pre-selection works correctly with both agents registered per spec examples\n\n**Tests**: detect with/without .agents/, which codex success/failure, getTargetDir for all types, registry lookup, both agents registered, two-agent pre-selection combinations match spec examples, unsupported warning on undeclared agent with both registered, empty declaredAgents warns both agents\n\n**Context**: Spec routing: Codex skills → .agents/skills/, agents → null, hooks → null. Detection: .agents/ then which codex. Absorbs cs-3-3 (two-agent multiselect verification).\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:20:09Z","updated":"2026-02-20T08:46:14Z","closed":"2026-02-20T08:46:14Z"}
{"id":"tick-947bd2","title":"cs-3-2: Agent Detection System","status":"done","priority":2,"description":"**Problem**: Detection is inline in add command. Need reusable detectAgents function for multiple commands.\n\n**Solution**: Extract detectAgents(projectDir) that loops registered drivers, calls detect() in parallel, returns detected AgentId[].\n\n**Outcome**: Tested detectAgents function. Add command uses it instead of inline loop.\n\n**Do**:\n1. Create src/detect-agents.ts with detectAgents(projectDir) → AgentId[]\n2. Loop getRegisteredAgentIds, detect each in parallel (Promise.all)\n3. Return detected IDs (may be empty). Individual failures → not detected.\n4. Replace inline detection in add command\n5. Create tests/detect-agents.test.ts\n\n**Acceptance Criteria**:\n- Returns detected AgentId[]\n- Parallel detection\n- Empty when none detected\n- Individual failure → not detected (no throw)\n- Add command uses detectAgents\n\n**Tests**: both detected, only one, none, parallel, individual failure, add command integration\n\n**Context**: Spec: detection for pre-selection, not gating. Project-level first, system fallback per driver.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:20:09Z","updated":"2026-02-20T08:52:26Z","closed":"2026-02-20T08:52:26Z"}
{"id":"tick-1abe95","title":"cs-3-3: Agent Multiselect with Pre-Selection and Warnings","status":"cancelled","priority":2,"description":"**Problem**: Phase 1 selectAgents built with Claude only. Need to verify and enhance for two-agent scenarios.\n\n**Solution**: Validate selectAgents with both agents registered. Verify pre-selection (declared ∩ detected), unsupported warnings, edge cases.\n\n**Outcome**: Multiselect correctly handles all two-agent declared/detected combinations.\n\n**Do**:\n1. Review src/agent-select.ts for two-agent correctness\n2. Add/update tests for all two-agent combinations\n3. Verify spec examples work\n4. Fix any gaps found\n\n**Acceptance Criteria**:\n- Both agents shown\n- Pre-selection = declared ∩ detected for all combinations\n- Unsupported warning on undeclared agents\n- Empty declaredAgents → all get warning\n- Unsupported agent selectable (warn never block)\n- Zero selection returns empty\n\n**Tests**: all declared/detected combinations, unsupported warnings, empty declared, no agents detected, user selects unsupported\n\n**Context**: Spec pre-selection examples. Warn never block. Works with Codex driver now registered.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:20:09Z","updated":"2026-02-19T12:04:30Z","closed":"2026-02-19T12:04:30Z"}
{"id":"tick-d63c08","title":"cs-3-4: Source Parsing: HTTPS URL","status":"done","priority":2,"description":"**Problem**: parseSource only handles GitHub shorthand. Need HTTPS URL support for any git host.\n\n**Solution**: Extend parseSource to detect https:// URLs, extract owner/repo from path, support @ref, return type \"https-url\" with cloneUrl. Normalize trailing slash and .git suffix.\n\n**Outcome**: parseSource handles HTTPS URLs from any host with correct manifest key and clone URL.\n\n**Do**:\n1. Add ParsedSource variant: { type: \"https-url\", owner, repo, ref, manifestKey, cloneUrl }\n2. Detect https:// prefix after trim\n3. Parse URL path: strip trailing slash/.git, extract last 2 segments as owner/repo\n4. Build cloneUrl: https://{host}/{owner}/{repo}.git\n5. manifestKey: owner/repo (host-independent)\n6. Update cloneSource to use cloneUrl for https-url type\n7. Update tests\n\n**Acceptance Criteria**:\n- Parses any host (github, gitlab, bitbucket)\n- Extracts owner/repo from URL path\n- Supports @ref suffix\n- Strips trailing slash and .git\n- manifestKey = owner/repo\n- cloneUrl normalized with .git\n- Throws for invalid URLs (no path, single segment)\n- GitHub shorthand still works\n\n**Tests**: various hosts, @ref, trailing slash, .git suffix, invalid URLs, no regression on shorthand\n\n**Context**: Spec: HTTPS URL format from any git host. manifest key = owner/repo regardless of format. @ref suffix supported.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:20:09Z","updated":"2026-02-20T08:58:11Z","closed":"2026-02-20T08:58:11Z"}
{"id":"tick-448957","title":"cs-3-5: Source Parsing: SSH URL","status":"done","priority":2,"description":"**Problem**: parseSource doesn't handle SSH URLs. Users with SSH auth can't use agntc add.\n\n**Solution**: Add type: \"ssh-url\" variant. Detect git@ prefix, parse host:owner/repo.git, handle missing .git, support @ref.\n\n**Outcome**: parseSource handles git@host:owner/repo.git[@ref] with correct cloneUrl, owner, repo, manifestKey.\n\n**Do**:\n1. Add ParsedSource variant: { type: \"ssh-url\", owner, repo, ref, manifestKey, cloneUrl }\n2. Detect git@ prefix. Split ref on last @ after repo path.\n3. Parse host:path, strip .git, extract owner/repo\n4. cloneUrl: git@host:owner/repo.git (normalized)\n5. manifestKey: owner/repo\n6. Throw for malformed URLs\n7. Update tests\n\n**Acceptance Criteria**: Parses git@host:owner/repo.git with/without ref, any host, missing .git handled, cloneUrl normalized, manifestKey=owner/repo, errors for malformed, no regression.\n\n**Tests**: with/without ref, tag/branch refs, missing .git, non-GitHub hosts, malformed URLs, no regression\n\n**Context**: Spec: git@github.com:owner/repo.git for SSH auth. @ref supported. manifestKey = owner/repo.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:23:36Z","updated":"2026-02-20T09:02:33Z","closed":"2026-02-20T09:02:33Z"}
{"id":"tick-db20a7","title":"cs-3-6: Source Parsing: Local Path","status":"done","priority":2,"description":"**Problem**: parseSource only handles remote sources. Need local paths for development/testing.\n\n**Solution**: Add type: \"local-path\" variant. Detect ./ ../ / ~ prefixes. Resolve absolute, expand tilde, validate exists + is directory at parse time. ref=null, manifestKey=absolute path.\n\n**Outcome**: parseSource handles local paths, validates existence, returns resolved absolute path.\n\n**Do**:\n1. Add ParsedSource variant: { type: \"local-path\", resolvedPath, ref: null, manifestKey }\n2. Detect path prefixes (./ ../ / ~)\n3. Expand ~, resolve to absolute via path.resolve\n4. Validate: fs.stat, must exist and be directory. Throw spec error message.\n5. manifestKey = resolvedPath\n6. Make parseSource async (fs.stat needed for path validation). Update callers: src/commands/add.ts (await parseSource), and all parseSource tests in tests/source-parser.test.ts (async test functions, await calls). This is a signature change affecting the add command pipeline.\n7. Update tests\n\n**Acceptance Criteria**: Resolves relative/absolute/tilde paths, validates exists+directory, throws spec error for missing/file, ref=null, manifestKey=absolute, tilde expanded, no regression.\n\n**Tests**: relative, absolute, tilde, non-existent, file not dir, permission denied, no regression\n\n**Context**: Spec: local paths for dev/testing. No clone. ref+commit null. Key=absolute path. Error: \"Path {path} does not exist or is not a directory.\"\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:23:36Z","updated":"2026-02-20T09:10:15Z","closed":"2026-02-20T09:10:15Z"}
{"id":"tick-0b36b0","title":"cs-3-7: Source Parsing: Direct Collection Path","status":"done","priority":2,"description":"**Problem**: Can't install a specific plugin from a collection via tree URL. Must add whole collection and multiselect.\n\n**Solution**: Add type: \"direct-path\" variant. Detect /tree/ in HTTPS URLs. Extract ref and plugin name from path. cloneUrl for whole repo. targetPlugin for skipping multiselect. Reject @ref suffix on tree URLs.\n\n**Outcome**: parseSource handles tree URLs, extracts ref+plugin from path, returns direct-path type. Add command skips multiselect for direct-path sources.\n\n**Do**:\n1. Add ParsedSource variant: { type: \"direct-path\", owner, repo, ref, targetPlugin, manifestKey, cloneUrl }\n2. Detect /tree/ in HTTPS URL path (before plain HTTPS fallthrough)\n3. Parse: owner/repo from path, ref = first segment after /tree/, plugin = rest\n4. cloneUrl: https://host/owner/repo.git\n5. manifestKey: owner/repo/plugin-name\n6. Throw for @ref suffix on tree URL, missing ref/plugin\n7. Wire into add command: when source is direct-path, skip collection multiselect and install targetPlugin directly. Remainder of flow (agent selection, collision check, copy) proceeds as normal.\n8. Update tests\n\n**Acceptance Criteria**: Parses tree URLs with branch/tag refs, correct targetPlugin, cloneUrl, manifestKey=owner/repo/plugin, throws for @ref suffix and missing segments, no regression, add command skips collection multiselect when source is direct-path and installs targetPlugin directly, remainder of add flow (agent selection, collision check, copy) proceeds as normal for direct-path sources.\n\n**Tests**: branch/tag refs, nested plugin paths, non-GitHub hosts, @ref suffix rejected, missing segments, no regression, add command bypasses collection multiselect for direct-path source, direct-path installs only the specified plugin, direct-path proceeds through agent selection and conflict checks normally, direct-path with targetPlugin not found in collection errors clearly.\n\n**Context**: Spec: direct path = collection shortcut, skips multiselect. Ref embedded in URL. manifestKey = owner/repo/plugin-name. \"The tool skips the collection multiselect and installs that plugin directly. The remainder of the flow proceeds as normal.\"\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:23:36Z","updated":"2026-02-20T09:16:17Z","closed":"2026-02-20T09:16:17Z"}
{"id":"tick-d24318","title":"cs-3-8: Local Path Source Integration","status":"done","priority":2,"description":"**Problem**: cs-3-6 parses local paths but add command still assumes remote sources (clone + temp dir). Need to wire local path through pipeline.\n\n**Solution**: Branch on type=local-path in add command. Skip clone, use resolvedPath as sourceDir. No temp dir cleanup. commit=null in manifest. Collection keys = absolutePath/pluginName.\n\n**Outcome**: npx agntc add ./my-plugin works without cloning. Correct manifest entry. Collections from local paths supported.\n\n**Do**:\n1. Branch on local-path early in add command\n2. sourceDir = parsed.resolvedPath (skip clone)\n3. Skip temp dir cleanup (conditional)\n4. Proceed with readConfig, detectType, select, copy as normal\n5. Manifest: ref=null, commit=null, key=resolvedPath\n6. Collections: manifestKeyPrefix = resolvedPath, plugin key = path/pluginName\n7. Summary shows \"local\" instead of ref\n8. Update tests\n\n**Acceptance Criteria**: Skips clone, uses resolvedPath, no temp dir, manifest ref+commit null, key=absolute path, bare skill+plugin+collection from local path, collection keys correct, local path with no agntc.json and no collection subdirs surfaces clear error and aborts, unreadable local path surfaces clear error and aborts, no regression.\n\n**Tests**: skip clone, resolvedPath as source, no cleanup, null ref/commit, correct key, bare skill/plugin/collection from local, collection keys, no agntc.json surfaces error, unreadable path surfaces error, summary, no regression\n\n**Context**: Spec: local path = no clone, copy directly. ref+commit null. Key = absolute path. Collection plugins: absolutePath/pluginName. ~ expanded. Spec error handling: \"If the local path doesn't exist, isn't readable, or contains no agntc.json: surface the error clearly and abort.\"\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:23:36Z","updated":"2026-02-20T09:25:00Z","closed":"2026-02-20T09:25:00Z"}
{"id":"tick-400db7","title":"cs-3-9: File Path Collision Check","status":"done","priority":2,"description":"**Problem**: Two plugins can install to overlapping paths, silently corrupting the first. No collision detection exists.\n\n**Solution**: checkFileCollisions diffs incoming files against manifest entries (excluding own key for reinstall). resolveCollisions offers remove-conflicting-plugin or cancel. No install-anyway option.\n\n**Outcome**: Collisions hard-block with clear prompt. User removes conflicting plugin in-flow or cancels. Reinstalls excluded from collision check.\n\n**Do**:\n1. Create src/collision-check.ts: checkFileCollisions(incomingFiles, manifest, excludeKey?) → CollisionResult\n2. Group collisions by manifest key\n3. Create src/collision-resolve.ts: resolveCollisions with remove or cancel options\n4. Remove = nukeManifestFiles + delete entry. Cancel = resolved: false.\n5. Multiple colliding plugins resolved sequentially\n6. Create tests\n\n**Acceptance Criteria**: Empty when no overlap, detects overlap, groups by key, excludes own key (reinstall), no install-anyway option, remove triggers nuke + entry removal, cancel returns false, multiple collisions sequential.\n\n**Tests**: no overlap, single/multi collision, exclude own key, directory paths, resolve remove/cancel, multiple plugins sequential, stop on cancel\n\n**Context**: Spec step 7: hard block on cross-plugin overlap. Remove then continue, or cancel. Reinstall nuke (step 6) runs before this.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:26:45Z","updated":"2026-02-20T09:32:52Z","closed":"2026-02-20T09:32:52Z"}
{"id":"tick-081566","title":"cs-3-10: Unmanaged File Conflict Check","status":"done","priority":2,"description":"**Problem**: User may have manually placed files at destination paths. Overwriting silently loses work. Need detection and prompt.\n\n**Solution**: checkUnmanagedConflicts scans destination paths on disk, excluding manifest-tracked files. Asset-level detection. resolveUnmanagedConflicts offers per-plugin overwrite-all (double confirmation) or cancel-plugin.\n\n**Outcome**: Unmanaged files detected. Per-plugin prompt with double-confirmed overwrite or cancel. Collections check independently.\n\n**Do**:\n1. Create src/unmanaged-check.ts: checkUnmanagedConflicts(incomingFiles, manifest, projectDir) → UnmanagedConflict[]\n2. Check disk existence, exclude manifest-tracked paths\n3. Asset-level: skill dir, agent file, hook file\n4. Create src/unmanaged-resolve.ts: per-plugin overwrite-all + second confirm, or cancel\n5. Return approved/cancelled lists\n6. Create tests\n\n**Acceptance Criteria**: Empty when nothing on disk, empty when all tracked, detects unmanaged assets, empty dir = conflict, asset-level detection, overwrite needs double confirm, cancel → cancelled, collections independent, all cancelled → empty approved.\n\n**Tests**: no files on disk, all tracked, unmanaged skill/agent/hook, empty dir, asset level, overwrite + confirm, overwrite + decline confirm, cancel, mixed collection, all cancelled\n\n**Context**: Spec step 8: scan for unmanaged files. Asset-level. Overwrite-all with second confirmation or cancel-plugin. After collision check passes. Note: overwrite-on-conflict also serves as the migration path from other tools (e.g., previous plugin managers) — no special migration tooling needed per spec.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:26:45Z","updated":"2026-02-20T09:37:34Z","closed":"2026-02-20T09:37:34Z"}
{"id":"tick-f5b1ac","title":"cs-3-11: Add Command Full Conflict Flow Integration","status":"done","priority":2,"description":"**Problem**: Collision check and unmanaged check exist but aren't wired into add command. Goes straight from agent select to copy.\n\n**Solution**: Wire both checks between agent selection and copy. Order: compute incoming files → collision check → resolve → unmanaged check → resolve → copy. All resolution before copying. Summary notes skipped plugins.\n\n**Outcome**: Full conflict flow for every install. Cancelled plugins excluded. No rollback needed.\n\n**Do**:\n1. Create computeIncomingFiles helper mirroring copy path computation\n2. For standalone: collision check → unmanaged check → copy\n3. For collections: per-plugin checks, cancelled excluded from copy\n4. Collision removal persists even if later cancelled\n5. Summary notes skipped plugins with reason\n6. Update tests\n\n**Acceptance Criteria**: Collision before unmanaged before copy, cancel at any stage exits cleanly, collections independent, removal persists after cancel, summary notes skips, computeIncomingFiles matches copy paths, no regression.\n\n**Tests**: collision before copy, unmanaged after collision, cancel at each stage, resolve then install, collection independent, all cancelled, removal persists, incoming files correct, no conflict path, manifest reflects all changes, cleanup on cancel\n\n**Context**: Spec steps 7-8 before step 9. All resolution before copying = no rollback. computeIncomingFiles mirrors copy logic.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:26:45Z","updated":"2026-02-20T09:45:46Z","closed":"2026-02-20T09:45:46Z"}
{"id":"tick-d85f8a","title":"Phase 4: Remove and Update Commands","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-18T21:28:58Z","updated":"2026-02-18T21:28:58Z"}
{"id":"tick-35621c","title":"cs-4-1: Remove Command: Parameterized Mode","status":"done","priority":2,"description":"**Problem**: No way to remove installed plugins. Users must manually delete files and edit manifest.\n\n**Solution**: Implement parameterized remove: parse key argument, match against manifest (exact, collection prefix, or not found), show files, confirm, nuke via nukeManifestFiles, remove entry, write manifest, summary.\n\n**Outcome**: npx agntc remove owner/repo deletes tracked files and manifest entry after confirmation.\n\n**Do**:\n1. Create src/commands/remove.ts with optional [key] argument\n2. readManifest → empty → \"No plugins installed.\", exit 0\n3. Match: exact key → single target. No exact → collection prefix (keys starting with key/) → multiple. No match → error, exit 1.\n4. Confirm: list files, @clack/prompts confirm. Decline → cancel, exit 0.\n5. nukeManifestFiles per target plugin\n6. Remove entries from manifest, writeManifest\n7. Summary: \"Removed {key}\" with counts\n8. Register in cli.ts\n\n**Acceptance Criteria**: Exact key removes single, prefix removes all collection plugins, non-existent exits 1 with spec message, empty manifest exits 0, confirmation shown, declined cancels, files nuked, manifest updated, summary shown, empty directories left in place after file deletion (no directory cleanup).\n\n**Tests**: standalone remove, collection prefix, specific collection plugin, non-existent key, empty manifest, confirmation shown/declined, files nuked, manifest updated, summary, ENOENT tolerance, preserves unrelated entries, empty parent directories left in place after removal.\n\n**Context**: Spec: confirm → delete → remove entry → write. nukeManifestFiles from cs-2-5. Error: \"Plugin {key} is not installed.\" No modification detection — the tool does not track checksums. If user modified installed files, those changes are lost on remove. Git is the safety net.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:45:19Z","updated":"2026-02-20T09:52:02Z","closed":"2026-02-20T09:52:02Z"}
{"id":"tick-5bc8a9","title":"cs-4-2: Remove Command: Interactive Mode","status":"done","priority":2,"description":"**Problem**: Users must know exact manifest key. Need no-arg interactive mode.\n\n**Solution**: No-arg reads manifest, presents @clack/prompts multiselect, selected plugins flow into same confirm → nuke → remove → write → summary path.\n\n**Outcome**: npx agntc remove (no args) shows selectable list. Selected plugins removed after confirmation.\n\n**Do**:\n1. No-arg branch in remove command\n2. readManifest → empty → message, exit 0\n3. @clack/prompts multiselect with all keys + ref hints\n4. Cancel/zero → exit 0\n5. Selection flows to parameterized confirm → nuke → remove → write → summary\n\n**Acceptance Criteria**: No-arg shows multiselect, cancel exits 0, selected flow to confirm+remove, empty manifest handled, single plugin still shows multiselect.\n\n**Tests**: multiselect shown, ref hints, cancel, zero selection, single/multi selection, empty manifest, declined confirmation, correct nuke args.\n\n**Context**: Spec: no-arg presents all plugins. Shares infrastructure with cs-4-1.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:45:19Z","updated":"2026-02-20T09:57:43Z","closed":"2026-02-20T09:57:43Z"}
{"id":"tick-76e6c7","title":"cs-4-3: Update Check Logic","status":"done","priority":2,"description":"**Problem**: No way to determine if a plugin has newer version. Update and list dashboard both need this.\n\n**Solution**: Create checkForUpdate returning typed result: update-available, up-to-date, newer-tags, check-failed, or local. Uses git ls-remote for remote comparison.\n\n**Outcome**: Tested update check handling all ref types with correct git ls-remote invocations.\n\n**Do**:\n1. Create src/update-check.ts with UpdateCheckResult union\n2. Local (ref=null, commit=null) → { status: 'local' }\n3. null ref (HEAD): ls-remote HEAD SHA → compare to commit\n4. Branch ref: ls-remote refs/heads/{ref} → compare\n5. Tag ref: always up-to-date + ls-remote --tags for newer tags\n6. Derive cloneUrl from manifest key\n7. All ls-remote failures → check-failed\n8. Create tests mocking child_process\n\n**Acceptance Criteria**: HEAD/branch/tag/local all handled correctly, ls-remote failure → check-failed, branch gone → check-failed, newer tags detected, clone URL derived from key.\n\n**Tests**: HEAD update-available/up-to-date, branch update/match/gone, tag up-to-date/newer-tags, local returns immediately, ls-remote failure/timeout, URL derivation, ls-remote output parsing.\n\n**Context**: Spec update check table. Used by update command and list dashboard (Phase 5).\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:45:19Z","updated":"2026-02-20T10:07:23Z","closed":"2026-02-20T10:07:23Z"}
{"id":"tick-2a89a4","title":"cs-4-4: Update Command: Single Plugin Nuke-and-Reinstall","status":"done","priority":2,"description":"**Problem**: No update command. Users must remove and re-add to get newer versions.\n\n**Solution**: Implement update with single-plugin mode: checkForUpdate → clone to temp → readConfig from temp → agent compat check → if all dropped: abort (preserve files) → if proceeding: nuke existing → copy from temp → update manifest. No confirmation. No agent re-prompt. Clone before nuke so agent compat can abort without file loss.\n\n**Outcome**: npx agntc update owner/repo checks, clones new version, verifies agent compat, then nukes and re-copies. All-agents-dropped preserves existing files. Clone failure doesn't affect installed files.\n\n**Do**:\n1. Create src/commands/update.ts with optional [key] argument\n2. readManifest → empty → message, exit 0. No match → error, exit 1.\n3. checkForUpdate → up-to-date → message, exit 0. check-failed → error, exit 1.\n4. update-available: cloneSource(same ref) to temp dir → readConfig from temp → agent compat check (cs-4-7) → if all agents dropped: warn, cleanup temp, exit 0 (existing files preserved) → if proceeding: nukeManifestFiles → detectType → copy from temp (effective agents) → update manifest entry → writeManifest → cleanup temp\n5. Summary: old→new commit + per-agent counts\n6. Register in cli.ts\n7. Handle clone failure: catch cloneSource errors with clear message. No files have been modified at this point since nuke hasn't happened yet. Cleanup temp dir.\n\n**Acceptance Criteria**: Non-existent key exits 1, empty manifest exits 0, up-to-date message, check-failed error, clone-then-nuke pipeline (clone before nuke so agent compat can abort without file loss), no confirmation, uses entry.agents (or effective agents after compat check), manifest updated with new commit/files, temp dir cleaned on all paths, clone failure does not affect existing installed files (nuke has not occurred), temp dir cleaned on clone failure.\n\n**Tests**: non-existent key, empty manifest, up-to-date, check-failed, clone-then-nuke-and-reinstall flow, same agents used, manifest updated, temp dir cleanup, already-deleted files, collection prefix updates all, clone failure leaves existing files intact (no nuke occurred), all-plugins mode continues after one plugin's clone failure, all-agents-dropped aborts before nuke (files preserved).\n\n**Context**: Spec nuke-and-reinstall: delete → re-clone same ref → re-copy same agents → update manifest. No confirmation. No agent re-selection. Pipeline reordered to clone-then-check-then-nuke so all-agents-dropped can abort without file loss per spec (\"Existing files are left in place\"). Absorbs cs-4-9 (clone failure handling simplified since nuke hasn't happened yet).\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:45:19Z","updated":"2026-02-20T10:15:00Z","closed":"2026-02-20T10:15:00Z"}
{"id":"tick-a1ef32","title":"cs-4-5: Update Command: Local Path Re-Copy","status":"done","priority":2,"description":"**Problem**: Local path plugins can't use git update. Need always-re-copy from stored path.\n\n**Solution**: Detect local status from checkForUpdate. Re-read agntc.json from stored path, check agent compat (cs-4-7), nuke existing if proceeding, re-copy with effective agents, update manifest. Always copies unless all agents dropped.\n\n**Outcome**: npx agntc update /path/to/plugin re-copies from source. Handles missing path. Agent compat checked before nuke.\n\n**Do**:\n1. Local-path branch in update after checkForUpdate returns 'local'\n2. Validate source path exists + is directory. Missing → error, exit 1.\n3. readConfig from stored path → agent compat check (cs-4-7) → if all agents dropped: warn, exit 0 (existing files preserved) → if proceeding: nukeManifestFiles → copy from path using effective agents → update manifest\n4. Summary: \"refreshed\" with counts\n\n**Acceptance Criteria**: Local detected, always re-copies, validates path, missing path errors, no git, manifest updated with null ref/commit, works for standalone and collection local, agent compat checked before nuke (re-reads agntc.json from stored path), all-agents-dropped preserves existing files, partial drop uses effective agents.\n\n**Tests**: local triggers re-copy, copies even if unchanged, validates path, errors when gone, errors no agntc.json, agent compat checked from stored path, all-agents-dropped preserves files, partial drop uses effective agents, nukes then copies, manifest updated with effective agents, no git clone, no temp dir.\n\n**Context**: Spec: local always re-copy. No change detection. Agent compat applies to all update types. Same class of fix as cs-4-4 clone-before-nuke, adapted for local (re-read config directly, no clone needed).\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:45:19Z","updated":"2026-02-20T10:20:08Z","closed":"2026-02-20T10:20:08Z"}
{"id":"tick-496cae","title":"cs-4-6: Update Command: Tag-Pinned Behavior","status":"done","priority":2,"description":"**Problem**: Tag-pinned plugins should never auto-upgrade but user should be informed of newer tags.\n\n**Solution**: Handle 'newer-tags' and 'up-to-date' from checkForUpdate for tag-pinned plugins. Display tag list and re-add command. No file/manifest changes.\n\n**Outcome**: Tag-pinned shows up-to-date or lists newer tags with upgrade command. No files touched.\n\n**Do**:\n1. Handle 'newer-tags' status in update command\n2. Display: pinned to {ref}, newer tags available, tag list (newest first)\n3. Show re-add command: npx agntc add {source}@{tag}\n4. 'up-to-date' for tags: brief message\n5. No file/manifest changes, exit 0\n\n**Acceptance Criteria**: Newer tags listed newest-first, re-add command shown, no newer tags → up-to-date, no files/manifest modified, exits 0.\n\n**Tests**: newer tags shown, no newer tags, re-add command, newest first, no nuke/clone/manifest write.\n\n**Context**: Spec: tag-pinned never auto-upgraded. Show available tags, re-add command.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:46:08Z","updated":"2026-02-20T10:23:42Z","closed":"2026-02-20T10:23:42Z"}
{"id":"tick-027b1d","title":"cs-4-7: Update Command: Agent Compatibility Changes","status":"done","priority":2,"description":"**Problem**: Plugin update may change agents field. Need to handle dropped agents without re-prompting.\n\n**Solution**: During update, after cloning new version to temp (before nuke), compare new agntc.json agents against manifest agents. effectiveAgents = intersection. All dropped → warn + abort update (existing files preserved). Partial drop → signal to proceed with remaining agents. New agents ignored.\n\n**Outcome**: Agent compat changes detected: partial drops warned, total drops abort preserving files, new agents ignored.\n\n**Do**:\n1. After re-clone + readConfig from temp dir: compare newConfig.agents vs entry.agents\n2. effectiveAgents = intersection\n3. All dropped: warn with spec message (includes remove command), return signal to abort update. Caller (cs-4-4) skips nuke and copy, cleans up temp dir, exits 0. Existing files preserved per spec.\n4. Partial drop: warn, return effectiveAgents for cs-4-4 to use for copy. manifest.agents updated after copy.\n5. New agents in config: silently ignore\n6. Summary: \"Updated for {agents}. {dropped} support removed.\"\n\n**Acceptance Criteria**: Detects dropped agents, all dropped warns+aborts+preserves existing files, partial drop warns+proceeds with remaining, manifest agents updated, dropped files removed (part of nuke after compat check passes), new agents ignored, no change proceeds normally, effectiveAgents used for copy.\n\n**Tests**: no change normal, partial drop warns/uses effective/updates manifest, all dropped warns/aborts/preserves files/shows remove cmd, all dropped exits 0, new agents ignored, single agent dropped from multi, effectiveAgents intersection correct.\n\n**Context**: Spec: re-read agntc.json, compare agents. Dropped → warn + remove files. All dropped → skip update, leave files, user decides. New → ignore. Runs after clone but before nuke in cs-4-4's corrected pipeline.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:46:08Z","updated":"2026-02-20T10:29:18Z","closed":"2026-02-20T10:29:18Z"}
{"id":"tick-7c0be9","title":"cs-4-8: Update Command: All-Plugins Mode","status":"done","priority":2,"description":"**Problem**: npx agntc update (no args) should update all installed plugins.\n\n**Solution**: No-arg mode: read manifest → parallel checkForUpdate → categorize → sequential processing per type → single manifest write → aggregate summary. Partial failures continue.\n\n**Outcome**: Processes all plugins. Mixed types handled. Partial failures noted. Summary per-plugin.\n\n**Do**:\n1. No-arg branch: readManifest → empty → message, exit 0\n2. Spinner: parallel checkForUpdate for all\n3. Categorize: update-available, local, newer-tags, up-to-date, check-failed\n4. Process updatable sequentially (nuke-and-reinstall / local re-copy)\n5. Tag-pinned: info only. Check-failed: note. All up-to-date: brief message.\n6. Single manifest write. Partial failures caught per-plugin.\n7. Aggregate summary\n\n**Acceptance Criteria**: All entries checked in parallel, each type processed correctly, partial failure continues, single manifest write, all up-to-date message, per-plugin summary.\n\n**Tests**: all entries processed, empty manifest, parallel checks, mixed types, partial failure continues, failed noted, single write, all up-to-date, per-plugin summary, spinner shown.\n\n**Context**: Spec: no-arg updates all. npm/brew convention. Each plugin independent.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:46:08Z","updated":"2026-02-20T10:42:07Z","closed":"2026-02-20T10:42:07Z"}
{"id":"tick-4ec9ff","title":"cs-4-9: Update Command: Network Retry","status":"cancelled","priority":2,"description":"**Problem**: Clone failures during update have unique context: files already nuked. Need proper error handling for this state.\n\n**Solution**: Verify cloneSource retry applies during update. Handle post-nuke clone failure: surface git error clearly with context that files have been removed.\n\n**Outcome**: Transient failures retried. Auth aborts immediately. Post-nuke failure produces actionable error.\n\n**Do**:\n1. Ensure cloneSource errors after nuke caught with context message\n2. Post-nuke clone failure: surface git error clearly with context that files have been removed\n3. Verify 3x retry applies during update\n4. Verify auth failure immediate abort\n5. Create update-specific clone failure tests\n\n**Acceptance Criteria**: Transient retried 3x, retry success completes update, auth aborts immediately, post-nuke failure surfaces git error with context, temp dir cleaned, all-plugins mode continues after one failure.\n\n**Tests**: transient retry, retry succeeds, auth abort, post-nuke error with context, temp dir cleaned, all-plugins continues, failed noted in summary.\n\n**Context**: Spec: 3x retry transient, no retry auth. Update adds nuance: files nuked before clone. Failure = degraded state. Spec does not prescribe specific recovery behavior for post-nuke clone failure — surface the error clearly and let the user decide next steps.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:46:08Z","updated":"2026-02-19T12:05:12Z","closed":"2026-02-19T12:05:12Z"}
{"id":"tick-32d35f","title":"cs-4-10: Update and Remove Output Formatting","status":"done","priority":2,"description":"**Problem**: Remove and update have functional logic but output needs polishing to match spec examples.\n\n**Solution**: Consistent @clack/prompts formatting for both commands. Exact spec message strings for agent compat warnings. Per-agent asset counts matching add command style.\n\n**Outcome**: Both commands produce clear output matching spec. All status variants formatted.\n\n**Do**:\n1. Remove confirmation: files grouped by type (skill dirs, agent files, hook files)\n2. Remove summary: \"Removed {key}\" with counts\n3. Update single: \"Updated {key}[@{ref}]: {old} → {new}\" + per-agent counts (non-zero only)\n4. Update all summary: per-plugin result line per status variant\n5. Agent compat messages match spec exactly: \"Plugin {key} no longer declares support for {agent}...\" and \"Updated for Claude. Codex support removed by plugin author — Codex files removed.\"\n6. Tag info: available tags + re-add command\n7. Spinners during clone/copy, intro/outro bookends\n8. Collection remove: list all affected plugins\n\n**Acceptance Criteria**: Remove files grouped by type, remove summary with counts, update shows commit transition, per-agent counts (non-zero only), tag info with re-add, check-failed noted, local shows re-copy, agent drop warning matches spec text, all up-to-date brief, spinners, intro/outro.\n\n**Tests**: remove file grouping, remove summary, update commit transition, per-agent counts, zero-count omitted, all-plugins per-plugin lines, tag list + re-add, check-failed, local message, agent drop spec text, all up-to-date, spinners, intro/outro, collection lists affected, partial failure distinguished.\n\n**Context**: Spec output examples lines 426-437. Consistent with add command summary style. @clack/prompts throughout.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:46:08Z","updated":"2026-02-20T10:48:26Z","closed":"2026-02-20T10:48:26Z"}
{"id":"tick-71886c","title":"Phase 5: List Dashboard and Error Hardening","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-18T21:48:24Z","updated":"2026-02-18T21:48:24Z"}
{"id":"tick-0f3e21","title":"cs-5-1: Parallel Update Check for All Plugins","status":"done","priority":2,"description":"**Problem**: List dashboard needs update status for all plugins. checkForUpdate handles one at a time. Need parallel bulk check behind spinner.\n\n**Solution**: Create checkAllForUpdates running checkForUpdate in parallel. Returns Map\u003cstring, UpdateCheckResult\u003e. Local plugins return immediately.\n\n**Outcome**: Tested parallel checker. Individual failures yield check-failed without blocking others. Empty manifest returns empty map.\n\n**Do**:\n1. Create src/update-check-all.ts: checkAllForUpdates(manifest) → Map\u003cstring, UpdateCheckResult\u003e\n2. Promise.all for parallel checks. Individual check failures → check-failed.\n3. Local → immediate (no remote check).\n4. Create tests mocking checkForUpdate\n\n**Acceptance Criteria**: All checked in parallel, individual failures isolated, local skips remote, empty manifest → empty map, mixed statuses handled.\n\n**Tests**: update-available, up-to-date, check-failed on failure, local immediate, empty manifest, all failing, mixed statuses, parallel not sequential, newer-tags for tag-pinned.\n\n**Context**: Spec: spinner then parallel ls-remote. Used by list dashboard and potentially update-all.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:52:23Z","updated":"2026-02-20T10:51:52Z","closed":"2026-02-20T10:51:52Z"}
{"id":"tick-b0cb9a","title":"cs-5-2: List View: Plugin List with Status Indicators","status":"done","priority":2,"description":"**Problem**: Phase 1 list is static read-only. Spec requires interactive selectable list with status indicators.\n\n**Solution**: Rewrite list command: readManifest → empty state → checkAllForUpdates with spinner → @clack/prompts select with status indicators → Done exits → selection returns key.\n\n**Outcome**: Interactive list with coloured status indicators. Done exits. Plugin selection enters detail view. Replaces cs-1-11.\n\n**Do**:\n1. Rewrite src/commands/list.ts replacing Phase 1 implementation\n2. Empty manifest → spec message, exit 0\n3. Spinner → checkAllForUpdates → build select options with status indicators per spec table\n4. Done option at bottom. Cancel = Done.\n5. Return selected key for navigation loop\n\n**Acceptance Criteria**: Empty state message, spinner during checks, correct status indicators with colours, ref shown when pinned, Done exits, cancel exits, single plugin shows list.\n\n**Tests**: empty state, spinner, all 5 status indicators, ref display, Done, cancel, single plugin, all-local, long keys.\n\n**Context**: Spec: selectable list, status indicators table, Done at bottom. Replaces cs-1-11.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:52:24Z","updated":"2026-02-20T10:57:12Z","closed":"2026-02-20T10:57:12Z"}
{"id":"tick-d19707","title":"cs-5-3: Detail View: Plugin Information Display","status":"done","priority":2,"description":"**Problem**: No detail view when plugin selected. Need to show full info and action options.\n\n**Solution**: Create renderDetailView showing key, ref, commit (7 chars), date, agents, per-agent counts, file list. Actions vary by update status per spec table.\n\n**Outcome**: Detail view renders all info. Actions vary by status. Local/HEAD/tag refs displayed correctly.\n\n**Do**:\n1. Create src/commands/list-detail.ts: renderDetailView({ key, entry, updateStatus }) → Action\n2. Display all fields. Compute asset counts from files array.\n3. Action select per spec status table.\n4. Cancel = Back.\n\n**Acceptance Criteria**: All fields displayed, ref variants correct, commit truncated, counts computed, actions match spec table, cancel = Back.\n\n**Tests**: all fields, local/HEAD/tag refs, commit truncation, asset counts, each action set by status, cancel, many files.\n\n**Context**: Spec detail view: all fields listed. Actions per status table.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:52:24Z","updated":"2026-02-20T11:05:38Z","closed":"2026-02-20T11:05:38Z"}
{"id":"tick-9d07b8","title":"cs-5-4: Detail View: Update Action","status":"done","priority":2,"description":"**Problem**: Update action selected from detail view but not wired. Need inline update staying in detail view.\n\n**Solution**: Execute update pipeline inline. Remote: clone to temp → agent compat check → nuke → copy (reuse cs-4-4 pipeline). Local: nuke → re-copy. Refresh detail view with success indicator. Failure shows error, stays in detail.\n\n**Outcome**: Update from detail view works. Refreshes with new data. Handles failures gracefully. All-agents-dropped aborts before nuke.\n\n**Do**:\n1. Handle update action in list-detail.ts\n2. Remote: clone to temp → agent compat check → nuke → copy (reuse cs-4-4 pipeline). Local: nuke → re-copy from path. Reuse Phase 4 logic.\n3. Success: return updated entry for refresh. Failure: show error, stay in detail.\n4. Handle agent compat changes (all-agents-dropped aborts before nuke, preserving existing files). Spinner during operations.\n\n**Acceptance Criteria**: Clone-then-nuke for remote, re-copy for local, detail refreshes on success, error stays in detail, agent compat handled (all-dropped aborts before nuke), spinner shown, temp dir cleaned, manifest updated.\n\n**Tests**: remote update, local update, success refresh, failure stays, agent compat, clone failure before nuke (existing files preserved), all-agents-dropped aborts before nuke, temp dir cleanup.\n\n**Context**: Spec: after Update remain in detail with refreshed info + success indicator. Reuses cs-4-4's corrected clone-before-nuke pipeline. No confirmation prompt.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:52:24Z","updated":"2026-02-20T11:13:59Z","closed":"2026-02-20T11:13:59Z"}
{"id":"tick-ba9807","title":"cs-5-5: Detail View: Remove Action","status":"done","priority":2,"description":"**Problem**: Remove action from detail view not wired. Need confirm → nuke → remove entry → return to list.\n\n**Solution**: Show files, confirm, nuke, remove entry, write manifest, return to list with message. Reuse cs-4-1 logic.\n\n**Outcome**: Remove from detail confirms, deletes, returns to list. Last plugin → empty state.\n\n**Do**:\n1. Handle remove action in list-detail.ts\n2. List files, confirm. Declined → Back.\n3. nukeManifestFiles, remove entry, writeManifest.\n4. Return removed action for list navigation.\n\n**Acceptance Criteria**: Files shown, declined = Back, confirmed removes + returns to list, last plugin → empty state, ENOENT tolerance, manifest updated.\n\n**Tests**: confirmation shown, declined, confirmed removes, returns to list, last plugin empty state, ENOENT tolerance, manifest preserves others.\n\n**Context**: Spec: after Remove return to list. Always confirm. Reuses cs-4-1 mechanics.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:52:24Z","updated":"2026-02-20T11:18:45Z","closed":"2026-02-20T11:18:45Z"}
{"id":"tick-39a172","title":"cs-5-6: Detail View: Change Version Action","status":"done","priority":2,"description":"**Problem**: Tag-pinned plugins with newer tags need Change version action. Not wired yet.\n\n**Solution**: Fetch tags via ls-remote, present selectable list (newest first), selection triggers clone-before-nuke reinstall at new tag. Agent compat checked before nuke. Remain in detail view.\n\n**Outcome**: Tag list presented, selection installs new version with correct pipeline, detail refreshes. All-agents-dropped preserves files.\n\n**Do**:\n1. Handle change-version in list-detail.ts\n2. Fetch tags, sort newest first. No tags → message, Back. Cancel → Back. Same tag → message, Back.\n3. Different tag: clone at new tag to temp → re-read agntc.json → agent compat check (reuse cs-4-7) → if all agents dropped: warn, cleanup temp, Back → if proceeding: nuke → copy from temp → update manifest with new ref + commit → cleanup temp. Reuse cs-4-4 pipeline with new ref.\n\n**Acceptance Criteria**: Tags newest-first, no tags handled, cancel = Back, same tag message, different tag triggers clone-before-nuke reinstall, agent compat checked before nuke, all-agents-dropped aborts (preserves files), manifest updated with new ref and commit, detail refreshes, temp dir cleaned.\n\n**Tests**: tags displayed, no tags, cancel, same tag, different tag reinstall with clone-before-nuke, agent compat checked, all-agents-dropped preserves files, manifest updated, refreshed detail, network failure, temp dir cleanup.\n\n**Context**: Spec: Change version = same mechanics as update with new ref. Uses cs-4-4 corrected clone-before-nuke pipeline.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:53:06Z","updated":"2026-02-20T11:24:03Z","closed":"2026-02-20T11:24:03Z"}
{"id":"tick-bb6c3b","title":"cs-5-7: List Navigation Loop","status":"done","priority":2,"description":"**Problem**: List and detail views exist but no loop connects them. Must re-run command after every action.\n\n**Solution**: While loop: list view → selection → detail → action → route (stay/return/exit). Re-read manifest each iteration. Removing last plugin → empty state.\n\n**Outcome**: Continuous interactive loop. Update/remove/navigate without restarting.\n\n**Do**:\n1. While loop in list.ts\n2. renderListView → Done/cancel = exit. Selection → renderDetailView → action routing.\n3. Back → continue. Removed → re-read manifest, continue. Updated → refresh detail.\n4. Empty manifest after remove → empty state, break.\n\n**Acceptance Criteria**: Back → list, Remove → list (plugin gone), Update → detail refresh, Done exits, cancel exits, last removed → empty state, manifest re-read, successive actions work.\n\n**Tests**: Back to list, Done exits, cancel exits, Remove returns to list, Update refreshes, last plugin → empty, successive actions, no stale data.\n\n**Context**: Spec: post-action routing table. Loop ties cs-5-2 through cs-5-6 together.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:53:06Z","updated":"2026-02-20T11:39:05Z","closed":"2026-02-20T11:39:05Z"}
{"id":"tick-95a48e","title":"cs-5-8: Partial Copy Failure Rollback","status":"done","priority":2,"description":"**Problem**: Copy failure midway leaves half-installed plugin. Spec requires rollback.\n\n**Solution**: Track copied paths during copy. On error, delete all tracked paths. Best-effort rollback (ENOENT skip, log other errors). Re-throw original error.\n\n**Outcome**: Copy failure rolls back all files. No manifest entry. Clean state.\n\n**Do**:\n1. Modify copyBareSkill/copyPluginAssets to track copiedFiles progressively\n2. try/catch: on error → rollbackCopiedFiles(tracked, projectDir)\n3. Create src/copy-rollback.ts: delete each path, ENOENT skip, log other errors\n4. Re-throw original error after rollback\n\n**Acceptance Criteria**: Failure triggers rollback, tracked files deleted, ENOENT skipped, rollback failure logged not thrown, original error propagated, no manifest entry, both copy functions support rollback, rollback after overwriting another plugin's file deletes the new copy (previous plugin's asset unrecoverable — accepted edge case per spec, user can update that plugin to restore).\n\n**Tests**: rollback on failure, no manifest entry, original error propagated, ENOENT skipped, rollback failure logged, successful copy unaffected, progressive tracking, both copy functions, rollback after cross-plugin overwrite deletes new copy (accepted loss).\n\n**Context**: Spec: rollback to clean state. Half-installed worse than none. Rollback edge case (cross-plugin overwrite) accepted per spec: \"If a copy fails after overwriting a file owned by another plugin, rollback deletes the new copy but the previous plugin's asset is already gone. Accepted as a narrow edge case — user can update the previous plugin to restore its files.\"\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:53:06Z","updated":"2026-02-20T11:44:33Z","closed":"2026-02-20T11:44:33Z"}
{"id":"tick-e908a4","title":"cs-5-9: Multi-Plugin Independent Failure Handling","status":"done","priority":2,"description":"**Problem**: Collection plugin failure can affect others. Need independent processing.\n\n**Solution**: Wrap per-plugin processing in try/catch. Track outcomes (installed/failed/skipped). Failed plugins rolled back. Successful ones keep manifest entries. Single manifest write.\n\n**Outcome**: Fault-tolerant collection installs. Individual failures isolated. Summary shows outcomes.\n\n**Do**:\n1. try/catch per plugin in collection flow\n2. Track outcomes: installed/failed/skipped with details\n3. Failed: rollback (cs-5-8). Successful: collect entry.\n4. Single writeManifest with successful entries only.\n5. All-fail exits 0 with summary.\n\n**Acceptance Criteria**: Each plugin independent, failed rolled back, successful preserved, single manifest write, all-fail exits 0, summary distinguishes outcomes, first succeeds + second fails works.\n\n**Tests**: first succeeds second fails, all fail, rollback on failure, skipped alongside failed, single manifest write, three plugins mixed, all succeed normal.\n\n**Context**: Spec: each plugin independent. Success keeps entry, failure rolls back. Summary per-plugin outcome.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:53:06Z","updated":"2026-02-20T11:53:46Z","closed":"2026-02-20T11:53:46Z"}
{"id":"tick-1028ba","title":"cs-5-10: Comprehensive Summary Output","status":"done","priority":2,"description":"**Problem**: Summary output is implemented inline across add (cs-1-10, cs-2-2, cs-2-4), update (cs-4-10), and remove (cs-4-1, cs-4-2) commands. Code is duplicated and formatting may have diverged. Need to extract into a single module for consistency and maintainability.\n\n**Solution**: Extract existing inline summary formatting from all commands into a shared src/summary.ts module with renderAddSummary, renderUpdateSummary, renderRemoveSummary. Unify formatting patterns. Wire back into all commands, replacing inline code. No new output behaviour — this is a refactoring task ensuring consistency with spec examples.\n\n**Outcome**: All commands produce consistent spec-compliant summaries via shared module. Mixed outcomes clearly formatted.\n\n**Do**:\n1. Create src/summary.ts extracting existing formatting from add, update, remove commands\n2. renderAddSummary: key+ref, per-agent counts (non-zero), failed/skipped noted for collections\n3. renderUpdateSummary: commit transition, per-plugin status, tag info, agent compat messages\n4. renderRemoveSummary: key + counts\n5. Wire into all commands replacing inline summary code\n\n**Acceptance Criteria**: Add matches spec format, collections show per-plugin, update shows transitions, tag info, agent compat spec text, remove shows counts, no zero-count lines, no empty agent sections, consistent @clack usage, no new output behaviour (refactoring only).\n\n**Tests**: add format, zero-count omitted, collection summaries, failed/skipped noted, update transitions, tag re-add command, agent drop spec text, remove counts, mixed outcomes, all up-to-date, single plugin concise.\n\n**Context**: Refactoring extraction task. Inline formatting built across Phases 1-4. This task unifies for consistency. Spec summary examples lines 337-346, 426-437.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:53:06Z","updated":"2026-02-20T12:04:17Z","closed":"2026-02-20T12:04:17Z"}
{"id":"tick-9b3876","title":"Phase 6: Analysis (Cycle 1)","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-20T13:12:57Z","updated":"2026-02-20T13:12:57Z"}
{"id":"tick-7180d4","title":"cs-6-1: Extract shared nuke-and-reinstall pipeline","status":"done","priority":2,"description":"**Problem**: The core update pipeline (readConfig, computeEffectiveAgents, detectType, build agent+driver pairs, nukeManifestFiles, conditional copy, construct ManifestEntry) is independently implemented 6+ times across src/commands/update.ts, src/commands/list-update-action.ts, and src/commands/list-change-version-action.ts. This is ~250 lines of near-identical logic with minor variations in error handling style and ManifestEntry field construction. The dropped-agents warning message string is copy-pasted identically across all of them.\n\n**Solution**: Extract a shared function (e.g., executeNukeAndReinstall) in a new module (e.g., src/nuke-reinstall-pipeline.ts) that takes a sourceDir, manifest entry, key, projectDir, and an options bag (onWarn callback, new ref/commit values) and returns the new ManifestEntry + copiedFiles. Each call site reduces to: resolve sourceDir, call the shared pipeline, handle the result per its own error convention.\n\n**Outcome**: One canonical implementation of the nuke-and-reinstall pipeline. Call sites in update.ts (runGitUpdate, runLocalUpdate, processGitUpdateForAll, processLocalUpdateForAll), list-update-action.ts, and list-change-version-action.ts each become thin wrappers (~10 lines) that resolve the source directory and call the shared function. ~200 lines of duplicate code eliminated.\n\n**Do**:\n1. Create src/nuke-reinstall-pipeline.ts with a function that encapsulates the shared pipeline: readConfig from sourceDir, compute effective agents (intersection of manifest agents and new config agents), detect type, build agent+driver pairs, nuke existing manifest files, copy (plugin or bare-skill), construct new ManifestEntry\n2. Define an options interface for the function: { key: string; sourceDir: string; existingEntry: ManifestEntry; projectDir: string; newRef?: string | null; newCommit?: string | null; onAgentsDropped?: (dropped: string[], kept: string[]) =\u003e void }\n3. Return a result object: { entry: ManifestEntry; copiedFiles: string[]; droppedAgents: string[] }\n4. Refactor runGitUpdate and runLocalUpdate in update.ts to use the shared function\n5. Refactor processGitUpdateForAll and processLocalUpdateForAll in update.ts to use the shared function\n6. Refactor runRemoteUpdate and runLocalUpdate in list-update-action.ts to use the shared function\n7. Refactor executeChangeVersionAction in list-change-version-action.ts to use the shared function\n8. Consolidate the buildParsedSource/getSourceDir helpers that were only needed because the pipeline was duplicated (see also Task 10)\n9. Ensure all existing tests pass -- update mocks as needed to point at the new module\n\n**Acceptance Criteria**:\n- The nuke-and-reinstall sequence exists in exactly one function\n- All 6+ call sites delegate to the shared function\n- No behavioral changes -- same warnings, same manifest entries, same error handling at each call site\n- All existing unit tests pass (with updated mocks where needed)\n\n**Tests**:\n- Unit test the shared pipeline function with mocked dependencies: verify it calls nukeManifestFiles, readConfig, detectType, copy functions, and returns correct ManifestEntry\n- Test that dropped-agents warning callback is invoked when new config removes agents\n- Test that when all agents are dropped, the function returns appropriately (no copy, signal to caller)\n- Verify existing command-level tests still pass after refactor","parent":"tick-9b3876","created":"2026-02-20T13:13:23Z","updated":"2026-02-20T13:26:50Z","closed":"2026-02-20T13:26:50Z"}
{"id":"tick-cf8b24","title":"cs-6-2: Add collection prefix matching to update command","status":"done","priority":2,"description":"**Problem**: The spec defines three invocation modes for update: no-arg (all), owner/repo (specific plugin or all from collection), and owner/repo/plugin-name (specific collection plugin). The implementation does a direct manifest lookup (manifest[key]) which fails with \"Plugin {key} is not installed\" when owner/repo is passed but the manifest only contains collection entries like owner/repo/plugin-name. The remove command correctly implements this via resolveTargetKeys with prefix matching, but update lacks equivalent logic.\n\n**Solution**: Add prefix-matching logic to runUpdate in src/commands/update.ts (similar to resolveTargetKeys in src/commands/remove.ts) so that npx agntc update owner/repo resolves to all collection plugins under that prefix and updates them sequentially.\n\n**Outcome**: npx agntc update owner/repo correctly finds and updates all collection plugins whose keys start with owner/repo/, matching the spec and the behavior already implemented in the remove command.\n\n**Do**:\n1. Extract or reuse the resolveTargetKeys logic from src/commands/remove.ts -- either import it directly or extract to a shared manifest utility\n2. In runUpdate (src/commands/update.ts), replace the direct manifest[key] lookup with prefix-matching resolution\n3. When prefix matching finds multiple keys, iterate and update each one sequentially (same as remove does)\n4. When prefix matching finds zero keys, display \"Plugin {key} is not installed.\" and exit with non-zero code (existing behavior)\n5. Ensure the single-key exact match path still works as before\n\n**Acceptance Criteria**:\n- npx agntc update owner/repo updates all collection plugins under that prefix\n- npx agntc update owner/repo/plugin-name updates that specific plugin (exact match)\n- npx agntc update nonexistent/repo shows \"Plugin nonexistent/repo is not installed.\" error\n- Behavior matches the remove command's resolution logic\n\n**Tests**:\n- Test that update owner/repo resolves to multiple collection keys and updates each\n- Test that update owner/repo/plugin-name resolves to exact match\n- Test that update nonexistent/key produces the correct error message\n- Test edge case: owner/repo exists as both a standalone key and a collection prefix -- exact match takes priority","parent":"tick-9b3876","created":"2026-02-20T13:13:39Z","updated":"2026-02-20T13:36:18Z","closed":"2026-02-20T13:36:18Z"}
{"id":"tick-a00a08","title":"cs-6-3: Fix nuke-before-copy data loss risk on copy failure","status":"done","priority":2,"description":"**Problem**: In the update pipeline, the sequence is: nuke existing files -\u003e copy new files. If copy fails after nuke (disk full, permission error), the user's installed files are gone with no recovery path. The spec says \"Rollback to clean state\" for partial copy failures, but rollback only deletes newly-copied files -- it cannot restore the nuked originals. This is a latent data-loss risk.\n\n**Solution**: Before nuking, record the list of files that will be removed. If copy fails after nuke, log a clear recovery message: \"Update failed after removing old files. Run npx agntc update {key} to retry.\" This is the minimum viable safety net within the current nuke-and-reinstall architecture. A more robust fix (staging area + atomic swap) can be considered later.\n\n**Outcome**: Users who hit a copy failure during update get a clear, actionable message telling them how to recover, rather than being left in a silently broken state.\n\n**Do**:\n1. In the nuke-and-reinstall pipeline (whether in the shared function from Task 1 or in the current individual implementations), wrap the copy step in a try/catch\n2. If copy fails after nuke has completed, catch the error and log a prominent warning: \"Update failed for {key} after removing old files. The plugin is currently uninstalled. Run npx agntc update {key} to retry installation.\"\n3. Remove the plugin's manifest entry (since files are gone) so the state is consistent -- or alternatively, keep the entry so update can retry\n4. Re-throw or return the error so the caller can handle it appropriately\n5. This task is independent of Task 1 -- apply to whichever code structure exists at execution time\n\n**Acceptance Criteria**:\n- Copy failure after nuke produces a clear, user-facing recovery message\n- The manifest state is consistent with the filesystem state after failure\n- No silent data loss -- the user always knows what happened and how to fix it\n\n**Tests**:\n- Mock copy to throw after nuke succeeds, verify the recovery message is output\n- Verify manifest state is consistent after copy failure (entry removed or marked for retry)\n- Verify the error propagates to the caller","parent":"tick-9b3876","created":"2026-02-20T13:13:54Z","updated":"2026-02-20T13:48:59Z","closed":"2026-02-20T13:48:59Z"}
{"id":"tick-8387d9","title":"cs-6-4: Strengthen type safety for AssetType, AgentId, and AgentWithDriver","status":"done","priority":2,"description":"**Problem**: Three related type safety gaps: (1) AgentDriver.getTargetDir accepts string when the valid asset types are the known finite set \"skills\" | \"agents\" | \"hooks\". (2) ManifestEntry.agents and AgntcConfig.agents are typed as string[] instead of AgentId[], forcing as AgentId[] casts at ~12 call sites. (3) The AgentWithDriver interface is independently declared in 3 files (copy-bare-skill.ts, copy-plugin-assets.ts, compute-incoming-files.ts).\n\n**Solution**: (1) Define type AssetType = typeof ASSET_DIRS[number] and use it in getTargetDir(assetType: AssetType). (2) Change ManifestEntry.agents and AgntcConfig.agents to AgentId[]. (3) Export AgentWithDriver from src/drivers/types.ts and import in the three consuming files.\n\n**Outcome**: Compile-time validation catches invalid asset type strings and agent identifiers. No more as AgentId[] casts. AgentWithDriver defined once.\n\n**Do**:\n1. In src/type-detection.ts, export type AssetType = typeof ASSET_DIRS[number]\n2. In src/drivers/types.ts, change getTargetDir(assetType: string) to getTargetDir(assetType: AssetType) (import AssetType from type-detection)\n3. Update src/drivers/claude-driver.ts and src/drivers/codex-driver.ts internal TARGET_DIRS records to use Partial\u003cRecord\u003cAssetType, string\u003e\u003e\n4. In src/drivers/types.ts, add export interface AgentWithDriver { id: AgentId; driver: AgentDriver }\n5. Remove the local AgentWithDriver declarations from src/copy-bare-skill.ts, src/copy-plugin-assets.ts, src/compute-incoming-files.ts and import from src/drivers/types.ts\n6. In src/manifest.ts, change ManifestEntry.agents from string[] to AgentId[] (import AgentId from drivers/types)\n7. In src/config.ts, change AgntcConfig.agents from string[] to AgentId[]\n8. Remove all as AgentId[] casts across the codebase (at least 12 occurrences in add.ts, update.ts, list-update-action.ts, list-change-version-action.ts)\n9. Fix any resulting type errors -- the validation in readConfig already filters to known agents, so the return type naturally becomes AgentId[]\n10. Verify all tests compile and pass\n\n**Acceptance Criteria**:\n- getTargetDir only accepts \"skills\" | \"agents\" | \"hooks\" at compile time\n- ManifestEntry.agents and AgntcConfig.agents are typed AgentId[]\n- Zero as AgentId[] casts remain in the codebase\n- AgentWithDriver is defined in exactly one file and imported elsewhere\n- All tests pass\n\n**Tests**:\n- Existing unit tests should pass without modification (behavioral no-op)\n- Verify TypeScript compilation catches a test file that passes an invalid string to getTargetDir (manual check during development)","parent":"tick-9b3876","created":"2026-02-20T13:14:10Z","updated":"2026-02-20T14:01:44Z","closed":"2026-02-20T14:01:44Z"}
{"id":"tick-42ff1b","title":"cs-6-5: Store original clone URL in manifest to fix non-GitHub update flows","status":"done","priority":2,"description":"**Problem**: update-check.ts derives the clone URL from the manifest key by hardcoding https://github.com/${owner}/${repo}.git. The same pattern is repeated via buildParsedSource in update.ts and list-update-action.ts. Plugins originally installed via HTTPS from GitLab/Bitbucket or via SSH will have update checks and re-clones pointed at github.com instead of the original host. The manifest stores only owner/repo as the key -- the original host is lost during key derivation.\n\n**Solution**: Add a cloneUrl: string | null field to ManifestEntry. Populate it during add from the parsed source. Use it during update checks and re-clones instead of reconstructing from the key. null for local path installs.\n\n**Outcome**: Update checks and re-clones use the original clone URL, correctly handling non-GitHub git hosts and SSH URLs.\n\n**Do**:\n1. Add cloneUrl: string | null to the ManifestEntry interface in src/manifest.ts\n2. In the add command (src/commands/add.ts), populate cloneUrl from the parsed source (the full HTTPS/SSH URL, or null for local paths)\n3. In src/update-check.ts, use entry.cloneUrl instead of deriveCloneUrl(key) for git ls-remote. Fall back to the github.com derivation if cloneUrl is null (backward compatibility with existing manifests)\n4. In src/commands/update.ts, use entry.cloneUrl for re-cloning instead of rebuilding from key\n5. In src/commands/list-update-action.ts and src/commands/list-change-version-action.ts, use entry.cloneUrl for re-cloning\n6. Handle backward compatibility: existing manifests without cloneUrl fall back to current github.com derivation behavior\n7. Update all tests that construct ManifestEntry objects to include the new field\n\n**Acceptance Criteria**:\n- ManifestEntry has a cloneUrl field\n- New installs store the original clone URL\n- Update checks use the stored URL, not a reconstructed one\n- Existing manifests without cloneUrl still work (backward compatible)\n\n**Tests**:\n- Test that add from a GitLab HTTPS URL stores the correct cloneUrl\n- Test that add from SSH URL stores the correct cloneUrl\n- Test that add from local path stores null\n- Test that update-check uses entry.cloneUrl when available\n- Test backward compatibility: entry without cloneUrl falls back to github.com derivation","parent":"tick-9b3876","created":"2026-02-20T13:14:23Z","updated":"2026-02-20T14:18:55Z","closed":"2026-02-20T14:18:55Z"}
{"id":"tick-c04b35","title":"cs-6-6: Fix config validation error messages to include spec-required prefix","status":"done","priority":2,"description":"**Problem**: The spec defines error messages \"Invalid agntc.json: agents field is required\" and \"Invalid agntc.json: agents must not be empty\". The implementation throws ConfigError with messages \"agents field is required\" and \"agents must not be empty\" -- missing the \"Invalid agntc.json:\" prefix. The JSON parse error correctly includes the prefix, but the structural validation errors do not.\n\n**Solution**: Add the \"Invalid agntc.json: \" prefix to the two structural validation error messages in src/config.ts.\n\n**Outcome**: All config validation errors consistently include the spec-required prefix.\n\n**Do**:\n1. In src/config.ts line 50, change the error message from \"agents field is required\" to \"Invalid agntc.json: agents field is required\"\n2. In src/config.ts line 56, change the error message from \"agents must not be empty\" to \"Invalid agntc.json: agents must not be empty\"\n3. Update any tests that assert on these exact error message strings\n\n**Acceptance Criteria**:\n- Missing agents field error: \"Invalid agntc.json: agents field is required\"\n- Empty agents array error: \"Invalid agntc.json: agents must not be empty\"\n- Matches the spec exactly\n\n**Tests**:\n- Test that missing agents field produces error with \"Invalid agntc.json:\" prefix\n- Test that empty agents array produces error with \"Invalid agntc.json:\" prefix","parent":"tick-9b3876","created":"2026-02-20T13:14:29Z","updated":"2026-02-20T14:21:59Z","closed":"2026-02-20T14:21:59Z"}
{"id":"tick-a4046d","title":"cs-6-7: Fix computeIncomingFiles granularity for plugin collision/unmanaged checks","status":"done","priority":2,"description":"**Problem**: The spec states unmanaged conflict detection operates at the \"asset level\" -- each skill directory, each agent file, each hook file is one conflict. The computePluginFiles function in src/compute-incoming-files.ts produces parent target directory paths (e.g., .claude/skills/, .claude/agents/) rather than individual asset paths within those directories. This means collision and unmanaged checks operate at the wrong granularity for plugin mode. Bare-skill mode is correct.\n\n**Solution**: computePluginFiles should scan the source asset directories and produce individual asset-level paths (e.g., .claude/skills/planning/, .claude/agents/executor.md) rather than parent directory paths.\n\n**Outcome**: Collision and unmanaged conflict checks operate at the correct asset-level granularity as specified, enabling accurate per-asset conflict detection for plugins.\n\n**Do**:\n1. Modify computePluginFiles in src/compute-incoming-files.ts to accept the source directory as an additional parameter\n2. For each asset type directory found (skills/, agents/, hooks/), scan its contents to enumerate individual assets\n3. For skills: each subdirectory becomes a path entry (e.g., .claude/skills/planning/)\n4. For agents: each file becomes a path entry (e.g., .claude/agents/executor.md)\n5. For hooks: each file becomes a path entry (e.g., .claude/hooks/pre-commit.sh)\n6. Update all call sites of computePluginFiles to pass the source directory\n7. Verify that checkFileCollisions and checkUnmanagedFiles work correctly with the new fine-grained paths\n8. Update existing tests for compute-incoming-files\n\n**Acceptance Criteria**:\n- Plugin incoming files are enumerated at individual asset level, not parent directory level\n- Skill directories, agent files, and hook files each produce their own path entry\n- Collision checks match at asset granularity\n- Bare-skill mode behavior unchanged\n\n**Tests**:\n- Test computePluginFiles with a source dir containing skills/planning/, skills/review/, agents/executor.md -- verify all individual paths are produced\n- Test that collision check correctly identifies overlapping individual assets between plugins\n- Test that unmanaged check correctly identifies individual existing assets","parent":"tick-9b3876","created":"2026-02-20T13:14:45Z","updated":"2026-02-20T14:27:59Z","closed":"2026-02-20T14:27:59Z"}
{"id":"tick-a3306f","title":"cs-6-8: Extract shared isNodeError type guard","status":"done","priority":2,"description":"**Problem**: The identical function isNodeError(err: unknown): err is NodeJS.ErrnoException checking err instanceof Error \u0026\u0026 \"code\" in err is defined independently in src/config.ts, src/manifest.ts, and src/nuke-files.ts.\n\n**Solution**: Extract to a shared utility module and import from the three consuming files.\n\n**Outcome**: One definition of isNodeError, imported by all consumers. Eliminates copy-paste drift risk.\n\n**Do**:\n1. Create src/errors.ts (or add to an existing utils module) with the exported isNodeError function\n2. Remove the local isNodeError from src/config.ts, src/manifest.ts, and src/nuke-files.ts\n3. Add import { isNodeError } from \"./errors\" to each file\n4. Verify all tests pass\n\n**Acceptance Criteria**:\n- isNodeError is defined in exactly one file\n- All three consumers import from the shared location\n- No behavioral change\n\n**Tests**:\n- Existing tests should pass without modification","parent":"tick-9b3876","created":"2026-02-20T13:14:52Z","updated":"2026-02-20T14:31:10Z","closed":"2026-02-20T14:31:10Z"}
{"id":"tick-6b7df4","title":"cs-6-9: Extract shared execGit helper","status":"done","priority":2,"description":"**Problem**: Both src/git-clone.ts and src/update-check.ts define their own execGit wrapper around child_process.execFile. The implementations are structurally identical -- promise wrapper, git error with stderr, resolve/reject. Only the timeout differs (60s for clone, 15s for update-check).\n\n**Solution**: Extract a shared execGit(args, options?) into src/git-utils.ts that accepts an optional timeout parameter with a sensible default.\n\n**Outcome**: One execGit implementation, two call sites passing their desired timeouts.\n\n**Do**:\n1. Create src/git-utils.ts with execGit(args: string[], options?: { timeout?: number; cwd?: string }): Promise\u003cstring\u003e\n2. Move the promise-wrapped execFile logic from either file into the shared module\n3. Update src/git-clone.ts to import and use the shared execGit with { timeout: 60_000 }\n4. Update src/update-check.ts to import and use the shared execGit with { timeout: 15_000 }\n5. Verify all tests pass\n\n**Acceptance Criteria**:\n- execGit is defined in exactly one file\n- Both consumers import from the shared location and pass their own timeouts\n- No behavioral change\n\n**Tests**:\n- Existing git-clone and update-check tests should pass without modification","parent":"tick-9b3876","created":"2026-02-20T13:14:58Z","updated":"2026-02-20T14:36:01Z","closed":"2026-02-20T14:36:01Z"}
{"id":"tick-8fe97c","title":"cs-6-10: Extract shared buildParsedSource and getSourceDir helpers","status":"done","priority":2,"description":"**Problem**: Both buildParsedSource(key, ...) and getSourceDir(tempDir, key) are independently implemented in src/commands/update.ts, src/commands/list-update-action.ts, and src/commands/list-change-version-action.ts. The implementations are nearly identical -- buildParsedSource splits the key on \"/\" to extract owner/repo and constructs a ParsedSource, getSourceDir joins remaining key segments onto tempDir.\n\n**Solution**: Extract both into a shared module (e.g., add to src/source-parser.ts or create src/manifest-key-utils.ts). Normalize buildParsedSource to accept (key: string, ref: string | null) to cover both calling conventions.\n\n**Outcome**: One implementation of each helper, imported by three consuming files. ~60 lines of duplication eliminated.\n\n**Do**:\n1. Add buildParsedSourceFromKey(key: string, ref: string | null): ParsedSource to src/source-parser.ts (or create a new module)\n2. Add getSourceDirFromKey(tempDir: string, key: string): string to the same module\n3. Remove local implementations from src/commands/update.ts, src/commands/list-update-action.ts, and src/commands/list-change-version-action.ts\n4. Update imports in all three files\n5. Verify all tests pass\n\n**Acceptance Criteria**:\n- buildParsedSource and getSourceDir each defined in exactly one file\n- All three consumers import from the shared location\n- No behavioral change\n\n**Tests**:\n- Unit test buildParsedSourceFromKey with standalone key (\"owner/repo\") and collection key (\"owner/repo/plugin\")\n- Unit test getSourceDirFromKey with both key formats\n- Existing command tests should pass without modification","parent":"tick-9b3876","created":"2026-02-20T13:15:07Z","updated":"2026-02-20T14:40:50Z","closed":"2026-02-20T14:40:50Z"}
{"id":"tick-ed706d","title":"cs-6-11: Add filesystem-based integration tests for core workflows","status":"done","priority":2,"description":"**Problem**: All command-level tests mock every dependency, verifying orchestration in isolation. There are no tests exercising real interaction between modules (e.g., computeIncomingFiles -\u003e checkFileCollisions -\u003e copyPluginAssets -\u003e writeManifest). Seam defects like path-format mismatches between modules would go undetected.\n\n**Solution**: Add a small set of filesystem-based integration tests that exercise the add/update/remove pipelines end-to-end against temp directories. Mock only interactive prompts (clack) and git operations (network). Use real file operations.\n\n**Outcome**: Cross-module path format consistency is validated. Seam defects between compute, check, copy, and manifest modules are caught.\n\n**Do**:\n1. Create tests/integration/ directory\n2. Create test helper that sets up a temp directory with a fake project structure and a fake plugin source directory\n3. Write integration test: bare skill add -- real computeIncomingFiles, real copyBareSkill, real writeManifest, verify files on disk match manifest\n4. Write integration test: plugin add with collision -- real file operations, verify collision detection works with actual file paths\n5. Write integration test: update with agent drop -- add a plugin, modify the source agntc.json to drop an agent, update, verify correct files removed/kept\n6. Write integration test: remove -- add a plugin, remove it, verify files deleted and manifest cleaned\n7. Mock only: clack prompts (return predetermined selections), git clone (copy from local fixture instead)\n8. Clean up temp directories in afterEach\n\n**Acceptance Criteria**:\n- At least 4 integration tests covering add (bare skill), add (plugin with collision), update, and remove\n- Tests use real filesystem operations against temp directories\n- Tests verify both file-on-disk state and manifest state\n- Tests run in the existing test suite (vitest)\n\n**Tests**:\n- The integration tests themselves are the deliverable","parent":"tick-9b3876","created":"2026-02-20T13:15:20Z","updated":"2026-02-20T14:46:02Z","closed":"2026-02-20T14:46:02Z"}
{"id":"tick-d00910","title":"Phase 7: Analysis (Cycle 2)","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-20T15:31:28Z","updated":"2026-02-20T15:31:28Z"}
{"id":"tick-b51c55","title":"cs-7-1: Extract shared clone-and-reinstall orchestration","status":"done","priority":2,"description":"**Problem**: The clone-then-nuke-and-reinstall-then-handle-result orchestration is duplicated across 5 call sites in update.ts (runGitUpdate, runLocalUpdate, processGitUpdateForAll, processLocalUpdateForAll), list-update-action.ts (runRemoteUpdate, runLocalUpdate), and list-change-version-action.ts (executeChangeVersionAction). Each site repeats ~60-80 lines of the same structure: buildParsedSourceFromKey, spinner start, cloneSource with try/catch, getSourceDirFromKey, executeNukeAndReinstall with onAgentsDropped callback, 4-way if-chain for NukeReinstallResult statuses, write manifest, cleanupTempDir in finally. The onAgentsDropped warning message is also duplicated verbatim 5 times. Any behavioral change to the pipeline (e.g. adding a new result variant) requires updating all sites.\n\n**Solution**: Extract a shared `cloneAndReinstall` function that encapsulates: (1) buildParsedSourceFromKey, (2) cloneSource with spinner, (3) getSourceDirFromKey, (4) executeNukeAndReinstall with a standard onAgentsDropped handler, (5) NukeReinstallResult status mapping to a discriminated success/failure union, (6) cleanupTempDir in finally. Each call site then maps the shared result to its own return type (ExitSignal for single update, PluginOutcome for batch, UpdateActionResult/ChangeVersionResult for list actions). Place in `src/clone-reinstall.ts` or extend `nuke-reinstall-pipeline.ts`.\n\n**Outcome**: The clone-pipeline-outcome orchestration exists in one place. Adding a new NukeReinstallResult variant requires changes in one location. The agents-dropped warning template is defined once. Each consumer is a thin mapper (~5-10 lines) over the shared result.\n\n**Do**:\n1. Create `src/clone-reinstall.ts` with a `cloneAndReinstall` function that accepts: key, entry, projectDir, optional newRef/newCommit, and returns a discriminated union of `{ status: 'success', manifestEntry: ManifestEntry, copiedFiles: string[], droppedAgents: string[] }` or `{ status: 'failed', message: string }`.\n2. Move the onAgentsDropped warning template into this module as a helper (e.g., `formatAgentsDroppedWarning`).\n3. Encapsulate the full sequence: build parsed source, clone (with spinner), get source dir, execute nuke-and-reinstall, map result statuses, cleanup temp dir in finally.\n4. Refactor `runGitUpdate` and `processGitUpdateForAll` in update.ts to call `cloneAndReinstall` and map the result to their existing return types.\n5. Refactor `runLocalUpdate` and `processLocalUpdateForAll` in update.ts similarly (local path variant skips clone, uses path directly).\n6. Refactor `runRemoteUpdate` and `runLocalUpdate` in list-update-action.ts to use `cloneAndReinstall`.\n7. Refactor `executeChangeVersionAction` in list-change-version-action.ts to use `cloneAndReinstall`.\n8. Remove the now-unused duplicated code from all call sites.\n9. Verify all existing tests pass without modification.\n\n**Acceptance Criteria**:\n- The 4-way NukeReinstallResult status handling exists in exactly one location\n- The onAgentsDropped warning message template exists in exactly one location\n- All update/list-update/list-change-version flows produce identical user-visible output as before\n- No call site directly imports or calls cloneSource + executeNukeAndReinstall + cleanupTempDir individually for the update pipeline\n\n**Tests**:\n- Existing update command tests pass (single git update, single local update, batch update all)\n- Existing list-update-action tests pass (remote update, local update)\n- Existing list-change-version-action tests pass\n- Each NukeReinstallResult status (no-config, no-agents, invalid-type, copy-failed, success) produces the same error messages/behavior as before","parent":"tick-d00910","created":"2026-02-20T15:31:56Z","updated":"2026-02-20T15:41:36Z","closed":"2026-02-20T15:41:36Z"}
{"id":"tick-dc4981","title":"cs-7-2: Centralize clone URL derivation and add cloneUrl to GitHubShorthandSource","status":"done","priority":2,"description":"**Problem**: Clone URL derivation is implemented independently in three places: `commands/add.ts:33-40` (handles all ParsedSource variants), `update-check.ts:12-17` (constructs `https://github.com/{owner}/{repo}.git` from a manifest key), and `git-clone.ts:29-37` (resolveCloneUrl). The `GitHubShorthandSource` type lacks a `cloneUrl` field, unlike all other git-based ParsedSource variants, forcing every consumer to special-case it with `https://github.com/${owner}/${repo}.git` construction.\n\n**Solution**: (1) Add `cloneUrl: string` to `GitHubShorthandSource` in source-parser.ts, computed as `https://github.com/${owner}/${repo}.git` during parsing. (2) Centralize clone URL resolution into source-parser.ts with two functions: `resolveCloneUrl(parsed: ParsedSource): string` for ParsedSource-based resolution, and `deriveCloneUrlFromKey(key: string, cloneUrl: string | null): string` for manifest-key-based resolution. (3) Remove the independent implementations in add.ts, update-check.ts, and git-clone.ts.\n\n**Outcome**: Clone URL derivation logic exists in one module. All git-based ParsedSource variants carry a `cloneUrl` field, eliminating special-case branches. If the fallback URL template changes, only one location needs updating.\n\n**Do**:\n1. In `src/source-parser.ts`, add `cloneUrl: string` to the `GitHubShorthandSource` interface.\n2. In the parsing function that creates `GitHubShorthandSource`, compute and set `cloneUrl: \\`https://github.com/${owner}/${repo}.git\\``.\n3. Add a `resolveCloneUrl(parsed: ParsedSource): string` function in source-parser.ts that returns `parsed.cloneUrl` for all git-based variants (now including github-shorthand) and throws for local-path.\n4. Add a `deriveCloneUrlFromKey(key: string, cloneUrl: string | null): string` function in source-parser.ts that returns `cloneUrl` if non-null, otherwise constructs from key as `https://github.com/${key}.git`.\n5. Replace `deriveCloneUrl` in `commands/add.ts` with the centralized function.\n6. Replace `deriveCloneUrl` in `update-check.ts` with `deriveCloneUrlFromKey`.\n7. Replace `resolveCloneUrl` in `git-clone.ts` with the centralized function (or import it).\n8. Remove the now-unused local implementations.\n\n**Acceptance Criteria**:\n- No file outside source-parser.ts contains clone URL construction logic (no `https://github.com/` template strings)\n- All ParsedSource git-based variants have a `cloneUrl` field\n- All existing tests pass\n\n**Tests**:\n- Source parser tests verify GitHubShorthandSource now includes correct cloneUrl\n- Add command tests pass with centralized URL derivation\n- Update check tests pass with centralized URL derivation\n- Git clone tests pass with centralized URL resolution","parent":"tick-d00910","created":"2026-02-20T15:32:14Z","updated":"2026-02-20T15:49:51Z","closed":"2026-02-20T15:49:51Z"}
{"id":"tick-b999e1","title":"cs-7-3: Fix collection add to enforce per-plugin agent compatibility warnings","status":"done","priority":2,"description":"**Problem**: The collection add flow unions all declared agents across all selected plugins and passes that union to a single `selectAgents` call. This means if plugin A declares `[\"claude\"]` and plugin B declares `[\"codex\"]`, both agents appear without any unsupported warning. The resulting selected agents are applied uniformly to ALL plugins -- plugin A gets installed for codex (which it never declared) and plugin B gets installed for claude (which it never declared). The spec states: \"No inheritance -- every installable unit declares its own `agents`, even within collections\" and \"Agents not listed in the plugin's `agents` field are still shown in the multiselect but display a warning.\"\n\n**Solution**: During the copy phase for collections, filter each plugin's agents to only include what the user selected AND emit a warning for any selected agent not in that plugin's declared agents list. This preserves the current single-prompt UX while aligning with spec intent. Specifically: after agent multiselect, for each plugin, compute `effectiveAgents = selectedAgents intersect plugin.agents` and `unsupportedSelected = selectedAgents - plugin.agents`. If unsupportedSelected is non-empty, show a warning per the spec. Install each plugin only for its effective agents plus any unsupported agents the user explicitly selected (with the warning shown).\n\n**Outcome**: Each plugin in a collection is installed respecting its own agent declarations. Users see per-plugin warnings when a selected agent is not declared by that plugin.\n\n**Do**:\n1. In `src/commands/add.ts`, locate the collection add flow (around line 319-365).\n2. After the agent multiselect, iterate over each selected plugin.\n3. For each plugin, compare the selected agents against that plugin's `agents` field from its `agntc.json`.\n4. For agents selected but not declared by the plugin, emit a warning: \"Plugin {plugin-name} does not declare support for {agent}. Installing at your own risk.\"\n5. Install each plugin for ALL selected agents (matching the spec's \"warn, never block\" approach), but with the warning displayed.\n6. Update the agent multiselect to show unsupported warnings based on per-plugin declarations rather than the union.\n\n**Acceptance Criteria**:\n- When adding a collection, each plugin shows unsupported-agent warnings based on its own `agents` field, not the union\n- The user can still select any agent for any plugin (warn, never block)\n- Each plugin's manifest entry `agents` field reflects what was actually installed for that plugin\n\n**Tests**:\n- Collection with plugin A (claude-only) and plugin B (codex-only): selecting both agents shows unsupported warnings for each plugin\n- Collection where all plugins declare the same agents: no warnings shown\n- Single-plugin (non-collection) flow remains unchanged","parent":"tick-d00910","created":"2026-02-20T15:32:34Z","updated":"2026-02-20T15:55:54Z","closed":"2026-02-20T15:55:54Z"}
{"id":"tick-56138f","title":"cs-7-4: Extract shared readDirEntries utility","status":"done","priority":2,"description":"**Problem**: `readSourceAssetDir` in `src/compute-incoming-files.ts:88-95` and `readTopEntries` in `src/copy-plugin-assets.ts:90-97` are near-identical functions. Both read a directory and map entries to `{name: string, isDirectory: boolean}` objects. The interfaces `SourceEntry` and `DirEntry` are structurally identical. Both handle errors by returning an empty array.\n\n**Solution**: Extract a shared `readDirEntries` function into `src/fs-utils.ts` with a single `DirEntry` interface. Both `compute-incoming-files.ts` and `copy-plugin-assets.ts` import from it.\n\n**Outcome**: Directory entry reading logic exists in one place with one interface definition. Both consumers share the same implementation and error handling.\n\n**Do**:\n1. Create `src/fs-utils.ts` (or add to an existing utility module if one exists).\n2. Define `export interface DirEntry { name: string; isDirectory: boolean }`.\n3. Export `readDirEntries(dirPath: string): Promise\u003cDirEntry[]\u003e` that reads the directory with `withFileTypes`, maps to `DirEntry`, and returns `[]` on error.\n4. In `src/compute-incoming-files.ts`, replace `readSourceAssetDir` and `SourceEntry` with imports from fs-utils.ts.\n5. In `src/copy-plugin-assets.ts`, replace `readTopEntries` and `DirEntry` with imports from fs-utils.ts.\n6. Remove the now-unused local implementations and interfaces.\n\n**Acceptance Criteria**:\n- `readSourceAssetDir` and `readTopEntries` no longer exist as separate functions\n- Both modules import and use the shared `readDirEntries` from fs-utils.ts\n- Only one `DirEntry` interface definition exists\n\n**Tests**:\n- Existing tests for compute-incoming-files pass\n- Existing tests for copy-plugin-assets pass\n- readDirEntries returns empty array for non-existent directory\n- readDirEntries correctly maps entries with name and isDirectory","parent":"tick-d00910","created":"2026-02-20T15:32:46Z","updated":"2026-02-20T15:59:56Z","closed":"2026-02-20T15:59:56Z"}
{"id":"tick-e6bbde","title":"cs-7-5: Consolidate findDroppedAgents as complement of computeEffectiveAgents","status":"done","priority":2,"description":"**Problem**: `computeEffectiveAgents` in `src/agent-compat.ts` returns `entryAgents.filter(a =\u003e newSet.has(a))` and `findDroppedAgents` returns `entryAgents.filter(a =\u003e \\!newSet.has(a))`. These are logical inverses computed independently. If the effective-agents logic becomes more nuanced, the dropped-agents logic must be updated in lockstep or they will drift. Both are called together in `nuke-reinstall-pipeline.ts` lines 80-87.\n\n**Solution**: Replace the two independent functions with a single function that returns both results: `computeAgentChanges(entryAgents: string[], newConfigAgents: string[]): { effective: string[], dropped: string[] }`. Derive dropped as `entryAgents.filter(a =\u003e \\!effective.includes(a))` so it is always the complement of effective. Alternatively, keep `computeEffectiveAgents` as the primary and derive dropped at the call site.\n\n**Outcome**: Dropped agents are always the exact complement of effective agents by construction, not by independent implementation. The logic cannot drift.\n\n**Do**:\n1. In `src/agent-compat.ts`, replace both functions with a single `computeAgentChanges(entryAgents: string[], newConfigAgents: string[]): { effective: string[], dropped: string[] }`.\n2. Compute `effective` using the existing logic.\n3. Derive `dropped` as `entryAgents.filter(a =\u003e \\!effective.includes(a))`.\n4. Update `src/nuke-reinstall-pipeline.ts` (lines 80-87) to destructure the single call: `const { effective, dropped } = computeAgentChanges(...)`.\n5. Update any other callers of `computeEffectiveAgents` or `findDroppedAgents`.\n6. Remove the old individual exports.\n\n**Acceptance Criteria**:\n- `findDroppedAgents` no longer exists as a standalone function\n- Dropped agents are derived from effective agents, not computed independently\n- All callers updated to use the new unified function\n\n**Tests**:\n- Existing agent-compat tests pass (adapted to new function signature)\n- nuke-reinstall-pipeline tests pass with identical behavior\n- When effective agents change, dropped agents are always the exact complement","parent":"tick-d00910","created":"2026-02-20T15:33:00Z","updated":"2026-02-20T16:03:37Z","closed":"2026-02-20T16:03:37Z"}
{"id":"tick-72799f","title":"cs-7-6: Align summary output format with spec","status":"done","priority":2,"description":"**Problem**: The spec defines the add summary format as multi-line with per-agent blocks on separate indented lines (e.g., \"Claude:\\n    12 skills, 3 agents, 2 hooks\"). The implementation in `src/summary.ts:63-71` produces a compact single-line format: \"Installed owner/repo@ref -- claude: 2 skill(s)\". Agent names use lowercase where the spec uses capitalized (\"Claude\" vs \"claude\").\n\n**Solution**: Update the summary formatting in `src/summary.ts` to produce multi-line per-agent output with capitalized agent names matching the spec example. Only show asset types that were actually installed (no \"0 hooks\" lines).\n\n**Outcome**: Summary output matches the spec format: multi-line, per-agent blocks with indentation, capitalized agent names, only non-zero asset types shown.\n\n**Do**:\n1. In `src/summary.ts`, locate the summary formatting logic (around line 63-71).\n2. Change the output to use multi-line format per the spec:\n   Installed owner/repo@ref\n\n     Claude:\n       12 skills, 3 agents, 2 hooks\n\n     Codex:\n       12 skills\n3. Capitalize agent names in output (e.g., \"Claude\" not \"claude\", \"Codex\" not \"codex\").\n4. Only include asset types with non-zero counts.\n5. For collections, repeat per plugin.\n\n**Acceptance Criteria**:\n- Summary output uses multi-line per-agent format matching spec example\n- Agent names are capitalized in output\n- Zero-count asset types are omitted\n- Collection installs show per-plugin summaries\n\n**Tests**:\n- Summary for single-agent install shows correct multi-line format\n- Summary for multi-agent install shows separate blocks per agent\n- Summary omits \"0 hooks\" or similar zero-count lines\n- Agent names appear capitalized in output","parent":"tick-d00910","created":"2026-02-20T15:33:13Z","updated":"2026-02-20T16:10:29Z","closed":"2026-02-20T16:10:29Z"}
{"id":"tick-64fe90","title":"Phase 8: Analysis (Cycle 3)","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-20T16:43:03Z","updated":"2026-02-20T16:43:03Z"}
{"id":"tick-e16f38","title":"cs-8-1: Extract failure-reason mapper and unify update orchestration functions","status":"done","priority":2,"description":"**Problem**: Every consumer of cloneAndReinstall() independently dispatches on result.failureReason with an if-chain checking \"clone-failed\", \"no-config\", \"no-agents\", \"invalid-type\", \"copy-failed\", and a fallback. This chain is ~30 lines and appears 6 times across src/commands/update.ts (runGitUpdate:112-141, runLocalUpdate:192-219, processGitUpdateForAll:253-291, processLocalUpdateForAll:340-377), src/commands/list-update-action.ts (runRemoteUpdate:37-68, runLocalUpdate:112-142), and src/commands/list-change-version-action.ts (53-84). Additionally, update.ts has four near-identical functions (runGitUpdate, runLocalUpdate, processGitUpdateForAll, processLocalUpdateForAll) that differ only in how they surface outcomes (throw ExitSignal vs return PluginOutcome) and whether they validate local paths. Adding a new failure reason requires updating all 6 sites. This was flagged in c2 but remains unaddressed at the consumer level.\n\n**Solution**: Define a generic mapCloneFailure\u003cT\u003e function in src/clone-reinstall.ts that accepts a CloneReinstallFailed result and a handler record with one callback per failure reason, returning T. Each call site provides its thin handler record (e.g., messages and return-type wrappers). Additionally, unify the four update functions in update.ts into a single processUpdate function that returns PluginOutcome, with the single-plugin path (runUpdate with a key) calling it and mapping PluginOutcome to throws/logs. The git vs local distinction is already handled inside cloneAndReinstall via the sourceDir parameter.\n\n**Outcome**: The failure-reason dispatch exists in one location. Adding a new failure reason requires changes in one place and produces a compile error if any handler is missing. Each consumer is reduced from ~30 lines of if-chains to ~5-10 lines of handler definitions. The four update functions in update.ts are reduced to one or two.\n\n**Do**:\n1. In src/clone-reinstall.ts, define a handler interface: CloneFailureHandlers\u003cT\u003e = { onCloneFailed: (msg: string) =\u003e T, onNoConfig: (msg: string) =\u003e T, onNoAgents: (msg: string) =\u003e T, onInvalidType: (msg: string) =\u003e T, onCopyFailed: (msg: string) =\u003e T, onUnknown: (msg: string) =\u003e T }.\n2. Export mapCloneFailure\u003cT\u003e(result: CloneReinstallFailed, handlers: CloneFailureHandlers\u003cT\u003e): T that dispatches to the appropriate handler based on result.failureReason.\n3. In src/commands/update.ts, replace the if-chains in runGitUpdate and runLocalUpdate with calls to mapCloneFailure providing handlers that throw ExitSignal or return null as appropriate.\n4. In src/commands/update.ts, replace processGitUpdateForAll and processLocalUpdateForAll with a single processUpdateForAll(key, entry, projectDir) function that calls cloneAndReinstall (with sourceDir for local paths) and uses mapCloneFailure to return PluginOutcome. Keep the local-path validation inline for the batch path.\n5. In src/commands/list-update-action.ts, replace the if-chains in runRemoteUpdate and runLocalUpdate with calls to mapCloneFailure providing handlers that return UpdateActionResult.\n6. In src/commands/list-change-version-action.ts, replace the if-chain with a call to mapCloneFailure providing handlers that return ChangeVersionResult.\n7. Remove all now-unused duplicated if-chain code.\n8. Verify all existing tests pass without modification.\n\n**Acceptance Criteria**:\n- The failure-reason if-chain exists in exactly one location (the mapCloneFailure function)\n- All consumers use mapCloneFailure with typed handler records\n- All update/list-update/list-change-version flows produce identical user-visible output as before\n- update.ts has at most 2 update orchestration functions (single + batch), down from 4\n\n**Tests**:\n- Existing update command tests pass (single git update, single local update, batch update all)\n- Existing list-update-action tests pass (remote update, local update)\n- Existing list-change-version-action tests pass\n- Each failure reason (no-config, no-agents, invalid-type, copy-failed, clone-failed, unknown) produces the same error messages/behavior as before","parent":"tick-64fe90","created":"2026-02-20T16:43:37Z","updated":"2026-02-20T16:54:08Z","closed":"2026-02-20T16:54:08Z"}
{"id":"tick-90df13","title":"cs-8-2: Extract local path validation helper","status":"done","priority":2,"description":"**Problem**: The pattern of calling stat(sourcePath), checking isDirectory(), and producing a \"does not exist or is not a directory\" error is repeated in 3 places: src/commands/update.ts:158-174 (validateLocalPath), src/commands/update.ts:316-331 (inline in processLocalUpdateForAll), and src/commands/list-update-action.ts:90-103 (inline in runLocalUpdate). Each is ~15 lines with identical structure. The update.ts version throws ExitSignal while the other two return error results, but the core validation logic is the same.\n\n**Solution**: Extract a validateLocalSourcePath(path: string): Promise\u003c{ valid: true } | { valid: false; reason: string }\u003e helper into src/fs-utils.ts (or extend an existing utility module). The function performs the stat + isDirectory check and returns a result type. Each call site maps the result to its own error handling (throw or return).\n\n**Outcome**: Local path validation logic exists in one place. The 3 call sites become thin wrappers that map the validation result to their context-specific error handling.\n\n**Do**:\n1. Create or extend src/fs-utils.ts with validateLocalSourcePath(path: string): Promise\u003c{ valid: true } | { valid: false; reason: string }\u003e.\n2. Implement: call stat(path), check isDirectory(). Return { valid: false, reason: \"path is not a directory\" } if not a directory, { valid: false, reason: \"path does not exist\" } if stat throws.\n3. In src/commands/update.ts, replace validateLocalPath (lines 158-174) to call validateLocalSourcePath and throw ExitSignal on invalid.\n4. In src/commands/update.ts, replace inline validation in processLocalUpdateForAll (lines 316-331) to call validateLocalSourcePath and return PluginOutcome on invalid.\n5. In src/commands/list-update-action.ts, replace inline validation in runLocalUpdate (lines 90-103) to call validateLocalSourcePath and return UpdateActionResult on invalid.\n6. Remove now-unused inline validation code.\n\n**Acceptance Criteria**:\n- Local path stat+isDirectory validation exists in exactly one function\n- All 3 call sites use the shared function\n- Error messages remain consistent with current behavior\n\n**Tests**:\n- Existing update tests pass for local path validation failures\n- Existing list-update-action tests pass for local path validation failures\n- validateLocalSourcePath returns valid:true for existing directories\n- validateLocalSourcePath returns valid:false for non-existent paths\n- validateLocalSourcePath returns valid:false for file paths (not directories)","parent":"tick-64fe90","created":"2026-02-20T16:43:52Z","updated":"2026-02-20T16:59:11Z","closed":"2026-02-20T16:59:11Z"}
{"id":"tick-902b4f","title":"cs-8-3: Extract readManifestOrExit helper","status":"done","priority":2,"description":"**Problem**: Three commands read the manifest with an identical .catch() block that extracts the error message, logs it via p.log.error, and throws ExitSignal(1). This 5-line pattern appears in src/commands/update.ts:34-38, src/commands/list.ts:76-80, and src/commands/remove.ts:72-76. The structure is identical each time.\n\n**Solution**: Extract a readManifestOrExit(projectDir: string): Promise\u003cManifest\u003e helper that encapsulates the .catch() + ExitSignal pattern. Place in src/manifest.ts alongside the existing readManifest.\n\n**Outcome**: Manifest-read-with-error-handling exists in one place. Each command calls readManifestOrExit instead of duplicating the catch block.\n\n**Do**:\n1. In src/manifest.ts, add readManifestOrExit(projectDir: string): Promise\u003cManifest\u003e that calls readManifest(projectDir) and catches errors with the standard pattern: extract message, p.log.error(\"Failed to read manifest: {message}\"), throw ExitSignal(1).\n2. In src/commands/update.ts, replace lines 34-38 with const manifest = await readManifestOrExit(projectDir).\n3. In src/commands/list.ts, replace the equivalent catch block with readManifestOrExit.\n4. In src/commands/remove.ts, replace the equivalent catch block with readManifestOrExit.\n5. Update imports in all three files.\n\n**Acceptance Criteria**:\n- No command file contains a .catch() block that logs manifest read errors and throws ExitSignal\n- All three commands use readManifestOrExit\n- Error messages remain identical to current behavior\n\n**Tests**:\n- Existing tests for update, list, and remove pass with manifest read errors\n- readManifestOrExit throws ExitSignal(1) when manifest cannot be read","parent":"tick-64fe90","created":"2026-02-20T16:44:01Z","updated":"2026-02-20T17:13:10Z","closed":"2026-02-20T17:13:10Z"}
{"id":"tick-99a33c","title":"cs-8-4: Extract errorMessage utility function","status":"done","priority":2,"description":"**Problem**: The expression err instanceof Error ? err.message : String(err) appears 13 times across the codebase: src/clone-reinstall.ts:88, src/config.ts:43, src/commands/update.ts:35,391,404, src/commands/list.ts:77, src/commands/list-update-action.ts:154, src/commands/add.ts:251,513, src/commands/remove.ts:73, src/nuke-reinstall-pipeline.ts:128, src/copy-rollback.ts:15, src/update-check-all.ts:20. Each is a single expression but the sheer repetition indicates a missing utility.\n\n**Solution**: Extract function errorMessage(err: unknown): string into src/errors.ts (alongside the existing isNodeError if present, or as a new file). Replace all 13 occurrences.\n\n**Outcome**: Error message extraction is a single utility function. All catch blocks use it consistently.\n\n**Do**:\n1. Create or extend src/errors.ts with export function errorMessage(err: unknown): string { return err instanceof Error ? err.message : String(err); }.\n2. Replace all 13 occurrences of err instanceof Error ? err.message : String(err) with errorMessage(err).\n3. Add the import to each affected file.\n\n**Acceptance Criteria**:\n- No file contains the inline err instanceof Error ? err.message : String(err) expression\n- All 13 sites use the shared errorMessage function\n- No behavioral change\n\n**Tests**:\n- All existing tests pass\n- errorMessage returns the message property for Error instances\n- errorMessage returns String(err) for non-Error values","parent":"tick-64fe90","created":"2026-02-20T16:44:09Z","updated":"2026-02-20T17:18:14Z","closed":"2026-02-20T17:18:14Z"}
{"id":"tick-a36a34","title":"cs-8-5: Narrow tree URL @ref rejection to path portion only","status":"done","priority":2,"description":"**Problem**: parseDirectPath in src/source-parser.ts:134-137 rejects any tree URL containing @ anywhere in the string (if (input.includes(\"@\"))). This would incorrectly reject legitimate URLs containing @ in non-ref positions, such as https://user@github.com/owner/repo/tree/main/plugin (authenticated URLs). The spec intent is to reject @ref suffixes appended after the URL, not @ characters within the URL structure.\n\n**Solution**: Narrow the check to only reject @ after the hostname/path portion. Since tree URLs have the structure https://{host}/{owner}/{repo}/tree/{ref}/{plugin}, check whether @ appears after the /tree/ segment or as a suffix to the overall URL, rather than anywhere in the string.\n\n**Outcome**: Tree URLs with @ in the authentication portion or hostname are accepted. Only @ref suffixes meant for version pinning are rejected, matching spec intent.\n\n**Do**:\n1. In src/source-parser.ts, locate parseDirectPath (line 133).\n2. Replace if (input.includes(\"@\")) with a check that only examines the portion after the hostname. For example: extract the path after https://{host}/ and check if that path portion contains @.\n3. Alternatively, check if @ appears after the last /tree/... segment, which would be the suffix position.\n4. Ensure the existing test for @ref rejection on tree URLs still passes.\n\n**Acceptance Criteria**:\n- https://github.com/owner/repo/tree/main/plugin is accepted (no @)\n- https://github.com/owner/repo/tree/main/plugin@v2 is rejected (@ as ref suffix in path)\n- https://user@github.com/owner/repo/tree/main/plugin would not be rejected by the @ check (@ is in auth portion)\n- Existing source-parser tests pass\n\n**Tests**:\n- Existing tree URL parsing tests pass\n- Tree URL with @ref suffix after path is still rejected\n- Standard tree URLs without @ continue to parse correctly","parent":"tick-64fe90","created":"2026-02-20T16:44:21Z","updated":"2026-02-20T17:40:04Z","closed":"2026-02-20T17:40:04Z"}
{"id":"tick-f05a59","title":"Phase 9: Analysis (Cycle 4)","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-20T18:40:10Z","updated":"2026-02-20T18:40:10Z"}
{"id":"tick-6c1630","title":"Unify runRemoteUpdate and runLocalUpdate in list-update-action.ts and internalize copy-failed manifest removal","status":"done","priority":2,"description":"**Problem**: `runRemoteUpdate` (lines 26-79) and `runLocalUpdate` (lines 81-149) in `src/commands/list-update-action.ts` are structurally identical. Both call `cloneAndReinstall`, check for copy-failed and remove the manifest entry, then call `mapCloneFailure` with near-identical handler records (~25 lines duplicated within the same file). The only differences are: (1) `runLocalUpdate` adds a `validateLocalSourcePath` guard and passes `sourceDir`, and (2) two of six message strings differ slightly (\"has no agntc.json\" vs \"New version of ... has no agntc.json\"). Additionally, the copy-failed manifest removal check (`result.failureReason === \"copy-failed\"` then `writeManifest(projectDir, removeEntry(manifest, key))`) is a 3-line block repeated at 4 call sites across 3 files -- this is a pipeline concern that leaks into every consumer of `cloneAndReinstall`.\n\n**Solution**: (1) Unify `runRemoteUpdate` and `runLocalUpdate` into a single `runUpdate(key, entry, manifest, projectDir)` function that determines local vs remote mode from `entry.commit === null`. Parameterize the two differing message strings via a local flag. (2) Move the copy-failed manifest removal into `cloneAndReinstall` itself (it already has access to key and projectDir), or into the `mapCloneFailure` `onCopyFailed` handler defined once in the shared function, eliminating the check from all 4 external call sites.\n\n**Outcome**: list-update-action.ts has one update function instead of two. The copy-failed manifest cleanup is handled in one location rather than repeated at every call site. ~50 lines eliminated from list-update-action.ts and ~9 lines from other files.\n\n**Do**:\n1. In `src/commands/list-update-action.ts`, create a single `runUpdate(key: string, entry: ManifestEntry, manifest: Manifest, projectDir: string): Promise\u003cUpdateActionResult\u003e` function.\n2. Inside `runUpdate`, check `entry.commit === null` to determine local vs remote mode. For local mode, call `validateLocalSourcePath` first and return early on failure. For remote mode, proceed directly.\n3. Call `cloneAndReinstall` with the appropriate parameters (sourceDir for local, ref/commit for remote).\n4. Extract a single `mapCloneFailure` handler record that parameterizes the two message-string differences based on a `isLocal` flag.\n5. In `src/clone-reinstall.ts` (or wherever `cloneAndReinstall` is defined), move the copy-failed manifest removal logic into the function itself, so consumers do not need to check for copy-failed and call `writeManifest(removeEntry(...))` independently.\n6. Remove the copy-failed manifest removal checks from `src/commands/update.ts`, `src/commands/list-update-action.ts`, and `src/commands/list-change-version-action.ts` (all 4 external sites).\n7. Remove the now-unused `runRemoteUpdate` and `runLocalUpdate` functions.\n8. Update all call sites that invoked `runRemoteUpdate` or `runLocalUpdate` to call the unified `runUpdate`.\n9. Verify all existing tests pass.\n\n**Acceptance Criteria**:\n- `runRemoteUpdate` and `runLocalUpdate` no longer exist as separate functions in list-update-action.ts\n- A single `runUpdate` function handles both local and remote update flows\n- The copy-failed manifest removal check does not appear at any external call site of `cloneAndReinstall`\n- All existing list-update-action tests pass with identical behavior\n- All existing update and list-change-version-action tests pass\n\n**Tests**:\n- Existing list-update-action tests for remote updates pass\n- Existing list-update-action tests for local updates pass\n- Existing update command tests pass (copy-failed handling still works)\n- Existing list-change-version-action tests pass\n- Copy-failed scenario correctly removes the manifest entry (verified via existing or updated tests)","parent":"tick-f05a59","created":"2026-02-20T18:40:37Z","updated":"2026-02-20T18:50:22Z","closed":"2026-02-20T18:50:22Z"}
{"id":"tick-75db2e","title":"Extract shared conflict-check pipeline in add.ts","status":"done","priority":2,"description":"**Problem**: The standalone add path (lines ~151-187) and the collection per-plugin loop (lines ~428-470) in `src/commands/add.ts` both implement the same 6-step sequence: computeIncomingFiles, checkFileCollisions, resolveCollisions (with manifest update), checkUnmanagedConflicts, resolveUnmanagedConflicts (with skip handling). Each is ~35 lines. The collection version wraps the cancel path in a `continue` instead of a `throw`, but the core pipeline is identical.\n\n**Solution**: Extract a shared function like `runConflictChecks({ incomingFiles, manifest, pluginKey, projectDir }): Promise\u003c{ updatedManifest: Manifest, proceed: boolean }\u003e` that encapsulates the full collision and unmanaged-conflict pipeline. The standalone path throws on `\\!proceed`, the collection path continues.\n\n**Outcome**: The 6-step conflict pipeline exists in one place. Any change to the collision/unmanaged resolution flow is made once. ~35 lines of duplication eliminated.\n\n**Do**:\n1. In `src/commands/add.ts`, define a function `runConflictChecks(opts: { incomingFiles: string[], manifest: Manifest, pluginKey: string, projectDir: string }): Promise\u003c{ updatedManifest: Manifest, proceed: boolean }\u003e`.\n2. Move the 6-step sequence into this function: computeIncomingFiles, checkFileCollisions, resolveCollisions, checkUnmanagedConflicts, resolveUnmanagedConflicts, return updated manifest and whether to proceed.\n3. In the standalone add path, call `runConflictChecks` and throw on `\\!proceed`.\n4. In the collection per-plugin loop, call `runConflictChecks` and `continue` on `\\!proceed`.\n5. Ensure both paths pass the correct parameters and handle the result appropriately.\n6. Verify all existing tests pass.\n\n**Acceptance Criteria**:\n- The collision-check + unmanaged-check sequence exists in exactly one function\n- Both the standalone and collection add paths use the shared function\n- Cancel behavior is preserved: standalone throws, collection continues to next plugin\n- All existing add command tests pass\n\n**Tests**:\n- Existing add tests for collision detection and resolution pass\n- Existing add tests for unmanaged conflict detection pass\n- Existing collection add tests pass\n- Cancel during standalone add still aborts the command\n- Cancel during collection add still skips to the next plugin","parent":"tick-f05a59","created":"2026-02-20T18:40:49Z","updated":"2026-02-20T18:58:12Z","closed":"2026-02-20T18:58:12Z"}
{"id":"tick-cfe67a","title":"Extract withExitSignal wrapper for command actions","status":"done","priority":2,"description":"**Problem**: All four commands (add, remove, update, list) wrap their `.action()` handler in an identical try/catch block that checks for ExitSignal and calls `process.exit(signal.code)`. The block is 7 lines, repeated 4 times with zero variation across `src/commands/add.ts:558-567`, `src/commands/remove.ts:161-170`, `src/commands/update.ts:461-470`, and `src/commands/list.ts:151-160`.\n\n**Solution**: Extract a `withExitSignal(fn: (...args: any[]) =\u003e Promise\u003cvoid\u003e): (...args: any[]) =\u003e Promise\u003cvoid\u003e` wrapper that returns an async function handling the ExitSignal catch pattern. Place in `src/exit-signal.ts` alongside the ExitSignal class definition.\n\n**Outcome**: Each command's `.action()` call becomes a one-liner: `.action(withExitSignal(async (source) =\u003e runAdd(source)))`. The ExitSignal catch boilerplate exists in one place.\n\n**Do**:\n1. In `src/exit-signal.ts` (or wherever ExitSignal is defined), add `export function withExitSignal\u003cT extends (...args: any[]) =\u003e Promise\u003cvoid\u003e\u003e(fn: T): T`.\n2. Implement: return an async function that wraps `fn` in try/catch, checking `if (err instanceof ExitSignal) process.exit(err.code)` and re-throwing otherwise.\n3. In `src/commands/add.ts`, replace the try/catch action wrapper with `withExitSignal(async (source) =\u003e { ... })`.\n4. In `src/commands/remove.ts`, replace the try/catch action wrapper with `withExitSignal(async (key) =\u003e { ... })`.\n5. In `src/commands/update.ts`, replace the try/catch action wrapper with `withExitSignal(async (key) =\u003e { ... })`.\n6. In `src/commands/list.ts`, replace the try/catch action wrapper with `withExitSignal(async () =\u003e { ... })`.\n7. Remove the now-unused try/catch blocks from all four files.\n8. Verify all existing tests pass.\n\n**Acceptance Criteria**:\n- No command file contains an inline try/catch block checking for ExitSignal\n- All four commands use `withExitSignal` to wrap their action handlers\n- ExitSignal handling behavior is identical to current (calls process.exit with the signal's code)\n- All existing tests pass\n\n**Tests**:\n- Existing tests for all four commands pass\n- withExitSignal calls process.exit when ExitSignal is thrown\n- withExitSignal re-throws non-ExitSignal errors","parent":"tick-f05a59","created":"2026-02-20T18:41:02Z","updated":"2026-02-20T19:02:37Z","closed":"2026-02-20T19:02:37Z"}
{"id":"tick-7d400b","title":"Phase 10: Analysis (Cycle 5)","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-20T19:34:02Z","updated":"2026-02-20T19:34:02Z"}
{"id":"tick-5000e1","title":"Derive agent/asset-type classification from driver registry instead of path substrings","status":"done","priority":2,"description":"**Problem**: Two locations reconstruct the agent-to-directory and asset-type-to-directory mapping by pattern-matching on file path strings rather than consulting the driver registry. `list-detail.ts:deriveAgent` hardcodes `.claude/` -\u003e `claude` and `.agents/` -\u003e `codex`. `classifyAssetType` uses `filePath.includes(\"/skills/\")` substring matching. `remove.ts:classifyFile` uses the same substring approach. These are the inverse of the driver's `getTargetDir` configuration but implemented independently via string heuristics. If a driver's target directory changes or a new agent is added, these functions silently produce wrong results. The `includes()` approach is also fragile -- a path like `.claude/skills/my-agents-toolkit/` would match both `/skills/` and `/agents/`.\n\n**Solution**: Add a utility in the driver layer (e.g., `identifyFileOwnership(filePath: string): { agentId: AgentId; assetType: AssetType } | null`) that iterates registered drivers and their `getTargetDir` results to find which agent/asset-type pair owns a given path prefix. Use `startsWith` against actual driver target dirs rather than `includes` against hardcoded substrings. Both `list-detail.ts` and `remove.ts` import this single function.\n\n**Outcome**: Agent and asset-type classification is derived from the single source of truth (driver registry). Adding a new agent or changing a target directory automatically propagates to all classification call sites. The substring false-positive risk is eliminated.\n\n**Do**:\n1. In the driver layer (e.g., `src/drivers/registry.ts` or a new `src/drivers/identify.ts`), add a function `identifyFileOwnership(filePath: string): { agentId: AgentId; assetType: AssetType } | null`.\n2. Implement by iterating all registered drivers, calling `getTargetDir` for each asset type, and checking if `filePath.startsWith(targetDir)`. Return the first match or null.\n3. In `src/commands/list-detail.ts`, replace `deriveAgent` and `classifyAssetType` with calls to `identifyFileOwnership`.\n4. In `src/commands/remove.ts`, replace `classifyFile` logic with a call to `identifyFileOwnership`.\n5. Remove the now-unused hardcoded path-matching functions.\n6. Verify all existing tests pass.\n\n**Acceptance Criteria**:\n- No file outside the driver layer contains hardcoded agent-to-directory or asset-type-to-directory mappings for classification purposes\n- `identifyFileOwnership` is the single function used for reverse-mapping file paths to agent/asset-type\n- Uses `startsWith` against actual driver target dirs, not `includes` against substrings\n- All existing list-detail and remove tests pass\n\n**Tests**:\n- identifyFileOwnership correctly identifies a `.claude/skills/foo` path as { agentId: \"claude\", assetType: \"skills\" }\n- identifyFileOwnership correctly identifies a `.agents/foo.md` path as { agentId: \"codex\", assetType: \"agents\" }\n- identifyFileOwnership returns null for an unrecognized path\n- Existing list-detail tests pass with the new classification approach\n- Existing remove tests pass with the new classification approach","parent":"tick-7d400b","created":"2026-02-20T19:34:24Z","updated":"2026-02-20T19:41:13Z","closed":"2026-02-20T19:41:13Z"}
{"id":"tick-995708","title":"Consolidate mapCloneFailure handler blocks between list-update-action.ts and list-change-version-action.ts","status":"done","priority":2,"description":"**Problem**: Both `list-update-action.ts` and `list-change-version-action.ts` call `mapCloneFailure` with 6 handler callbacks that return a result-object with a boolean flag and message string. The handlers are structurally identical -- the only differences are the field name (`success` vs `changed`) and 2 of the 6 message strings (`onNoConfig` and `onInvalidType` use \"New version of\" in the change-version variant). The remaining 4 handlers (`onNoAgents`, `onCopyFailed`, `onCloneFailed`, `onUnknown`) produce character-for-character identical messages. This is approximately 25 lines duplicated across the two files.\n\n**Solution**: Extract a shared helper that takes a `CloneReinstallFailed` result and a key, and returns a standard `{ message: string }` object. Each call site wraps it in its own return type (`{ success: false, ...msg }` vs `{ changed: false, ...msg }`). Something like `buildFailureMessage(result, key, { isChangeVersion?: boolean })` in `clone-reinstall.ts`. Each call site reduces to 2-3 lines.\n\n**Outcome**: The failure message construction logic exists in one place. The 4 identical handlers are defined once. The 2 differing handlers are parameterized. Each call site is a thin wrapper mapping the shared message to its own result type.\n\n**Do**:\n1. In `src/clone-reinstall.ts`, add a function `buildFailureMessage(result: CloneReinstallFailed, key: string, opts?: { isChangeVersion?: boolean }): string` that dispatches on `result.failureReason` and returns the appropriate message string.\n2. For the 4 identical handlers (onNoAgents, onCopyFailed, onCloneFailed, onUnknown), use the shared message directly.\n3. For the 2 differing handlers (onNoConfig, onInvalidType), branch on `opts.isChangeVersion` to select the appropriate prefix (\"New version of\" vs standard).\n4. In `src/commands/list-update-action.ts`, replace the `mapCloneFailure` call with `buildFailureMessage` and wrap in `{ success: false, message }`.\n5. In `src/commands/list-change-version-action.ts`, replace the `mapCloneFailure` call with `buildFailureMessage` and wrap in `{ changed: false, message }`.\n6. Verify all existing tests pass.\n\n**Acceptance Criteria**:\n- The 6 failure-message handler definitions no longer appear independently in both files\n- A single shared function produces failure messages for both consumers\n- list-update-action.ts and list-change-version-action.ts each have at most 2-3 lines for failure handling\n- All existing tests pass with identical user-visible output\n\n**Tests**:\n- Existing list-update-action tests pass for all failure reasons\n- Existing list-change-version-action tests pass for all failure reasons\n- buildFailureMessage produces correct messages for each failure reason with and without isChangeVersion flag","parent":"tick-7d400b","created":"2026-02-20T19:34:45Z","updated":"2026-02-20T19:46:08Z","closed":"2026-02-20T19:46:08Z"}
{"id":"tick-57e313","title":"Deduplicate formatRef by reusing formatRefLabel from summary.ts","status":"done","priority":2,"description":"**Problem**: `list-detail.ts` defines `formatRef(entry: ManifestEntry)` and `summary.ts` exports `formatRefLabel(ref, commit)`. Both implement the same logic: if ref is non-null return it, if there is a commit return \"HEAD\", otherwise return \"local\". The only difference is the function signature -- one takes a ManifestEntry, the other takes ref and commit as separate parameters.\n\n**Solution**: Remove `formatRef` from `list-detail.ts` and import `formatRefLabel` from `summary.ts` instead. Call it as `formatRefLabel(entry.ref, entry.commit)`.\n\n**Outcome**: One canonical implementation of the ref-label formatting logic. No behavioral change.\n\n**Do**:\n1. In `src/commands/list-detail.ts`, remove the local `formatRef` function (lines 13-17).\n2. Add `import { formatRefLabel } from \"../summary\"` to `list-detail.ts`.\n3. Replace all calls to `formatRef(entry)` with `formatRefLabel(entry.ref, entry.commit)`.\n4. Verify all existing tests pass.\n\n**Acceptance Criteria**:\n- `formatRef` no longer exists in list-detail.ts\n- list-detail.ts imports and uses `formatRefLabel` from summary.ts\n- No behavioral change in list detail output\n\n**Tests**:\n- Existing list-detail tests pass with identical output\n- Existing summary tests pass unchanged","parent":"tick-7d400b","created":"2026-02-20T19:34:55Z","updated":"2026-02-20T19:48:50Z","closed":"2026-02-20T19:48:50Z"}
{"id":"tick-6f7201","title":"Strengthen CollectionPluginResult.detectedType to use concrete DetectedType union","status":"done","priority":2,"description":"**Problem**: `add.ts` defines `PluginInstallResult` with `detectedType?: DetectedType` (the concrete discriminated union from `type-detection.ts`). `summary.ts` defines a near-identical `CollectionPluginResult` interface but declares `detectedType?: { type: string }`. The only consumer of `detectedType` in summary.ts is line 113: `r.detectedType?.type === \"plugin\"`. Using `{ type: string }` means a typo like `\"pluginn\"` would be a valid value at compile time and the comparison would silently return false.\n\n**Solution**: Import `DetectedType` from `type-detection.ts` in `summary.ts` and use it for the `detectedType` field in `CollectionPluginResult`. This aligns the type with `PluginInstallResult` in `add.ts`.\n\n**Outcome**: Compile-time validation catches invalid `detectedType` values. The two interfaces share the same concrete type for this field.\n\n**Do**:\n1. In `src/summary.ts`, add `import { DetectedType } from \"./type-detection\"` (or adjust the import path as needed).\n2. In the `CollectionPluginResult` interface, change `detectedType?: { type: string }` to `detectedType?: DetectedType`.\n3. Verify all existing tests pass.\n\n**Acceptance Criteria**:\n- `CollectionPluginResult.detectedType` uses the concrete `DetectedType` union type, not `{ type: string }`\n- All existing tests pass\n- No behavioral change\n\n**Tests**:\n- Existing summary tests pass unchanged\n- Existing add command tests pass unchanged","parent":"tick-7d400b","created":"2026-02-20T19:35:15Z","updated":"2026-02-20T19:52:17Z","closed":"2026-02-20T19:52:17Z"}
{"id":"tick-5ae939","title":"Plugin Authoring","status":"open","priority":2,"created":"2026-02-22T21:14:27Z","updated":"2026-02-22T21:14:27Z"}
{"id":"tick-e2964f","title":"Phase 1: Walking Skeleton -- Skill Scaffolding End-to-End","status":"done","priority":2,"parent":"tick-5ae939","created":"2026-02-22T21:14:31Z","updated":"2026-02-23T12:53:16Z","closed":"2026-02-23T12:53:16Z"}
{"id":"tick-4ec897","title":"Register init command with Commander","status":"done","priority":2,"description":"**Problem**: The init command does not exist in the CLI. Users need to run npx agntc init to scaffold new plugin repos, but Commander has no init subcommand registered.\n\n**Solution**: Create a new command module at src/commands/init.ts that exports a Commander Command for init with no arguments and no flags. Wire it into src/cli.ts alongside the existing commands.\n\n**Outcome**: Running npx agntc init invokes the init command handler (a stub that exits cleanly for now). Running npx agntc --help lists init alongside add, list, remove, and update.\n\n**Do**:\n- Create src/commands/init.ts exporting initCommand as a new Command(\"init\") with description \"Scaffold a new agntc plugin\" and no arguments or options\n- The .action() handler should call a runInit() async function wrapped in withExitSignal (same pattern as add.ts)\n- runInit() should be a stub that does nothing for now (the flow is built in subsequent tasks and wired in task 1-6)\n- In src/cli.ts, import and register initCommand via program.addCommand(initCommand)\n- Update tests/cli.test.ts to verify init appears in --help output and that agntc init exits with code 0\n\n**Acceptance Criteria**:\n- [ ] npx agntc init exits with code 0 without errors\n- [ ] npx agntc --help output includes init\n- [ ] init command accepts no arguments and no flags\n- [ ] Command description is present in help output\n\n**Tests**:\n- \"agntc --help includes init in output\" — verify the help text contains \"init\"\n- \"agntc init exits with code 0\" — verify the stub command runs cleanly\n- \"agntc init ignores extra arguments\" — verify extra args don't cause errors\n\n**Edge Cases**: None specified in task table.\n\n**Spec Reference**: .workflows/specification/plugin-authoring/specification.md — \"Command Signature\" section","parent":"tick-e2964f","created":"2026-02-22T21:14:47Z","updated":"2026-02-23T12:21:39Z","closed":"2026-02-23T12:21:39Z"}
{"id":"tick-63577c","title":"Type selection prompt","status":"done","priority":2,"description":"**Problem**: The init flow needs to ask the user what type of plugin they are creating (Skill, Plugin, or Collection). This is Step 2 of the init flow and determines the scaffolding path.\n\n**Solution**: Create a src/init/type-select.ts module that renders a @clack/prompts select prompt with three options — Skill, Plugin, Collection — and returns the selected type or signals cancellation.\n\n**Outcome**: Calling selectInitType() displays a radio-select prompt with three labelled options. Selecting an option returns a typed string (\"skill\" | \"plugin\" | \"collection\"). Cancelling (Ctrl+C / Escape) returns a cancellation signal that the caller can handle.\n\n**Do**:\n- Create src/init/type-select.ts exporting async function selectInitType(): Promise\u003cInitType | null\u003e\n- Define type InitType = \"skill\" | \"plugin\" | \"collection\" and export it\n- Use @clack/prompts select to render the prompt with message \"What are you creating?\"\n- Options: { value: \"skill\", label: \"Skill\", hint: \"a single skill (SKILL.md)\" }, { value: \"plugin\", label: \"Plugin\", hint: \"skills, agents, and/or hooks that install together as one package\" }, { value: \"collection\", label: \"Collection\", hint: \"a repo of individually selectable plugins\" }\n- Check isCancel(result) — if cancelled, return null\n- Otherwise return the selected value cast to InitType\n- Create tests/init/type-select.test.ts — mock @clack/prompts and test the prompt behavior\n\n**Acceptance Criteria**:\n- [ ] selectInitType() renders a select prompt with exactly three options: Skill, Plugin, Collection\n- [ ] Selecting \"Skill\" returns \"skill\"\n- [ ] Selecting \"Plugin\" returns \"plugin\"\n- [ ] Selecting \"Collection\" returns \"collection\"\n- [ ] Cancelling the prompt returns null\n- [ ] Prompt message is \"What are you creating?\"\n\n**Tests**:\n- \"renders three options: Skill, Plugin, Collection\" — verify the select call receives exactly 3 options with correct values and labels\n- \"returns 'skill' when Skill is selected\" — mock select returning \"skill\", verify return value\n- \"returns 'plugin' when Plugin is selected\" — mock select returning \"plugin\", verify return value\n- \"returns 'collection' when Collection is selected\" — mock select returning \"collection\", verify return value\n- \"returns null when user cancels\" — mock select returning Symbol(\"cancel\"), verify return is null\n\n**Edge Cases**:\n- User cancels at type prompt: the function returns null; the orchestrator (task 1-6) is responsible for exiting cleanly without writing files\n\n**Spec Reference**: .workflows/specification/plugin-authoring/specification.md — \"Step 2: Type Selection\"","parent":"tick-e2964f","created":"2026-02-22T21:15:03Z","updated":"2026-02-23T12:26:45Z","closed":"2026-02-23T12:26:45Z"}
{"id":"tick-036c2f","title":"Agent selection prompt","status":"done","priority":2,"description":"**Problem**: After selecting a type, the author must declare which agents their plugin supports (Claude, Codex, or both). At least one agent must be selected — empty selection is invalid. This is Step 3 of the init flow.\n\n**Solution**: Create a src/init/agent-select.ts module that renders a @clack/prompts multiselect prompt for agent selection. Unlike the consumer-facing selectAgents in src/agent-select.ts (which has pre-selection logic based on detected/declared agents), this is a simpler author-facing prompt with no pre-selection — just a clean multiselect where the author declares intent. Empty selection re-prompts.\n\n**Outcome**: Calling selectInitAgents() displays a multiselect with Claude and Codex options. Selecting one or both returns the array of AgentId. Selecting none re-prompts with a warning. Cancelling returns null.\n\n**Do**:\n- Create src/init/agent-select.ts exporting async function selectInitAgents(): Promise\u003cAgentId[] | null\u003e\n- Import AgentId from src/drivers/types.ts and getRegisteredAgentIds from src/drivers/registry.ts\n- Use @clack/prompts multiselect with message \"Which agents is this built for?\"\n- Build options from getRegisteredAgentIds() — each agent gets { value: id, label: id } (capitalize the label: \"Claude\", \"Codex\")\n- Set required: false on the multiselect so we can handle empty selection ourselves\n- After the multiselect returns: if isCancel(result), return null\n- If result.length === 0, log a warning via p.log.warn(\"At least one agent must be selected\") and loop back to re-prompt (wrap the multiselect in a while (true) loop)\n- Otherwise return result as AgentId[]\n- Create tests/init/agent-select.test.ts — mock @clack/prompts and getRegisteredAgentIds\n\n**Acceptance Criteria**:\n- [ ] selectInitAgents() renders a multiselect with Claude and Codex as options\n- [ ] Selecting [\"claude\"] returns [\"claude\"]\n- [ ] Selecting [\"codex\"] returns [\"codex\"]\n- [ ] Selecting [\"claude\", \"codex\"] returns [\"claude\", \"codex\"]\n- [ ] Empty selection triggers a warning and re-prompts (does not return empty array)\n- [ ] Cancelling returns null\n- [ ] No pre-selection — initialValues is empty or not set\n\n**Tests**:\n- \"renders Claude and Codex as multiselect options\" — verify options passed to multiselect match registered agents with capitalized labels\n- \"returns selected agents on valid selection\" — mock multiselect returning [\"claude\"], verify return\n- \"returns both agents when both selected\" — mock multiselect returning [\"claude\", \"codex\"], verify return\n- \"re-prompts on empty selection\" — mock multiselect returning [] first, then [\"claude\"] second; verify multiselect was called twice and final result is [\"claude\"]\n- \"returns null on cancel\" — mock multiselect returning Symbol(\"cancel\"), verify return is null\n- \"returns null on cancel after empty selection re-prompt\" — mock multiselect returning [] first, then Symbol(\"cancel\") second; verify return is null\n\n**Edge Cases**:\n- Empty selection rejected: the function re-prompts instead of returning an empty array. The spec says \"At least one agent must be selected — empty selection is not valid.\"\n- User cancels at agent prompt: returns null so the orchestrator can exit cleanly\n\n**Spec Reference**: .workflows/specification/plugin-authoring/specification.md — \"Step 3: Agent Selection\"","parent":"tick-e2964f","created":"2026-02-22T21:15:22Z","updated":"2026-02-23T12:30:52Z","closed":"2026-02-23T12:30:52Z"}
{"id":"tick-3bc6b7","title":"Preview and confirm prompt","status":"done","priority":2,"description":"**Problem**: Before writing files, the user must see a preview of what will be created and explicitly confirm. This is Step 4 of the init flow. For the Skill type, the preview shows agntc.json and SKILL.md.\n\n**Solution**: Create a src/init/preview-confirm.ts module that accepts the init type and renders a preview of files to be created, then asks for yes/no confirmation via @clack/prompts confirm.\n\n**Outcome**: Calling previewAndConfirm({ type: \"skill\" }) displays the file list and asks \"Proceed?\". Confirming returns true. Declining or cancelling returns false.\n\n**Do**:\n- Create src/init/preview-confirm.ts exporting async function previewAndConfirm(options: { type: InitType }): Promise\u003cboolean\u003e\n- Import InitType from src/init/type-select.ts\n- Build the file list based on the type. For \"skill\": [\"agntc.json\", \"SKILL.md\"]. (Plugin and Collection file lists will be added in Phase 2, but define the branching structure now with placeholder arrays or throw for unsupported types)\n- Use p.note() or p.log.info() to display the file list formatted as the spec shows: \"This will create:\\n\\n  agntc.json\\n  SKILL.md\"\n- Use p.confirm({ message: \"Proceed?\" }) to ask for confirmation\n- If isCancel(result) or result === false, return false\n- If result === true, return true\n- Create tests/init/preview-confirm.test.ts — mock @clack/prompts\n\n**Acceptance Criteria**:\n- [ ] For type \"skill\", displays agntc.json and SKILL.md in the preview\n- [ ] Confirming returns true\n- [ ] Declining (answering no) returns false\n- [ ] Cancelling (Ctrl+C) returns false\n- [ ] Preview message includes \"This will create:\"\n- [ ] For type \"plugin\" or \"collection\", throws an error (these types are wired in Phase 2)\n\n**Tests**:\n- \"displays agntc.json and SKILL.md for skill type\" — verify the note/log call contains both file names\n- \"returns true when user confirms\" — mock confirm returning true, verify return\n- \"returns false when user declines\" — mock confirm returning false, verify return\n- \"returns false when user cancels\" — mock confirm returning Symbol(\"cancel\"), verify return\n- \"preview message includes 'This will create:'\" — verify the displayed text\n- \"throws for plugin type\" — call with type \"plugin\", verify it throws (placeholder until Phase 2)\n\n**Edge Cases**:\n- User declines confirmation: returns false, no files written\n- User cancels at confirm prompt: returns false, same behavior as declining\n\n**Spec Reference**: .workflows/specification/plugin-authoring/specification.md — \"Step 4: Preview and Confirm\"","parent":"tick-e2964f","created":"2026-02-22T21:15:39Z","updated":"2026-02-23T12:41:31Z","closed":"2026-02-23T12:41:31Z"}
{"id":"tick-37bd20","title":"Scaffold skill files to disk","status":"done","priority":2,"description":"**Problem**: Once the user confirms, the init flow needs to write agntc.json and SKILL.md to disk with the correct content. Existing files must not be overwritten — they should be skipped, with the output reporting what was created vs skipped.\n\n**Solution**: Create a src/init/scaffold-skill.ts module that writes agntc.json (with the selected agents) and SKILL.md (with the frontmatter template) to the current directory. Each file is checked for existence before writing; existing files are skipped.\n\n**Outcome**: Calling scaffoldSkill({ agents, targetDir }) writes up to two files and returns a result indicating which were created and which were skipped. Files are written with the exact content specified in the spec.\n\n**Do**:\n- Create src/init/scaffold-skill.ts exporting async function scaffoldSkill(options: { agents: AgentId[]; targetDir: string }): Promise\u003cScaffoldResult\u003e\n- Define and export interface ScaffoldResult { created: string[]; skipped: string[] }\n- For agntc.json: build the JSON content as { \"agents\": [...] } using JSON.stringify with 2-space indentation plus trailing newline. The agents array reflects exactly what was selected\n- For SKILL.md: use the exact template from the spec:\n  ---\n  name: my-skill\n  description: Brief description of what this skill does and when to use it.\n  ---\n\n  # My Skill\n\n  ## Instructions\n\n  [Describe what the agent should do when this skill is invoked]\n- Before writing each file, check if it already exists using fs.access() or similar. If it exists, add the filename to skipped and do not overwrite. If it does not exist, write it and add to created\n- Use node:fs/promises for all file operations (writeFile, access)\n- Create tests/init/scaffold-skill.test.ts — use a real temp directory (fs.mkdtemp) for file system tests\n\n**Acceptance Criteria**:\n- [ ] agntc.json is written with {\"agents\": [\"claude\"]} when [\"claude\"] is selected (2-space indent, trailing newline)\n- [ ] agntc.json is written with {\"agents\": [\"claude\", \"codex\"]} when both selected\n- [ ] SKILL.md is written with the exact frontmatter template from the spec\n- [ ] If agntc.json already exists, it is skipped (not overwritten) and appears in skipped\n- [ ] If SKILL.md already exists, it is skipped (not overwritten) and appears in skipped\n- [ ] If both files already exist, both are skipped\n- [ ] created array contains only the files that were actually written\n- [ ] skipped array contains only the files that were skipped\n\n**Tests**:\n- \"writes agntc.json with selected agents\" — scaffold in empty temp dir, read file, verify JSON content matches { agents: [\"claude\"] }\n- \"writes agntc.json with both agents when both selected\" — verify { agents: [\"claude\", \"codex\"] }\n- \"writes SKILL.md with frontmatter template\" — scaffold in empty temp dir, read file, verify content matches spec template exactly\n- \"skips agntc.json when it already exists\" — pre-create agntc.json with different content, scaffold, verify original content unchanged and filename in skipped\n- \"skips SKILL.md when it already exists\" — pre-create SKILL.md, scaffold, verify unchanged and in skipped\n- \"skips both files when both exist\" — pre-create both, scaffold, verify created is empty and skipped has both\n- \"reports created files correctly\" — scaffold in empty dir, verify created contains both filenames\n- \"agntc.json has trailing newline\" — verify the written content ends with newline\n\n**Edge Cases**:\n- agntc.json already exists: skipped, original content preserved\n- SKILL.md already exists: skipped, original content preserved\n- Both already exist: both skipped, created is empty\n\n**Spec Reference**: .workflows/specification/plugin-authoring/specification.md — \"Step 5: Scaffold\" and \"Starter File Content\"","parent":"tick-e2964f","created":"2026-02-22T21:16:00Z","updated":"2026-02-23T12:48:31Z","closed":"2026-02-23T12:48:31Z"}
{"id":"tick-3127a5","title":"End-to-end init flow orchestration","status":"done","priority":2,"description":"**Problem**: Tasks 1-5 created individual pieces (command registration, type prompt, agent prompt, preview/confirm, file scaffolding) but they are not wired together. The runInit() function in src/commands/init.ts is still a stub. The full flow — intro, type select, agent select, preview, scaffold, done message — needs to be orchestrated.\n\n**Solution**: Implement runInit() in src/commands/init.ts to call each step in sequence, handling cancellation at each prompt step by exiting cleanly without writing files. For Phase 1, only the Skill path completes end-to-end; Plugin and Collection types exit with a \"not yet supported\" message.\n\n**Outcome**: Running npx agntc init walks the user through: intro -\u003e type selection -\u003e agent selection -\u003e preview -\u003e confirm -\u003e scaffold -\u003e success message. Cancellation at any step exits cleanly. The Skill path produces agntc.json and SKILL.md on disk.\n\n**Do**:\n- Replace the stub runInit() in src/commands/init.ts with the full orchestration\n- Call p.intro(\"agntc init\") at the start\n- Call selectInitType() — if null (cancelled), call p.cancel(\"Cancelled\") and throw new ExitSignal(0)\n- If type is \"plugin\" or \"collection\", call p.cancel(\"Plugin and Collection scaffolding coming soon\") and throw new ExitSignal(0) (Phase 2 will remove this guard)\n- Call selectInitAgents() — if null (cancelled), call p.cancel(\"Cancelled\") and throw new ExitSignal(0)\n- Call previewAndConfirm({ type }) — if false (declined/cancelled), call p.cancel(\"Cancelled\") and throw new ExitSignal(0)\n- Call scaffoldSkill({ agents, targetDir: process.cwd() })\n- Build the output message: if any files were skipped, include \"Skipped (already exists): {filenames}\". If any files were created, show the success message\n- For Skill type, the success message is: \"Done. Edit `SKILL.md` to define your skill.\"\n- Call p.outro(message) with the success message\n- Create tests/commands/init.test.ts — mock all prompt modules and scaffoldSkill, test the orchestration logic including cancellation at every step\n- Import dependencies: selectInitType from src/init/type-select.ts, selectInitAgents from src/init/agent-select.ts, previewAndConfirm from src/init/preview-confirm.ts, scaffoldSkill from src/init/scaffold-skill.ts\n\n**Acceptance Criteria**:\n- [ ] runInit() calls type select, agent select, preview/confirm, and scaffold in order\n- [ ] Cancelling at type selection exits without writing any files\n- [ ] Cancelling at agent selection exits without writing any files\n- [ ] Cancelling/declining at confirmation exits without writing any files\n- [ ] Selecting Skill type, choosing agents, confirming produces agntc.json and SKILL.md\n- [ ] Success message for Skill is \"Done. Edit `SKILL.md` to define your skill.\"\n- [ ] Skipped files are reported in the output\n- [ ] Plugin and Collection types show \"coming soon\" and exit cleanly\n- [ ] p.intro(\"agntc init\") is called at the start of the flow\n\n**Tests**:\n- \"completes skill scaffolding end-to-end\" — mock type-\u003eskill, agents-\u003e[\"claude\"], confirm-\u003etrue, scaffold returns created:[\"agntc.json\",\"SKILL.md\"]; verify scaffoldSkill was called with correct args and outro contains the success message\n- \"exits cleanly when type selection is cancelled\" — mock type-\u003enull; verify scaffoldSkill was NOT called and ExitSignal(0) is thrown\n- \"exits cleanly when agent selection is cancelled\" — mock type-\u003eskill, agents-\u003enull; verify scaffoldSkill was NOT called\n- \"exits cleanly when confirmation is declined\" — mock type-\u003eskill, agents-\u003e[\"claude\"], confirm-\u003efalse; verify scaffoldSkill was NOT called\n- \"exits with coming-soon for plugin type\" — mock type-\u003eplugin; verify ExitSignal(0) is thrown and scaffoldSkill was NOT called\n- \"exits with coming-soon for collection type\" — mock type-\u003ecollection; verify ExitSignal(0) is thrown\n- \"reports skipped files in output\" — mock scaffold returning created:[\"agntc.json\"], skipped:[\"SKILL.md\"]; verify the outro message mentions the skipped file\n- \"passes selected agents to scaffoldSkill\" — mock agents-\u003e[\"claude\",\"codex\"]; verify scaffoldSkill receives { agents: [\"claude\",\"codex\"], targetDir: expect.any(String) }\n- \"calls p.intro with 'agntc init'\" — verify intro is called with the correct string\n\n**Edge Cases**:\n- Cancel at any prompt step exits cleanly without writing files: this is the primary edge case for the orchestrator. Each cancellation point must be tested independently.\n\n**Spec Reference**: .workflows/specification/plugin-authoring/specification.md — \"Init Flow\" (all steps), \"Step 6: Done\"","parent":"tick-e2964f","created":"2026-02-22T21:16:29Z","updated":"2026-02-23T12:53:09Z","closed":"2026-02-23T12:53:09Z"}
{"id":"tick-1a7ccc","title":"Phase 2: Plugin and Collection Scaffolding","status":"done","priority":2,"parent":"tick-5ae939","created":"2026-02-22T21:22:58Z","updated":"2026-02-23T13:43:23Z","closed":"2026-02-23T13:43:23Z"}
{"id":"tick-e6b318","title":"Scaffold plugin files and directories","status":"done","priority":2,"description":"**Problem**: When a user selects \"Plugin\" type in the init flow, the system needs to write agntc.json, create the skills/my-skill/SKILL.md starter file, and create empty agents/ and hooks/ directories. Phase 1 only implemented skill scaffolding (agntc.json + SKILL.md at root). There is no module that produces the plugin directory structure.\n\n**Solution**: Create src/init/scaffold-plugin.ts that writes the plugin directory structure to disk. The function accepts the target directory and selected agents, then creates agntc.json, skills/my-skill/SKILL.md, agents/, and hooks/. Each file/directory is checked for existence before creation -- existing items are skipped, not overwritten. The function returns a result reporting which items were created and which were skipped.\n\n**Outcome**: Calling scaffoldPlugin(dir, agents) on a clean directory writes all four items. Calling it on a directory with some items already present writes only the missing ones. The return value accurately reports created vs skipped for every item.\n\n**Do**:\n- Create src/init/scaffold-plugin.ts exporting scaffoldPlugin(dir: string, agents: AgentId[]): Promise\u003cScaffoldPluginResult\u003e\n- Define ScaffoldPluginResult with created: string[] and skipped: string[] arrays\n- For agntc.json: check if file exists; if not, write { \"agents\": [...] } with 2-space indent + trailing newline\n- For skills/my-skill/SKILL.md: create directory with { recursive: true }, check if SKILL.md exists, write template if not\n- For agents/ and hooks/: create with mkdir({ recursive: true }), check existence first\n- Create tests/init/scaffold-plugin.test.ts with tests against a real temp directory\n\n**Acceptance Criteria**:\n- [ ] scaffoldPlugin on empty directory creates agntc.json, skills/my-skill/SKILL.md, agents/, hooks/\n- [ ] agntc.json content matches { \"agents\": [\"claude\"] } with 2-space indent\n- [ ] SKILL.md content matches the spec template exactly\n- [ ] When agntc.json already exists, it is skipped\n- [ ] When skills/my-skill/SKILL.md already exists, it is skipped\n- [ ] When agents/ or hooks/ already exists, they are skipped\n- [ ] Return value created + skipped together account for all four items\n\n**Edge Cases**:\n- agntc.json already exists: skip, do not overwrite\n- skills/ directory already exists without SKILL.md: create the file\n- agents/ or hooks/ already exists: skip\n- SKILL.md already exists inside existing skills/my-skill/: skip\n\n**Tests**:\n- \"creates all four items in empty directory\" -- scaffold in clean temp dir, verify agntc.json, skills/my-skill/SKILL.md, agents/, hooks/ all exist\n- \"writes agntc.json with selected agents\" -- verify JSON content matches { agents: [\"claude\"] } with 2-space indent\n- \"writes SKILL.md with spec template\" -- verify content matches frontmatter template exactly\n- \"skips agntc.json when it already exists\" -- pre-create agntc.json, scaffold, verify original content unchanged and filename in skipped\n- \"skips SKILL.md when it already exists inside skills/my-skill/\" -- pre-create the nested file, scaffold, verify unchanged\n- \"creates SKILL.md when skills/ exists but SKILL.md does not\" -- create skills/my-skill/ directory only, scaffold, verify SKILL.md created\n- \"skips agents/ when it already exists\" -- pre-create agents/, scaffold, verify in skipped\n- \"skips hooks/ when it already exists\" -- pre-create hooks/, scaffold, verify in skipped\n- \"created and skipped arrays account for all four items\" -- scaffold with some items existing, verify created.length + skipped.length === 4\n\n**Spec Reference**: .workflows/specification/plugin-authoring/specification.md -- Step 5: Scaffold","parent":"tick-1a7ccc","created":"2026-02-22T21:23:16Z","updated":"2026-02-23T12:57:49Z","closed":"2026-02-23T12:57:49Z"}
{"id":"tick-ca0f0a","title":"Plugin preview and success message","status":"done","priority":2,"description":"**Problem**: The init flow needs to show the user what files will be created before writing them, and display a type-specific success message after scaffolding completes. Phase 1 implemented preview for the \"Skill\" type only. The \"Plugin\" type has a different preview tree format and a different success message.\n\n**Solution**: Extend src/init/preview-confirm.ts to handle plugin type preview rendering. The preview must show the exact tree structure from the spec. After scaffolding, the success message must be \"Done. Add your skills, agents, and hooks.\" The output should also report created vs skipped items.\n\n**Outcome**: When a user selects \"Plugin\" type, they see the spec-defined preview tree before confirmation. After successful scaffolding, they see the correct success message.\n\n**Do**:\n- Add buildPluginPreviewLines(): string[] that returns the preview lines matching the spec format:\n  agntc.json\n  skills/\n    my-skill/\n      SKILL.md\n  agents/\n  hooks/\n- Integrate with existing previewAndConfirm flow\n- Success message for plugin type is exactly: \"Done. Add your skills, agents, and hooks.\"\n- After scaffoldPlugin returns, format output showing created vs skipped items\n- Create tests for preview lines and success message formatting\n\n**Acceptance Criteria**:\n- [ ] Plugin preview output matches the exact tree format from the spec (2-space indentation)\n- [ ] Preview is shown before confirmation prompt\n- [ ] Success message is exactly \"Done. Add your skills, agents, and hooks.\"\n- [ ] When all items created, output shows success without skipped section\n- [ ] When some items skipped, output reports created and skipped separately\n- [ ] Cancelling at confirm exits without writing files\n\n**Edge Cases**:\n- Mixed created and skipped items: preview shows full tree; created/skipped breakdown in post-scaffold summary\n\n**Tests**:\n- \"builds plugin preview lines matching spec tree format\" -- verify buildPluginPreviewLines() returns lines with agntc.json, skills/, my-skill/, SKILL.md, agents/, hooks/ at correct indentation\n- \"preview is shown before confirmation prompt\" -- mock @clack/prompts, verify note/log called before confirm\n- \"success message is 'Done. Add your skills, agents, and hooks.'\" -- verify the exact string\n- \"reports created items when all items are new\" -- pass scaffold result with all created, verify output shows success without skipped section\n- \"reports mixed created and skipped items\" -- pass scaffold result with some created and some skipped, verify both sections present\n- \"cancelling at confirm returns false\" -- mock confirm returning Symbol(\"cancel\"), verify return is false\n\n**Spec Reference**: .workflows/specification/plugin-authoring/specification.md -- Step 4: Preview and Confirm, Step 6: Done","parent":"tick-1a7ccc","created":"2026-02-22T21:23:30Z","updated":"2026-02-23T13:05:03Z","closed":"2026-02-23T13:05:03Z"}
{"id":"tick-640df5","title":"Scaffold collection structure","status":"done","priority":2,"description":"**Problem**: When a user selects \"Collection\" type, the system must scaffold a nested structure under a my-plugin/ subdirectory: my-plugin/agntc.json, my-plugin/skills/my-skill/SKILL.md, my-plugin/agents/, my-plugin/hooks/. Crucially, there must be no root-level agntc.json -- collections are identified by the absence of a root config.\n\n**Solution**: Create src/init/scaffold-collection.ts that writes the collection directory structure. The function creates the my-plugin/ wrapper directory and then writes the same internal structure as a plugin inside it. It reuses the same file content but at the nested path.\n\n**Outcome**: Calling scaffoldCollection(dir, agents) on a clean directory creates the my-plugin/ subtree with all four items inside. No root agntc.json is created.\n\n**Do**:\n- Create src/init/scaffold-collection.ts exporting scaffoldCollection(dir: string, agents: AgentId[]): Promise\u003cScaffoldCollectionResult\u003e\n- Define ScaffoldCollectionResult with created: string[] and skipped: string[] arrays, paths prefixed with \"my-plugin/\"\n- Create my-plugin/ directory with mkdir({ recursive: true })\n- For each item inside my-plugin/, follow the same existence-check-then-create pattern as scaffoldPlugin\n- Consider extracting shared helpers into src/init/scaffold-common.ts\n- Do NOT create a root-level agntc.json -- verify this in tests\n- Create tests/init/scaffold-collection.test.ts\n\n**Acceptance Criteria**:\n- [ ] scaffoldCollection on empty directory creates my-plugin/agntc.json, my-plugin/skills/my-skill/SKILL.md, my-plugin/agents/, my-plugin/hooks/\n- [ ] No agntc.json exists at root directory (only inside my-plugin/)\n- [ ] my-plugin/agntc.json content matches agent-selection format\n- [ ] my-plugin/skills/my-skill/SKILL.md content matches spec template\n- [ ] When my-plugin/ directory already exists, items inside are checked individually\n- [ ] When my-plugin/agntc.json already exists, it is skipped\n- [ ] Return value paths all prefixed with my-plugin/\n\n**Edge Cases**:\n- my-plugin/ directory already exists: enter and check each item individually\n- Partial contents inside existing my-plugin/: only create missing items\n- Root directory must NOT contain agntc.json after scaffolding\n\n**Tests**:\n- \"creates my-plugin/ subtree in empty directory\" -- scaffold in clean temp dir, verify my-plugin/agntc.json, my-plugin/skills/my-skill/SKILL.md, my-plugin/agents/, my-plugin/hooks/ all exist\n- \"does not create root agntc.json\" -- scaffold, verify no agntc.json at root directory\n- \"my-plugin/agntc.json content matches agent selection\" -- verify JSON content matches { agents: [\"claude\", \"codex\"] }\n- \"my-plugin/skills/my-skill/SKILL.md matches spec template\" -- verify content matches frontmatter template exactly\n- \"skips my-plugin/agntc.json when it already exists\" -- pre-create, scaffold, verify unchanged and in skipped\n- \"checks items individually when my-plugin/ already exists\" -- pre-create my-plugin/ with partial contents, scaffold, verify only missing items created\n- \"return paths all prefixed with my-plugin/\" -- verify every entry in created and skipped starts with \"my-plugin/\"\n\n**Spec Reference**: .workflows/specification/plugin-authoring/specification.md -- Step 5: Scaffold","parent":"tick-1a7ccc","created":"2026-02-22T21:23:45Z","updated":"2026-02-23T13:09:16Z","closed":"2026-02-23T13:09:16Z"}
{"id":"tick-01d772","title":"Collection preview and success message","status":"done","priority":2,"description":"**Problem**: The Collection type needs its own preview tree format and success message, distinct from both Skill and Plugin types. The preview must show the my-plugin/ wrapper directory with the nested structure inside. The success message must guide the author to rename and duplicate the template directory.\n\n**Solution**: Add collection preview rendering that produces the spec-defined tree format with my-plugin/ as the root item. Wire the success message \"Done. Rename \\`my-plugin/\\` and duplicate for each plugin in your collection.\" into the post-scaffold output.\n\n**Outcome**: When a user selects \"Collection\" type, they see the correct nested preview tree. After scaffolding, they see the collection-specific success message.\n\n**Do**:\n- Add buildCollectionPreviewLines(): string[] that returns lines matching the spec:\n  my-plugin/\n    agntc.json\n    skills/\n      my-skill/\n        SKILL.md\n    agents/\n    hooks/\n- Integrate with preview-confirm flow to dispatch based on InitType\n- Success message for collection type is exactly: \"Done. Rename \\`my-plugin/\\` and duplicate for each plugin in your collection.\"\n- After scaffoldCollection returns, format created/skipped output\n- Create tests for collection preview lines and success message\n\n**Acceptance Criteria**:\n- [ ] Collection preview output matches spec tree format (2-space indentation, my-plugin/ at root)\n- [ ] Preview shows my-plugin/ as first line with agntc.json indented under it\n- [ ] Success message is exactly \"Done. Rename \\`my-plugin/\\` and duplicate for each plugin in your collection.\"\n- [ ] When all items created, output shows success without skipped section\n- [ ] When some items skipped, output reports created and skipped with my-plugin/-prefixed paths\n- [ ] Cancelling at confirm exits without writing files\n\n**Edge Cases**:\n- Mixed created and skipped items: preview shows full tree; breakdown in post-scaffold summary\n\n**Tests**:\n- \"builds collection preview lines with my-plugin/ at root\" -- verify buildCollectionPreviewLines() returns lines with my-plugin/ first, then indented agntc.json, skills/, etc.\n- \"preview shows correct 2-space indentation\" -- verify indentation levels match spec\n- \"success message is 'Done. Rename \\`my-plugin/\\` and duplicate for each plugin in your collection.'\" -- verify exact string\n- \"reports created items when all items are new\" -- pass scaffold result with all created, verify output shows success without skipped section\n- \"reports mixed created and skipped with my-plugin/ prefixed paths\" -- pass result with some skipped, verify paths shown with prefix\n- \"cancelling at confirm returns false\" -- mock confirm returning Symbol(\"cancel\"), verify return is false\n\n**Spec Reference**: .workflows/specification/plugin-authoring/specification.md -- Step 4: Preview and Confirm, Step 6: Done","parent":"tick-1a7ccc","created":"2026-02-22T21:24:03Z","updated":"2026-02-23T13:14:23Z","closed":"2026-02-23T13:14:23Z"}
{"id":"tick-d1d22a","title":"End-to-end type routing","status":"done","priority":2,"description":"**Problem**: The runInit() orchestration function (from Phase 1) currently only handles the \"Skill\" type end-to-end. It needs to route to the correct scaffold and preview functions based on the user's type selection. When the user selects \"Plugin\" or \"Collection\", the flow must call the corresponding scaffold function, show the correct preview, and display the correct success message.\n\n**Solution**: Extend src/commands/init.ts to branch on the InitType returned from type selection. For each type, call the appropriate preview builder, scaffold function, and success message. Ensure cancellation at any step exits cleanly for all three type paths.\n\n**Outcome**: npx agntc init correctly scaffolds Plugin and Collection structures end-to-end when those types are selected. Cancellation at any step exits cleanly. The complete flow for each type matches the spec.\n\n**Do**:\n- In init orchestration (src/commands/init.ts runInit()), after receiving InitType:\n  - If \"skill\": use existing Phase 1 scaffold path\n  - If \"plugin\": call buildPluginPreviewLines(), scaffoldPlugin(), show plugin success message\n  - If \"collection\": call buildCollectionPreviewLines(), scaffoldCollection(), show collection success message\n- Agent selection step is shared across all three types\n- Handle @clack/prompts cancellation (isCancel()) at every prompt step for plugin and collection paths\n- Create tests/init/init-routing.test.ts (or extend tests/commands/init.test.ts) testing routing and cancellation\n\n**Acceptance Criteria**:\n- [ ] Selecting \"Plugin\" routes through plugin preview, plugin scaffold, plugin success message\n- [ ] Selecting \"Collection\" routes through collection preview, collection scaffold, collection success message\n- [ ] Selecting \"Skill\" continues to work as before (Phase 1 preserved)\n- [ ] Agent multiselect values passed correctly to scaffoldPlugin and scaffoldCollection\n- [ ] Cancel at type selection exits cleanly with no files written\n- [ ] Cancel at agent selection exits cleanly with no files written\n- [ ] Cancel at confirm exits cleanly with no files written\n- [ ] Correct scaffold function called for each type (no cross-contamination)\n\n**Edge Cases**:\n- Cancel at any prompt step exits cleanly for plugin and collection paths\n- Existing Skill path must not regress\n\n**Tests**:\n- \"routes plugin type through plugin scaffold\" -- mock type-\u003eplugin, agents-\u003e[\"claude\"], confirm-\u003etrue; verify scaffoldPlugin called, scaffoldSkill NOT called\n- \"routes collection type through collection scaffold\" -- mock type-\u003ecollection, agents-\u003e[\"claude\"], confirm-\u003etrue; verify scaffoldCollection called\n- \"skill type continues to work\" -- mock type-\u003eskill; verify scaffoldSkill called (Phase 1 regression check)\n- \"passes agent selection to scaffoldPlugin\" -- mock agents-\u003e[\"claude\",\"codex\"]; verify scaffoldPlugin receives correct agents\n- \"passes agent selection to scaffoldCollection\" -- mock agents-\u003e[\"codex\"]; verify scaffoldCollection receives correct agents\n- \"cancel at type selection exits cleanly for all types\" -- mock type-\u003enull; verify no scaffold function called\n- \"cancel at agent selection exits cleanly\" -- mock type-\u003eplugin, agents-\u003enull; verify scaffoldPlugin NOT called\n- \"cancel at confirm exits cleanly\" -- mock type-\u003ecollection, agents-\u003e[\"claude\"], confirm-\u003efalse; verify scaffoldCollection NOT called\n- \"displays correct success message for plugin\" -- verify outro contains \"Done. Add your skills, agents, and hooks.\"\n- \"displays correct success message for collection\" -- verify outro contains \"Done. Rename \\`my-plugin/\\`...\"\n\n**Spec Reference**: .workflows/specification/plugin-authoring/specification.md -- Init Flow (all steps)","parent":"tick-1a7ccc","created":"2026-02-22T21:24:19Z","updated":"2026-02-23T13:43:16Z","closed":"2026-02-23T13:43:16Z"}
{"id":"tick-5c139e","title":"Phase 3: Pre-check and Reconfigure","status":"done","priority":2,"parent":"tick-5ae939","created":"2026-02-22T21:32:40Z","updated":"2026-02-23T14:09:25Z","closed":"2026-02-23T14:09:25Z"}
{"id":"tick-7a71b4","title":"Pre-check detection, orchestrator wiring, and cancel behavior","status":"done","priority":2,"description":"**Problem**: When a plugin author runs npx agntc init in a directory that already contains agntc.json, the flow currently has no guard. The spec requires detecting this state and presenting an explicit choice before any other prompts appear. The pre-check must also be wired into the init orchestrator so it gates the entire flow.\n\n**Solution**: Create a pre-check module that tests for agntc.json existence at process.cwd() before entering the prompt flow. When found, display a @clack/prompts warning message (\"This directory is already initialized.\") and present a select prompt with \"Reconfigure\" and \"Cancel\" options. Wire preCheck() into the init command orchestrator as the first call, routing on its result.\n\n**Outcome**: When agntc.json exists at cwd root, the user sees the warning and two options before any other prompts. Selecting \"Cancel\" exits immediately without writing files or showing further prompts. Selecting \"Reconfigure\" enters the full prompt flow with a reconfigure flag. When agntc.json does not exist, the prompt flow proceeds unchanged.\n\n**Do**:\n- Create src/init/pre-check.ts exporting async preCheck(cwd: string) function\n- Use node:fs/promises access() to check for agntc.json at the given path\n- If agntc.json does not exist, return { status: \"fresh\" }\n- If agntc.json exists, use @clack/prompts log.warn() to display warning then use select() for Reconfigure/Cancel\n- If user selects \"Reconfigure\", return { status: \"reconfigure\" }\n- If user selects \"Cancel\" or cancels (isCancel), return { status: \"cancel\" }\n- Define and export PreCheckResult type\n- In src/commands/init.ts runInit(), add preCheck(process.cwd()) as the first call before any prompt flow\n- If preCheck returns { status: \"cancel\" }, call p.cancel(\"Operation cancelled.\") and throw new ExitSignal(0)\n- If preCheck returns { status: \"fresh\" }, proceed with existing prompt flow unchanged\n- If preCheck returns { status: \"reconfigure\" }, proceed with prompt flow but pass reconfigure: true flag through to scaffold step (reconfigure overwrite behavior is implemented in task 3-3)\n- Create tests/init/pre-check.test.ts for the preCheck module\n- Create or extend tests/commands/init.test.ts to verify orchestrator routing on preCheck results\n\n**Acceptance Criteria**:\n- [ ] When agntc.json exists at cwd, warning \"This directory is already initialized.\" is displayed\n- [ ] When agntc.json exists, select prompt with \"Reconfigure\" and \"Cancel\" options shown\n- [ ] Selecting \"Reconfigure\" returns { status: \"reconfigure\" }\n- [ ] Selecting \"Cancel\" returns { status: \"cancel\" }\n- [ ] When agntc.json does not exist, returns { status: \"fresh\" } with no prompts\n- [ ] Empty or malformed agntc.json still triggers pre-check (existence check only)\n- [ ] Collection directories with no root agntc.json do not trigger pre-check\n- [ ] When pre-check returns cancel, no type selection prompt is shown\n- [ ] When pre-check returns cancel, no files are written to disk\n- [ ] When pre-check returns cancel, p.cancel() is called and process exits with code 0\n- [ ] When pre-check returns fresh, prompt flow proceeds as in Phase 1/2\n- [ ] When pre-check returns reconfigure, prompt flow proceeds with reconfigure flag\n\n**Tests**:\n- \"returns fresh when agntc.json does not exist\" -- verify no prompts shown, returns { status: \"fresh\" }\n- \"displays warning when agntc.json exists\" -- verify log.warn called with \"This directory is already initialized.\"\n- \"returns reconfigure when user selects Reconfigure\" -- mock select returning \"reconfigure\", verify result\n- \"returns cancel when user selects Cancel\" -- mock select returning \"cancel\", verify result\n- \"returns cancel when user presses Ctrl+C\" -- mock select returning Symbol(\"cancel\"), verify result\n- \"triggers for empty agntc.json\" -- create empty file, verify pre-check still fires\n- \"does not trigger when agntc.json absent\" -- clean directory, verify returns fresh\n- \"orchestrator exits cleanly on cancel\" -- mock preCheck returning cancel, verify scaffoldSkill/Plugin/Collection NOT called, ExitSignal(0) thrown\n- \"orchestrator proceeds normally on fresh\" -- mock preCheck returning fresh, verify type selection prompt is called\n- \"orchestrator passes reconfigure flag on reconfigure\" -- mock preCheck returning reconfigure, verify prompt flow enters with reconfigure context\n\n**Edge Cases**:\n- agntc.json exists but is empty or malformed: pre-check triggers (existence check only, no parsing)\n- Collection directories with no root agntc.json: pre-check returns fresh, no warning shown\n- Ctrl+C at the Reconfigure/Cancel prompt: treated as cancel\n\n**Spec Reference**: .workflows/specification/plugin-authoring/specification.md -- Step 1: Pre-check","parent":"tick-5c139e","created":"2026-02-22T21:32:55Z","updated":"2026-02-23T13:49:12Z","closed":"2026-02-23T13:49:12Z"}
{"id":"tick-df1d66","title":"Cancel at pre-check exits cleanly","status":"cancelled","priority":2,"description":"**Problem**: When the user selects \"Cancel\" at the pre-check prompt (or presses Ctrl+C), the init command must exit immediately without writing any files or showing further prompts.\n\n**Solution**: Wire the pre-check result into the init command orchestration so that a cancel status short-circuits the entire flow. The orchestrator calls preCheck() first; if the result is cancel, it calls @clack/prompts cancel() and returns without entering type selection.\n\n**Outcome**: Selecting \"Cancel\" at the pre-check prompt exits the init command gracefully. No files are created, modified, or deleted. No subsequent prompts are shown.\n\n**Do**:\n- In init command orchestrator (src/commands/init.ts), add preCheck(cwd) as first call before prompt flow\n- If preCheck returns { status: \"cancel\" }, call @clack/prompts cancel(\"Operation cancelled.\") and return early\n- If preCheck returns { status: \"fresh\" }, proceed with normal prompt flow\n- If preCheck returns { status: \"reconfigure\" }, proceed with prompt flow but pass reconfigure: true flag to scaffold step\n- Create tests verifying orchestrator exits cleanly on cancel\n\n**Acceptance Criteria**:\n- [ ] When pre-check returns cancel, no type selection prompt is shown\n- [ ] When pre-check returns cancel, no files are written to disk\n- [ ] When pre-check returns cancel, @clack/prompts cancel() is called\n- [ ] When pre-check returns fresh, prompt flow proceeds as in Phase 1/2\n- [ ] When pre-check returns reconfigure, prompt flow proceeds with reconfigure flag\n- [ ] Process exits with code 0 on cancel\n\n**Spec Reference**: .workflows/specification/plugin-authoring/specification.md -- Step 1: Pre-check","parent":"tick-5c139e","created":"2026-02-22T21:33:08Z","updated":"2026-02-22T21:46:26Z","closed":"2026-02-22T21:46:26Z"}
{"id":"tick-36fae5","title":"Reconfigure overwrites agntc.json while skipping other files","status":"done","priority":2,"description":"**Problem**: When a user chooses \"Reconfigure\", the scaffolding step must change overwrite semantics for exactly one file: agntc.json. In fresh-run mode, all existing files are skipped. In reconfigure mode, agntc.json must be overwritten while every other file retains skip-if-exists behavior.\n\n**Solution**: Add a reconfigure?: boolean flag to the scaffold functions (scaffoldSkill, scaffoldPlugin, scaffoldCollection). When reconfigure is true, the agntc.json write uses overwrite instead of skip-if-exists. All other writes remain unchanged. The scaffold result gains a third state: \"overwritten\".\n\n**Outcome**: Running reconfigure produces a new agntc.json reflecting new selections, even if it already existed. All other existing files are untouched.\n\n**Do**:\n- In src/init/scaffold-skill.ts, extend ScaffoldResult to include an overwritten: string[] array alongside created and skipped (this is the shared type used by all three scaffold functions)\n- Add reconfigure?: boolean to scaffoldSkill's options parameter\n- When reconfigure is true and agntc.json exists: overwrite and add to overwritten array instead of skipped\n- When reconfigure is false or agntc.json does not exist: behavior unchanged from Phase 1\n- Apply the same reconfigure flag to scaffoldPlugin in src/init/scaffold-plugin.ts -- when reconfigure is true, agntc.json is overwritten; all other items (SKILL.md, agents/, hooks/) follow skip-if-exists\n- Apply the same reconfigure flag to scaffoldCollection in src/init/scaffold-collection.ts -- when reconfigure is true, my-plugin/agntc.json is overwritten; all other items follow skip-if-exists\n- The agntc.json overwrite is a full write (not merge) -- always {\"agents\": [...]} from current selection\n- In src/commands/init.ts, pass the reconfigure flag from the orchestrator through to the scaffold call (the flag was threaded through in task 3-1)\n- Create tests/init/scaffold-reconfigure.test.ts covering all three types\n\n**Acceptance Criteria**:\n- [ ] ScaffoldResult type includes overwritten: string[] alongside created and skipped\n- [ ] In reconfigure mode, agntc.json is overwritten with new selections\n- [ ] In reconfigure mode, SKILL.md is skipped if it exists\n- [ ] In reconfigure mode, skills/, agents/, hooks/ directories are skipped if they exist\n- [ ] In fresh mode (reconfigure=false), behavior identical to Phase 1/2 (overwritten array is empty)\n- [ ] Scaffold result tags agntc.json as \"overwritten\" when it was overwritten\n- [ ] Overwritten agntc.json contains only {\"agents\": [...]} from current selections (full replace)\n- [ ] Works for all three types: skill, plugin, collection\n- [ ] For collection, my-plugin/agntc.json is the file overwritten (not a root agntc.json)\n\n**Tests**:\n- \"scaffoldSkill overwrites agntc.json when reconfigure is true\" -- pre-create agntc.json with old content, scaffold with reconfigure: true, verify new content written\n- \"scaffoldSkill skips SKILL.md even in reconfigure mode\" -- pre-create both files, scaffold with reconfigure: true, verify SKILL.md unchanged\n- \"scaffoldSkill reports agntc.json as overwritten\" -- verify overwritten array contains \"agntc.json\"\n- \"scaffoldSkill in fresh mode is unchanged\" -- reconfigure: false, verify identical to Phase 1 behavior\n- \"scaffoldPlugin overwrites agntc.json when reconfigure is true\" -- pre-create plugin structure, scaffold with reconfigure: true, verify agntc.json updated and others unchanged\n- \"scaffoldCollection overwrites my-plugin/agntc.json when reconfigure is true\" -- pre-create collection structure, scaffold with reconfigure: true, verify my-plugin/agntc.json updated\n- \"overwritten agntc.json is full replace not merge\" -- pre-create with {\"agents\":[\"claude\"]}, reconfigure with [\"codex\"], verify content is {\"agents\":[\"codex\"]}\n- \"fresh mode returns empty overwritten array\" -- scaffold with reconfigure: false, verify overwritten is []\n\n**Edge Cases**:\n- Type changes from skill to plugin on reconfigure: agntc.json overwritten, new directories created, old SKILL.md at root remains (not managed by plugin scaffold path)\n- For collection reconfigure: my-plugin/agntc.json is overwritten, root remains free of agntc.json\n\n**Spec Reference**: .workflows/specification/plugin-authoring/specification.md -- Step 5: Scaffold","parent":"tick-5c139e","created":"2026-02-22T21:33:24Z","updated":"2026-02-23T13:57:18Z","closed":"2026-02-23T13:57:18Z"}
{"id":"tick-1010d8","title":"Output report distinguishes overwritten from created and skipped","status":"done","priority":2,"description":"**Problem**: The scaffold output report (from Phase 1/2) shows files as \"created\" or \"skipped\". With reconfigure mode introducing a third status -- \"overwritten\" -- the report needs to visually distinguish all three states.\n\n**Solution**: Update the output report rendering to handle the \"overwritten\" status alongside \"created\" and \"skipped\". Each status gets a distinct visual indicator in the @clack/prompts output.\n\n**Outcome**: After a reconfigure run, the user sees a clear report where agntc.json is marked as \"overwritten\", new files as \"created\", and existing files as \"skipped\".\n\n**Do**:\n- Locate output report rendering logic (from Phase 1/2)\n- Add handling for \"overwritten\" status with distinct visual marker:\n  - created: green/positive indicator\n  - skipped: dim/neutral indicator with \"(skipped)\" label\n  - overwritten: yellow/warning indicator with \"(overwritten)\" label\n- Ensure fresh mode works (no overwritten entries)\n- Ensure reconfigure mode works with mixed statuses\n- Report entries appear in scaffold processing order\n- Create tests/init/scaffold-report.test.ts\n\n**Acceptance Criteria**:\n- [ ] \"created\" files displayed with creation indicator\n- [ ] \"skipped\" files displayed with skip indicator and label\n- [ ] \"overwritten\" files displayed with overwrite indicator and label\n- [ ] All three statuses visually distinguishable\n- [ ] Fresh-run reports render correctly (no overwritten)\n- [ ] Reconfigure reports with mixed statuses render correctly\n- [ ] Works for all three types: skill, plugin, collection\n- [ ] Report entries in scaffold processing order\n\n**Edge Cases**:\n- Mixed report with overwritten, skipped, and created in same run (typical reconfigure scenario)\n\n**Tests**:\n- \"renders created files with creation indicator\" -- pass result with created entries, verify output contains the positive indicator\n- \"renders skipped files with skip indicator and label\" -- pass result with skipped entries, verify \"(skipped)\" label present\n- \"renders overwritten files with overwrite indicator and label\" -- pass result with overwritten entries, verify \"(overwritten)\" label present\n- \"all three statuses are visually distinguishable\" -- pass result with all three statuses, verify each uses a different indicator\n- \"fresh-run report has no overwritten section\" -- pass result with empty overwritten array, verify no overwrite indicator in output\n- \"reconfigure report renders mixed statuses correctly\" -- pass result with one overwritten, one skipped, one created; verify all three appear with correct labels\n- \"works for skill type scaffold result\" -- pass a skill-shaped result, verify rendering\n- \"works for plugin type scaffold result\" -- pass a plugin-shaped result with directories, verify rendering\n- \"report entries appear in scaffold processing order\" -- pass result with specific ordering, verify output preserves order\n\n**Spec Reference**: .workflows/specification/plugin-authoring/specification.md -- Step 5: Scaffold","parent":"tick-5c139e","created":"2026-02-22T21:33:36Z","updated":"2026-02-23T14:09:19Z","closed":"2026-02-23T14:09:19Z"}
{"id":"tick-fa5a7a","title":"Phase 4: Analysis Refinements","status":"done","priority":2,"parent":"tick-5ae939","created":"2026-02-23T14:21:02Z","updated":"2026-02-23T14:50:20Z","closed":"2026-02-23T14:50:20Z"}
{"id":"tick-aae765","title":"Extract shared scaffold utilities (template, pathExists, ScaffoldResult)","status":"done","priority":2,"description":"**Problem**: Three independently-authored scaffold modules each define their own copy of: (1) SKILL_MD_TEMPLATE -- an identical 10-line string literal in scaffold-skill.ts, scaffold-plugin.ts, and scaffold-collection.ts; (2) pathExists/fileExists -- an identical async fs.access wrapper (named fileExists in scaffold-skill.ts, pathExists in the other two); (3) ScaffoldResult/ScaffoldPluginResult/ScaffoldCollectionResult -- three structurally identical interfaces. format-report.ts imports ScaffoldResult from scaffold-skill.ts specifically, creating an arbitrary coupling. The orchestrator (init.ts:53) also defines the same shape inline as a return type.\n\n**Solution**: Create two shared modules: `src/init/templates.ts` exporting SKILL_MD_TEMPLATE, and `src/init/scaffold-utils.ts` exporting pathExists and the ScaffoldResult interface. All three scaffold files and format-report.ts import from these shared locations. Remove the per-file duplicate declarations.\n\n**Outcome**: SKILL_MD_TEMPLATE, pathExists, and ScaffoldResult each have a single definition. The three scaffold modules and format-report.ts import from the shared locations. Approximately 50 lines of duplicated declarations eliminated. Future changes to the template or result shape need only be made in one place.\n\n**Do**:\n1. Create `src/init/templates.ts` exporting `SKILL_MD_TEMPLATE`\n2. Create `src/init/scaffold-utils.ts` exporting `pathExists` (the async fs.access wrapper) and `ScaffoldResult` interface (`{ created: string[]; skipped: string[]; overwritten: string[] }`)\n3. In `src/init/scaffold-skill.ts`: remove local SKILL_MD_TEMPLATE, fileExists, and ScaffoldResult. Import SKILL_MD_TEMPLATE from `./templates.js`, pathExists and ScaffoldResult from `./scaffold-utils.js`. Change the function to use `pathExists` instead of `fileExists`. Update the export to re-export ScaffoldResult if needed for backward compatibility, or update all consumers.\n4. In `src/init/scaffold-plugin.ts`: remove local SKILL_MD_TEMPLATE, pathExists, and ScaffoldPluginResult. Import from the shared modules. Change return type to `ScaffoldResult`.\n5. In `src/init/scaffold-collection.ts`: remove local SKILL_MD_TEMPLATE, pathExists, and ScaffoldCollectionResult. Import from the shared modules. Change return type to `ScaffoldResult`.\n6. In `src/init/format-report.ts`: change import to `import type { ScaffoldResult } from \"./scaffold-utils.js\"`\n7. In `src/commands/init.ts`: replace the inline return type on the `scaffold` function (line 53) with `Promise\u003cScaffoldResult\u003e`, importing from `./scaffold-utils.js`\n8. Verify all tests pass -- update any test imports if they reference the old per-file types\n\n**Acceptance Criteria**:\n- SKILL_MD_TEMPLATE is defined in exactly one file (`src/init/templates.ts`)\n- pathExists is defined in exactly one file (`src/init/scaffold-utils.ts`)\n- ScaffoldResult is defined in exactly one file (`src/init/scaffold-utils.ts`)\n- All three scaffold functions return the same `ScaffoldResult` type\n- format-report.ts imports ScaffoldResult from the shared location\n- No behavioral changes -- all existing tests pass\n\n**Tests**:\n- Existing scaffold-skill, scaffold-plugin, and scaffold-collection tests pass without behavioral changes\n- Existing format-report tests pass with updated imports\n- TypeScript compilation succeeds with no errors","parent":"tick-fa5a7a","created":"2026-02-23T14:21:02Z","updated":"2026-02-23T14:37:37Z","closed":"2026-02-23T14:37:37Z"}
{"id":"tick-a68a2f","title":"Compose scaffoldCollection with scaffoldPlugin","status":"done","priority":2,"description":"**Problem**: scaffoldCollection (scaffold-collection.ts:32-85) independently reimplements the same file-creation logic as scaffoldPlugin -- agntc.json write-or-skip-or-overwrite, skills/my-skill/SKILL.md creation, agents/ mkdir, hooks/ mkdir -- with all paths prefixed by `my-plugin/`. The two functions share approximately 80% of their logic. The plan explicitly states \"Collection is just Plugin nested inside a named directory with no root agntc.json.\" This violates the compositional relationship: when one concept is a wrapper of another, it should delegate rather than reimplement.\n\n**Solution**: Have scaffoldCollection delegate to scaffoldPlugin by calling `scaffoldPlugin(join(dir, 'my-plugin'), agents, options)` and then prefix all returned paths with `my-plugin/`. The collection function also needs to create the `my-plugin/` directory before delegating. This eliminates ~50 lines of duplicated scaffold logic.\n\n**Outcome**: scaffoldCollection is a thin wrapper (~10 lines) that creates the `my-plugin/` directory, delegates to scaffoldPlugin, and prefixes the returned paths. Changes to the scaffolded plugin structure (e.g., adding new starter files) only need to be made in scaffoldPlugin.\n\n**Do**:\n1. In `src/init/scaffold-collection.ts`, replace the current implementation with:\n   - Create `my-plugin/` directory with `mkdir(join(dir, 'my-plugin'), { recursive: true })`\n   - Call `scaffoldPlugin(join(dir, 'my-plugin'), agents, options)`\n   - Map the returned `created`, `skipped`, and `overwritten` arrays to prefix each entry with `my-plugin/`\n   - Return the prefixed result\n2. Remove the now-unused local imports (access, writeFile if no longer needed) -- keep mkdir and join\n3. Import `scaffoldPlugin` from `./scaffold-plugin.js`\n4. Remove imports of SKILL_MD_TEMPLATE and pathExists from scaffold-collection.ts (they are no longer needed directly)\n5. Verify all scaffold-collection tests pass -- the external behavior (returned paths, created files) should be identical\n6. Verify the init command's scaffold dispatch still works correctly for collection type\n\n**Acceptance Criteria**:\n- scaffoldCollection delegates to scaffoldPlugin instead of reimplementing the logic\n- All returned paths are correctly prefixed with `my-plugin/`\n- scaffoldCollection handles `reconfigure` correctly by passing options through\n- All existing scaffold-collection tests pass with identical assertions\n- All init command tests pass\n\n**Tests**:\n- Existing scaffold-collection tests verify the same files are created on disk\n- Existing scaffold-collection tests verify the same paths appear in created/skipped/overwritten arrays\n- Test that reconfigure mode still overwrites `my-plugin/agntc.json` correctly\n- Test that skip-if-exists behavior is preserved for all files","parent":"tick-fa5a7a","created":"2026-02-23T14:21:02Z","updated":"2026-02-23T14:41:13Z","closed":"2026-02-23T14:41:13Z"}
{"id":"tick-d69180","title":"Unify scaffold function signatures","status":"done","priority":2,"description":"**Problem**: scaffoldSkill takes a single options object `{ agents, targetDir, reconfigure? }`, while scaffoldPlugin and scaffoldCollection take positional parameters `(dir, agents, options?)`. These three functions serve the same architectural role and are called from the same dispatch site in init.ts (lines 54-70). The inconsistency forces the orchestrator to use two different calling conventions and prevents the scaffold dispatch from being simplified to a uniform call pattern.\n\n**Solution**: Unify all three scaffold functions to use the options-object pattern from scaffoldSkill: `{ agents, targetDir, reconfigure? }`. The options-object pattern is preferable because it makes call sites self-documenting with named fields.\n\n**Outcome**: All three scaffold functions accept the same signature shape. The init.ts orchestrator can call all three with an identical argument structure, simplifying the dispatch logic.\n\n**Do**:\n1. In `src/init/scaffold-plugin.ts`, change the function signature from `scaffoldPlugin(dir, agents, options?)` to `scaffoldPlugin(options: { agents: AgentId[]; targetDir: string; reconfigure?: boolean })`. Update the function body to destructure from the options object.\n2. In `src/init/scaffold-collection.ts`, change the function signature from `scaffoldCollection(dir, agents, options?)` to `scaffoldCollection(options: { agents: AgentId[]; targetDir: string; reconfigure?: boolean })`. Update the function body to destructure from the options object. (If Task 2 has been applied, this means updating the delegation call accordingly.)\n3. In `src/commands/init.ts`, update the scaffold dispatch to use the unified signature for all three functions. The two calling conventions (lines 56-70) can collapse into a single pattern.\n4. Update all test files that call scaffoldPlugin or scaffoldCollection directly to use the new signature\n5. Verify all tests pass\n\n**Acceptance Criteria**:\n- All three scaffold functions accept `{ agents, targetDir, reconfigure? }`\n- The init.ts orchestrator uses one calling convention for all three\n- All existing tests pass with updated call signatures\n\n**Tests**:\n- Existing scaffold-plugin tests pass with updated call syntax\n- Existing scaffold-collection tests pass with updated call syntax\n- Existing init command tests pass","parent":"tick-fa5a7a","created":"2026-02-23T14:21:02Z","updated":"2026-02-23T14:47:30Z","closed":"2026-02-23T14:47:30Z"}
{"id":"tick-1ec0c0","title":"Tighten Partial\u003cRecord\u003e to Record in preview-confirm","status":"done","priority":2,"description":"**Problem**: In `src/init/preview-confirm.ts:4`, `filesByType` is typed as `Partial\u003cRecord\u003cInitType, string[]\u003e\u003e` even though all three InitType variants (skill, plugin, collection) are present in the literal. This introduces an unnecessary `undefined` possibility, forcing the runtime guard on line 30 (`if (!files)`) and an error path (`Init type \"${options.type}\" is not yet supported`) that can never be reached in practice. Using `Partial` is unnecessarily abstract when the record is complete.\n\n**Solution**: Change the type to `Record\u003cInitType, string[]\u003e` and remove the unreachable guard/error.\n\n**Outcome**: The type accurately reflects the data (all variants present). The compiler will enforce completeness if a new InitType variant is added in the future. The unreachable error path is eliminated.\n\n**Do**:\n1. In `src/init/preview-confirm.ts:4`, change `Partial\u003cRecord\u003cInitType, string[]\u003e\u003e` to `Record\u003cInitType, string[]\u003e`\n2. Remove the `if (!files)` guard and the associated `throw new Error(...)` on lines 30-31, since `files` is now guaranteed to be defined\n3. Verify TypeScript compilation succeeds\n4. Verify all existing tests pass\n\n**Acceptance Criteria**:\n- `filesByType` is typed as `Record\u003cInitType, string[]\u003e`\n- No unreachable error path for unsupported init types\n- TypeScript compilation succeeds\n- All existing tests pass\n\n**Tests**:\n- Existing preview-confirm tests pass without modification\n- TypeScript compilation verifies completeness (adding a new InitType variant without updating filesByType would cause a compile error)","parent":"tick-fa5a7a","created":"2026-02-23T14:21:02Z","updated":"2026-02-23T14:50:15Z","closed":"2026-02-23T14:50:15Z"}
{"id":"tick-7b1bb7","title":"Phase 5: Analysis Refinements (Cycle 2)","status":"in_progress","priority":2,"parent":"tick-5ae939","created":"2026-02-23T14:56:22Z","updated":"2026-02-23T14:57:55Z"}
{"id":"tick-fbd2f9","title":"Extract agntc.json write-or-skip-or-overwrite helper into scaffold-utils","status":"done","priority":2,"description":"**Problem**: scaffold-skill.ts (lines 18-31) and scaffold-plugin.ts (lines 17-30) contain a near-identical 14-line block that builds agntc.json content, checks existence via pathExists, branches on reconfigure to decide overwrite/skip/create, and pushes to the appropriate result array. If the agntc.json schema changes, both must be updated in lockstep. This was identified in cycle 1 but the fixes addressed other duplication without extracting this specific block.\\n\\n**Solution**: Extract a helper function `writeConfigFile` into `src/init/scaffold-utils.ts` that encapsulates the full check-write-classify flow for agntc.json. Both scaffoldSkill and scaffoldPlugin call it and push to result arrays based on the returned status.\\n\\n**Outcome**: The agntc.json write logic exists in exactly one place. Both scaffold functions delegate to it, reducing each by ~14 lines and making the config schema a single-point-of-change.\\n\\n**Do**:\\n1. In `src/init/scaffold-utils.ts`, add an exported async function `writeConfigFile(targetDir: string, agents: AgentId[], reconfigure?: boolean): Promise\u003c{ path: string; status: \"created\" | \"skipped\" | \"overwritten\" }\u003e`.\\n2. Move the agntc.json build + pathExists check + reconfigure branching + writeFile logic into this function.\\n3. The function returns `{ path: \"agntc.json\", status }` where status reflects what happened.\\n4. In `src/init/scaffold-skill.ts`, replace lines 18-31 with a call to `writeConfigFile(options.targetDir, options.agents, options.reconfigure)` and push to the appropriate result array based on the returned status.\\n5. In `src/init/scaffold-plugin.ts`, replace lines 17-30 with a call to `writeConfigFile(targetDir, agents, reconfigure)` and push to the appropriate result array based on the returned status.\\n6. Ensure `writeFile` and `join` imports are added to scaffold-utils.ts and removed from scaffold-skill.ts / scaffold-plugin.ts if no longer needed.\\n7. Run `pnpm test` to confirm all existing tests pass.\\n\\n**Acceptance Criteria**:\\n- `writeConfigFile` is exported from `src/init/scaffold-utils.ts`\\n- `scaffold-skill.ts` and `scaffold-plugin.ts` both call `writeConfigFile` instead of inline logic\\n- No inline agntc.json write-or-skip-or-overwrite logic remains in either scaffold function\\n- All existing tests pass without modification\\n\\n**Tests**:\\n- Existing scaffold-skill and scaffold-plugin tests continue to pass (fresh create, skip-if-exists, reconfigure overwrite)\\n- Unit test for writeConfigFile: returns `{ path: \"agntc.json\", status: \"created\" }` when file does not exist\\n- Unit test for writeConfigFile: returns `{ path: \"agntc.json\", status: \"skipped\" }` when file exists and reconfigure is false/undefined\\n- Unit test for writeConfigFile: returns `{ path: \"agntc.json\", status: \"overwritten\" }` when file exists and reconfigure is true","parent":"tick-7b1bb7","created":"2026-02-23T14:56:42Z","updated":"2026-02-23T15:02:38Z","closed":"2026-02-23T15:02:38Z"}
{"id":"tick-d64cc1","title":"Use pathExists from scaffold-utils in pre-check.ts","status":"done","priority":2,"description":"**Problem**: `src/init/pre-check.ts` (lines 13-17) uses a raw `access(configPath)` wrapped in try/catch to test file existence -- the exact same pattern exported as `pathExists` from `src/init/scaffold-utils.ts`. The shared utility was introduced specifically for this purpose but pre-check was not updated to use it. Having two filesystem-existence patterns in the same feature module undermines the purpose of the shared utility.\\n\\n**Solution**: Import `pathExists` from `./scaffold-utils.js` in pre-check.ts and replace the inline try/catch with a one-line call.\\n\\n**Outcome**: All file-existence checks in the init feature use the shared `pathExists` utility. The inline try/catch pattern is eliminated from pre-check.ts.\\n\\n**Do**:\\n1. In `src/init/pre-check.ts`, add `import { pathExists } from \"./scaffold-utils.js\";` to the imports.\\n2. Remove the `import { access } from \"node:fs/promises\";` import (no longer needed).\\n3. Replace lines 13-17 (the try/catch block around `access(configPath)`) with: `if (\\!(await pathExists(configPath))) { return { status: \"fresh\" }; }`\\n4. Run `pnpm test` to confirm all existing tests pass.\\n\\n**Acceptance Criteria**:\\n- pre-check.ts imports `pathExists` from `./scaffold-utils.js`\\n- pre-check.ts no longer imports `access` from `node:fs/promises`\\n- No inline try/catch around `access()` remains in pre-check.ts\\n- All existing tests pass without modification\\n\\n**Tests**:\\n- Existing pre-check tests continue to pass (fresh directory returns \"fresh\", existing config triggers reconfigure prompt)","parent":"tick-7b1bb7","created":"2026-02-23T14:56:53Z","updated":"2026-02-23T15:05:40Z","closed":"2026-02-23T15:05:40Z"}
{"id":"tick-9a674c","title":"Remove allowExcessArguments from init command","status":"open","priority":2,"description":"**Problem**: The init command definition in `src/commands/init.ts` (line 70) uses `.allowExcessArguments(true)`, which silently accepts extra positional arguments (e.g., `npx agntc init foo bar` succeeds without error). The specification states \"No arguments. No flags.\" and Commander's default behavior (`allowExcessArguments(false)`) already enforces this. No other command in the project uses `allowExcessArguments(true)`. This contradicts the spec's acceptance criteria.\\n\\n**Solution**: Remove `.allowExcessArguments(true)` from the init command definition. Commander's default behavior will reject excess arguments, matching the spec.\\n\\n**Outcome**: `npx agntc init foo` produces a Commander error about excess arguments, conforming to the spec requirement of no arguments and no flags.\\n\\n**Do**:\\n1. In `src/commands/init.ts`, remove `.allowExcessArguments(true)` from the command chain on line 70.\\n2. Run `pnpm test` to confirm all existing tests pass.\\n\\n**Acceptance Criteria**:\\n- The init command definition does not include `.allowExcessArguments(true)`\\n- Commander rejects excess positional arguments with its default error behavior\\n- All existing tests pass without modification\\n\\n**Tests**:\\n- Existing init command tests continue to pass\\n- Manual verification: running the built CLI with `npx agntc init extra-arg` produces a Commander error","parent":"tick-7b1bb7","created":"2026-02-23T14:57:03Z","updated":"2026-02-23T14:57:03Z"}
