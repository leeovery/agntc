{"id":"tick-20aa13","title":"Core System","status":"open","priority":2,"created":"2026-02-18T20:38:55Z","updated":"2026-02-18T20:38:55Z"}
{"id":"tick-dea5ee","title":"Phase 1: Walking Skeleton - Add a Bare Skill from Git","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-18T20:39:00Z","updated":"2026-02-18T20:39:00Z"}
{"id":"tick-0ba43c","title":"cs-1-1: Project Scaffolding and CLI Entry Point","status":"open","priority":2,"description":"**Problem**: The agntc repo has no TypeScript setup, no build tooling, no test framework, and no CLI entry point. Every subsequent task depends on this.\n\n**Solution**: Scaffold a TypeScript project with tsup for bundling, Vitest for testing, and Commander for CLI argument parsing. Create the bin entry point with add and list as subcommand stubs.\n\n**Outcome**: A buildable, testable TypeScript project where npx agntc add owner/repo and npx agntc list print placeholders, help works, unknown commands error, and Vitest runs.\n\n**Do**:\n1. Create tsconfig.json — ES2022/NodeNext, strict mode, rootDir src/, outDir dist/\n2. Install deps: typescript, tsup, vitest (dev); commander, @clack/prompts (runtime)\n3. Update package.json — type: module, bin: { \"agntc\": \"dist/cli.js\" }, scripts for build/test\n4. Create tsup.config.ts — entry src/cli.ts, format esm, target node20, dts, shebang banner\n5. Create src/cli.ts — Commander program with add (required \u003csource\u003e arg) and list subcommands\n6. Create src/index.ts — empty barrel export\n7. Create src/commands/add.ts — stub with @clack/prompts intro/outro\n8. Create src/commands/list.ts — stub with @clack/prompts intro/outro\n9. Create vitest.config.ts\n10. Create tests/cli.test.ts — smoke tests for CLI wiring\n11. Ensure .gitignore covers dist/ and node_modules/\n12. Build and verify\n\n**Acceptance Criteria**:\n- npm run build produces dist/cli.js with shebang, executable\n- npx agntc --help shows help listing add and list\n- npx agntc add owner/repo exits 0 with placeholder output\n- npx agntc add (no source) exits non-zero\n- npx agntc list exits 0 with placeholder output\n- npx agntc (no command) shows help\n- npx agntc unknown-command exits non-zero\n- npm test runs vitest, all tests pass\n- package.json bin field points to dist/cli.js\n- TypeScript strict mode enabled\n\n**Tests**:\n- npx agntc --help includes add and list in output\n- npx agntc add \u003csource\u003e exits 0 and outputs placeholder message\n- npx agntc add with no source argument exits non-zero\n- npx agntc list exits 0 and outputs placeholder message\n- npx agntc with no arguments shows help\n- npx agntc with unknown command exits non-zero\n- build produces dist/cli.js with node shebang\n\n**Context**: Naming spec mandates agntc as CLI command and package name. Spec requires Commander + @clack/prompts. Phase 1 only stubs add and list — remove and update come later.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:39:09Z","updated":"2026-02-18T20:39:09Z"}
{"id":"tick-be4c96","title":"cs-1-2: Source Argument Parsing (GitHub Shorthand)","status":"open","priority":2,"description":"**Problem**: The add command receives a raw string but needs structured data (owner, repo, ref) for downstream operations (clone, manifest key).\n\n**Solution**: Create a parseSource function returning a typed ParsedSource object with a type: \"github-shorthand\" discriminant for future union extension in Phase 3.\n\n**Outcome**: Tested parser that extracts owner, repo, and optional ref from owner/repo and owner/repo@ref, rejects malformed input with descriptive errors.\n\n**Do**:\n1. Create src/source-parser.ts with ParsedSource type (type, owner, repo, ref, manifestKey)\n2. Implement parseSource(raw) — trim, split on first @, split on /, validate segments\n3. Throw descriptive errors for: missing owner/repo, empty owner, empty repo, empty ref, extra slashes, empty string\n4. Create tests/source-parser.test.ts with all edge case tests\n5. Wire into src/commands/add.ts — call parseSource on source arg\n\n**Acceptance Criteria**:\n- parseSource(\"owner/repo\") returns { type: \"github-shorthand\", owner: \"owner\", repo: \"repo\", ref: null, manifestKey: \"owner/repo\" }\n- parseSource(\"owner/repo@v2.0\") returns ref: \"v2.0\"\n- parseSource(\"owner/repo@main\") returns ref: \"main\"\n- parseSource(\"repo\") throws with descriptive error (missing owner)\n- parseSource(\"/repo\") throws with descriptive error (empty owner)\n- parseSource(\"owner/\") throws with descriptive error (empty repo)\n- parseSource(\"owner/repo@\") throws with descriptive error (empty ref)\n- parseSource(\"a/b/c\") throws with descriptive error (extra slashes)\n- parseSource(\"\") throws with descriptive error\n- The add command calls parseSource on its source argument\n\n**Tests**:\n- parses owner/repo into structured source with null ref\n- parses owner/repo@ref with tag ref\n- parses owner/repo@ref with branch name ref\n- returns manifestKey as owner/repo\n- trims whitespace from input\n- throws for missing owner segment (bare repo name)\n- throws for empty owner (leading slash)\n- throws for empty repo (trailing slash)\n- throws for empty ref after @ symbol\n- throws for extra slashes in path (three segments)\n- throws for empty string input\n- handles ref containing special characters (e.g., v2.0.0-beta.1)\n- splits on first @ only — ref can contain @ characters\n\n**Context**: Phase 1 implements GitHub shorthand only. The ParsedSource type uses a discriminant so Phase 3 can extend it as a union type. Manifest key is owner/repo; collection suffixes appended downstream. ref: null means HEAD.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:46:55Z","updated":"2026-02-18T20:46:55Z"}
