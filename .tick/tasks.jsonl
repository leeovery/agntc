{"id":"tick-20aa13","title":"Core System","status":"open","priority":2,"created":"2026-02-18T20:38:55Z","updated":"2026-02-18T20:38:55Z"}
{"id":"tick-dea5ee","title":"Phase 1: Walking Skeleton - Add a Bare Skill from Git","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-18T20:39:00Z","updated":"2026-02-18T20:39:00Z"}
{"id":"tick-0ba43c","title":"cs-1-1: Project Scaffolding and CLI Entry Point","status":"open","priority":2,"description":"**Problem**: The agntc repo has no TypeScript setup, no build tooling, no test framework, and no CLI entry point. Every subsequent task depends on this.\n\n**Solution**: Scaffold a TypeScript project with tsup for bundling, Vitest for testing, and Commander for CLI argument parsing. Create the bin entry point with add and list as subcommand stubs.\n\n**Outcome**: A buildable, testable TypeScript project where npx agntc add owner/repo and npx agntc list print placeholders, help works, unknown commands error, and Vitest runs.\n\n**Do**:\n1. Create tsconfig.json — ES2022/NodeNext, strict mode, rootDir src/, outDir dist/\n2. Install deps: typescript, tsup, vitest (dev); commander, @clack/prompts (runtime)\n3. Update package.json — type: module, bin: { \"agntc\": \"dist/cli.js\" }, scripts for build/test\n4. Create tsup.config.ts — entry src/cli.ts, format esm, target node20, dts, shebang banner\n5. Create src/cli.ts — Commander program with add (required \u003csource\u003e arg) and list subcommands\n6. Create src/index.ts — empty barrel export\n7. Create src/commands/add.ts — stub with @clack/prompts intro/outro\n8. Create src/commands/list.ts — stub with @clack/prompts intro/outro\n9. Create vitest.config.ts\n10. Create tests/cli.test.ts — smoke tests for CLI wiring\n11. Ensure .gitignore covers dist/ and node_modules/\n12. Build and verify\n\n**Acceptance Criteria**:\n- npm run build produces dist/cli.js with shebang, executable\n- npx agntc --help shows help listing add and list\n- npx agntc add owner/repo exits 0 with placeholder output\n- npx agntc add (no source) exits non-zero\n- npx agntc list exits 0 with placeholder output\n- npx agntc (no command) shows help\n- npx agntc unknown-command exits non-zero\n- npm test runs vitest, all tests pass\n- package.json bin field points to dist/cli.js\n- TypeScript strict mode enabled\n\n**Tests**:\n- npx agntc --help includes add and list in output\n- npx agntc add \u003csource\u003e exits 0 and outputs placeholder message\n- npx agntc add with no source argument exits non-zero\n- npx agntc list exits 0 and outputs placeholder message\n- npx agntc with no arguments shows help\n- npx agntc with unknown command exits non-zero\n- build produces dist/cli.js with node shebang\n\n**Context**: Naming spec mandates agntc as CLI command and package name. Spec requires Commander + @clack/prompts. Phase 1 only stubs add and list — remove and update come later.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:39:09Z","updated":"2026-02-18T20:39:09Z"}
{"id":"tick-be4c96","title":"cs-1-2: Source Argument Parsing (GitHub Shorthand)","status":"open","priority":2,"description":"**Problem**: The add command receives a raw string but needs structured data (owner, repo, ref) for downstream operations (clone, manifest key).\n\n**Solution**: Create a parseSource function returning a typed ParsedSource object with a type: \"github-shorthand\" discriminant for future union extension in Phase 3.\n\n**Outcome**: Tested parser that extracts owner, repo, and optional ref from owner/repo and owner/repo@ref, rejects malformed input with descriptive errors.\n\n**Do**:\n1. Create src/source-parser.ts with ParsedSource type (type, owner, repo, ref, manifestKey)\n2. Implement parseSource(raw) — trim, split on first @, split on /, validate segments\n3. Throw descriptive errors for: missing owner/repo, empty owner, empty repo, empty ref, extra slashes, empty string\n4. Create tests/source-parser.test.ts with all edge case tests\n5. Wire into src/commands/add.ts — call parseSource on source arg\n\n**Acceptance Criteria**:\n- parseSource(\"owner/repo\") returns { type: \"github-shorthand\", owner: \"owner\", repo: \"repo\", ref: null, manifestKey: \"owner/repo\" }\n- parseSource(\"owner/repo@v2.0\") returns ref: \"v2.0\"\n- parseSource(\"owner/repo@main\") returns ref: \"main\"\n- parseSource(\"repo\") throws with descriptive error (missing owner)\n- parseSource(\"/repo\") throws with descriptive error (empty owner)\n- parseSource(\"owner/\") throws with descriptive error (empty repo)\n- parseSource(\"owner/repo@\") throws with descriptive error (empty ref)\n- parseSource(\"a/b/c\") throws with descriptive error (extra slashes)\n- parseSource(\"\") throws with descriptive error\n- The add command calls parseSource on its source argument\n\n**Tests**:\n- parses owner/repo into structured source with null ref\n- parses owner/repo@ref with tag ref\n- parses owner/repo@ref with branch name ref\n- returns manifestKey as owner/repo\n- trims whitespace from input\n- throws for missing owner segment (bare repo name)\n- throws for empty owner (leading slash)\n- throws for empty repo (trailing slash)\n- throws for empty ref after @ symbol\n- throws for extra slashes in path (three segments)\n- throws for empty string input\n- handles ref containing special characters (e.g., v2.0.0-beta.1)\n- splits on first @ only — ref can contain @ characters\n\n**Context**: Phase 1 implements GitHub shorthand only. The ParsedSource type uses a discriminant so Phase 3 can extend it as a union type. Manifest key is owner/repo; collection suffixes appended downstream. ref: null means HEAD.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:46:55Z","updated":"2026-02-18T20:46:55Z"}
{"id":"tick-3dff00","title":"cs-1-3: Git Shallow Clone","status":"open","priority":2,"description":"**Problem**: After parsing the source argument, the tool needs to fetch repo contents to a local temp directory before reading agntc.json or copying assets. No clone infrastructure exists yet.\n\n**Solution**: Create a cloneSource function that takes a ParsedSource, creates a temp directory, performs a shallow git clone (depth 1), and returns the temp dir path + resolved commit SHA. Retries transient failures, aborts immediately on auth errors, cleans up temp dir on failure.\n\n**Outcome**: Tested clone module that shallow-clones GitHub repos to temp dirs, retries transient failures up to 3 times, aborts on auth errors, cleans up on failure, returns temp path + commit SHA on success.\n\n**Do**:\n1. Create src/git-clone.ts with CloneResult type ({ tempDir, commit }) and cloneSource(parsed: ParsedSource) async function\n2. Build clone URL as https://github.com/{owner}/{repo}.git from ParsedSource fields\n3. Create temp dir using fs.mkdtemp(os.tmpdir() + '/agntc-')\n4. Shell out to git clone --depth 1 [--branch ref] \u003curl\u003e \u003ctempDir\u003e via child_process.execFile. ref null = omit --branch (HEAD). ref provided = --branch \u003cref\u003e.\n5. On success, resolve commit SHA via git -C \u003ctempDir\u003e rev-parse HEAD\n6. Return { tempDir, commit }\n7. Retry logic: max 3 attempts. Auth errors (exit 128 + stderr contains Authentication, Permission denied, could not read Username/Password) throw immediately. Otherwise retry with delay (500ms, 1000ms).\n8. On final failure, clean up temp dir (fs.rm recursive+force) before throwing\n9. Create tests/git-clone.test.ts — mock execFile for retry/auth/URL/ref/cleanup tests. Optional integration test behind RUN_INTEGRATION=1.\n10. Export cleanupTempDir(path) helper for callers. Thin wrapper around fs.rm recursive+force.\n\n**Acceptance Criteria**:\n- cloneSource constructs URL as https://github.com/{owner}/{repo}.git\n- ref: null clones HEAD (no --branch flag)\n- ref: \"v2.0\" passes --branch v2.0\n- Clone uses --depth 1 (shallow)\n- Returns { tempDir, commit } where commit is 40-char hex SHA\n- Temp dir under os.tmpdir() with agntc- prefix\n- Transient failures retried up to 3 times\n- Auth failures throw immediately, no retry\n- Temp dir cleaned up on failure (retries exhausted or auth error)\n- Temp dir NOT cleaned up on success (caller responsibility)\n- cleanupTempDir removes directory recursively\n- Error messages surface underlying git error clearly\n\n**Tests**:\n- constructs correct clone URL from owner and repo\n- calls git clone with --depth 1\n- omits --branch when ref is null\n- passes --branch \u003cref\u003e when ref is provided\n- returns tempDir and 40-char commit SHA on success\n- creates temp dir with agntc- prefix\n- retries up to 3 times on transient failure then throws\n- succeeds on second attempt after transient failure\n- does not retry on auth failure (throws immediately)\n- detects auth failure from stderr patterns\n- cleans up temp dir after failure\n- does not clean up temp dir on success\n- surfaces git error message in thrown error\n- cleanupTempDir removes directory recursively\n- cleanupTempDir does not throw if dir missing\n- clone failure for nonexistent repo produces clear error\n\n**Context**: Spec says retry 3 times on transient, no retry on auth. Phase 1 = GitHub shorthand only, so URL is always https://github.com/{owner}/{repo}.git. Phase 3 extends for other hosts/formats. Caller owns cleanup on success; cloneSource owns cleanup on failure. Git is a runtime prerequisite — the tool should surface a clear error if git is not found on the system.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:48:56Z","updated":"2026-02-19T10:50:30Z"}
{"id":"tick-5024dd","title":"cs-1-4: agntc.json Validation","status":"open","priority":2,"description":"**Problem**: After cloning a repo, the tool needs to read and validate agntc.json from the repo root. No config reading or validation logic exists yet. Each validation failure mode requires a specific error message per spec. Unknown agent identifiers must warn (not error) to future-proof.\n\n**Solution**: Create a readConfig function that reads agntc.json from a given directory, parses JSON, validates schema (agents field required, non-empty array, valid identifiers), returns typed AgntcConfig. Unknown agents trigger warning callback and are filtered out. Missing file returns null (valid signal for collection detection).\n\n**Outcome**: Tested config module that reads/validates agntc.json, returns null when absent, throws descriptive errors for invalid JSON / missing agents / empty agents, warns on unknown identifiers, returns typed config on success.\n\n**Do**:\n1. Create src/config.ts with types: AgntcConfig ({ agents: string[] }), KNOWN_AGENTS ([\"claude\", \"codex\"]), ReadConfigOptions ({ onWarn? })\n2. Implement readConfig(dir, options?) — read agntc.json, parse JSON, validate agents field, filter unknown agents with warnings, return typed config or null\n3. Error messages per spec: \"Invalid agntc.json: {parse error}\", \"agents field is required\", \"agents must not be empty\"\n4. Unknown agents: warn via onWarn callback, filter out. Return only known agents.\n5. Create ConfigError class (extends Error)\n6. Create tests/config.test.ts covering all validation paths\n7. Export AgntcConfig, KNOWN_AGENTS, readConfig, ConfigError\n\n**Acceptance Criteria**:\n- Returns null when agntc.json does not exist\n- Returns { agents: [\"claude\"] } for valid config\n- Returns { agents: [\"claude\", \"codex\"] } for multi-agent config\n- Throws ConfigError with parse error for malformed JSON\n- Throws ConfigError for missing agents field\n- Throws ConfigError for empty agents array\n- Unknown agents filtered out + onWarn called\n- Returns only known agents when mix of known/unknown\n- Returns empty known agents array when all agents unknown (downstream handles no-valid-agents scenario)\n- KNOWN_AGENTS contains [\"claude\", \"codex\"]\n- Non-ENOENT file errors propagate as-is\n\n**Tests**:\n- returns null when agntc.json does not exist\n- parses valid config with single agent\n- parses valid config with multiple agents\n- throws ConfigError for invalid JSON (truncated)\n- throws ConfigError for invalid JSON (trailing comma)\n- throws ConfigError with parse error detail\n- throws when agents field missing entirely\n- throws when agents is empty array\n- warns for unknown agent and filters it out\n- returns known agents when mix present\n- warns once per unknown agent\n- returns empty known agents when all unknown (warns for each)\n- does not call onWarn when all agents known\n- propagates permission denied errors\n- reads from correct path\n\n**Context**: Spec defines agntc.json as single required config. Missing file = null (type detection uses absence for collection scanning). Naming spec confirms filename is agntc.json.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:50:30Z","updated":"2026-02-19T11:28:59Z"}
{"id":"tick-3f9f32","title":"cs-1-5: Type Detection","status":"open","priority":2,"description":"**Problem**: After reading agntc.json (or discovering its absence), the tool must determine what kind of installable it is looking at — bare skill, plugin, collection, or not an agntc repo. Downstream operations depend on this classification.\n\n**Solution**: Create a detectType function applying the spec's 3-rule cascade: (1) root has agntc.json — check asset dirs vs SKILL.md, (2) no agntc.json — scan subdirs (collection), (3) nothing — not agntc. Returns a typed discriminated union (DetectedType). All paths implemented and tested.\n\n**Outcome**: Tested type detection module classifying directories as bare-skill, plugin, collection, or not-agntc. Warns on misconfigurations.\n\n**Do**:\n1. Create src/type-detection.ts with types: ASSET_DIRS ([\"skills\", \"agents\", \"hooks\"]), DetectedType union (bare-skill, plugin with assetDirs, collection with plugins, not-agntc)\n2. Implement detectType(dir, options?) — hasConfig boolean from caller, onWarn callback\n3. Rule 1 (hasConfig=true): check asset dirs → plugin; check SKILL.md → bare-skill; neither → warn + not-agntc. Warn if SKILL.md coexists with asset dirs.\n4. Rule 2 (hasConfig=false): scan immediate subdirs for agntc.json → collection; none → not-agntc\n5. Use fs.access for existence checks\n6. Create tests/type-detection.test.ts with real temp dir fixtures\n7. Export DetectedType, ASSET_DIRS, detectType\n\n**Acceptance Criteria**:\n- Returns bare-skill when hasConfig=true, SKILL.md exists, no asset dirs\n- Returns plugin with assetDirs when asset dirs found\n- Returns collection with plugin names when subdirs have agntc.json\n- Returns not-agntc when nothing recognisable\n- Returns not-agntc with warning when hasConfig=true but no SKILL.md/asset dirs\n- Warns when SKILL.md coexists with asset dirs\n- Collection scan checks immediate subdirs only (not recursive)\n- ASSET_DIRS = [\"skills\", \"agents\", \"hooks\"]\n\n**Tests**:\n- bare-skill with SKILL.md and no asset dirs\n- bare-skill with non-asset dirs alongside SKILL.md\n- plugin with each individual asset dir\n- plugin with all three asset dirs\n- plugin warns when SKILL.md coexists with asset dirs\n- not-agntc with warning when config but nothing to install\n- collection with multiple subdirs having agntc.json\n- collection skips subdirs without agntc.json\n- not-agntc when no config and no subdirs have config\n- not-agntc for empty directory\n- collection scan ignores files\n- collection scan not recursive\n\n**Context**: Spec defines type detection as structure-based with 3 ordered rules. hasConfig avoids re-reading agntc.json. Collections are structural, not declared.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:52:07Z","updated":"2026-02-18T20:52:07Z"}
{"id":"tick-cc248f","title":"cs-1-6: Agent Driver Interface and Claude Driver","status":"open","priority":2,"description":"**Problem**: The tool needs to ask \"is this agent present?\" and \"where do assets go for this agent?\" but no driver abstraction exists. Spec mandates driver/strategy pattern so adding agents requires only a new driver + registration.\n\n**Solution**: Define AgentDriver TypeScript interface (detect + getTargetDir). Implement Claude driver. Create registry mapping agent IDs to drivers. Detection: project-level first (.claude/), system fallback (which claude, ~/.claude/). Routing: static config map.\n\n**Outcome**: Tested AgentDriver interface, Claude driver with detection/routing, registry. getDriver(\"claude\") → driver, detect(projectDir) → boolean, getTargetDir(assetType) → string | null.\n\n**Do**:\n1. Create src/drivers/types.ts — AgentDriver interface (detect, getTargetDir), AgentId type (\"claude\" | \"codex\")\n2. Create src/drivers/claude-driver.ts — detect: check .claude/ in project → which claude → ~/.claude/. getTargetDir: { skills: \".claude/skills\", agents: \".claude/agents\", hooks: \".claude/hooks\" }, null for unknown.\n3. Create src/drivers/registry.ts — DRIVER_REGISTRY mapping \"claude\" → ClaudeDriver. getDriver(id), getRegisteredAgentIds().\n4. Create tests/drivers/claude-driver.test.ts — mock fs.access and child_process for detection, direct routing tests.\n5. Create tests/drivers/registry.test.ts — registry lookup and registered IDs.\n\n**Acceptance Criteria**:\n- AgentDriver interface with detect(projectDir) and getTargetDir(assetType)\n- AgentId type as \"claude\" | \"codex\"\n- ClaudeDriver.detect: true when .claude/ in project, skips system check on project match\n- ClaudeDriver.detect: fallback to which claude, then ~/.claude/, false when all fail\n- ClaudeDriver.getTargetDir: skills → .claude/skills, agents → .claude/agents, hooks → .claude/hooks, unknown → null\n- getDriver(\"claude\") returns Claude driver\n- getRegisteredAgentIds() returns [\"claude\"]\n- No Codex driver yet (Phase 3)\n\n**Tests**:\n- detect true when .claude/ exists in project\n- detect skips system fallback on project match\n- detect true when which claude succeeds\n- detect true when ~/.claude/ exists\n- detect false when all checks fail\n- detect does not throw on check failures\n- getTargetDir returns correct paths for skills, agents, hooks\n- getTargetDir returns null for unknown asset type\n- registry returns claude driver\n- registry lists registered IDs\n- registry does not contain codex yet\n\n**Context**: Spec: driver/strategy pattern, project-level first + system fallback, cheapest check first. Claude targets per spec table. Codex added Phase 3. KNOWN_AGENTS in config.ts and AgentId in drivers must stay in sync.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:53:49Z","updated":"2026-02-18T20:53:49Z"}
{"id":"tick-e86117","title":"cs-1-7: Agent Multiselect UI","status":"open","priority":2,"description":"**Problem**: After detecting agents (cs-1-6) and reading plugin's declared agents (cs-1-4), need to let user choose which agents to install for. Spec mandates always-shown @clack/prompts multiselect with smart pre-selection and unsupported warnings.\n\n**Solution**: Create selectAgents function taking declared and detected agents, presenting @clack/prompts multiselect of all registered agents. Pre-selection = declared ∩ detected. Unsupported agents get warning hint. Zero selection = cancel.\n\n**Outcome**: Tested agent selection module showing all registered agents, pre-selecting compatible+detected, warning on unsupported, returning AgentId[] or empty on cancel.\n\n**Do**:\n1. Create src/agent-select.ts with selectAgents({ declaredAgents, detectedAgents }) → Promise\u003cAgentId[]\u003e\n2. Get all agents from getRegisteredAgentIds()\n3. Build multiselect options: value (AgentId), label, hint (warning if not declared), initialValue (true if declared AND detected)\n4. Call @clack/prompts multiselect with required: false\n5. Handle clack cancel → return []\n6. Handle zero selection → brief cancel message, return []\n7. Return selected AgentId[]\n8. Create tests/agent-select.test.ts mocking @clack/prompts multiselect\n\n**Acceptance Criteria**:\n- Always shows all registered agents regardless of compatibility\n- Pre-selection = intersection of declared and detected\n- Warning hint on agents not in declared list\n- Clack cancel returns empty array\n- Zero selection returns empty array\n- Valid selection returns AgentId[]\n\n**Tests**:\n- pre-selects declared AND detected agents\n- does not pre-select declared-only agents\n- does not pre-select detected-only agents\n- shows all registered agents\n- warning hint on undeclared agents\n- no hint on declared agents\n- returns empty on cancel\n- returns empty on zero selection\n- returns selected AgentId[] on valid selection\n- correct options shape passed to multiselect\n- handles empty declaredAgents\n- handles empty detectedAgents\n- handles all agents declared and detected\n\n**Context**: Spec: multiselect always shown, never skipped. Pre-selection = plugin declares + agent detected. Unsupported agents still shown with warning. User can always select any agent. Zero = cancel, no error. Options from registry (Phase 1: Claude only; Phase 3 adds Codex).\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:55:16Z","updated":"2026-02-18T20:55:16Z"}
{"id":"tick-601f31","title":"cs-1-8: Bare Skill File Copy","status":"open","priority":2,"description":"**Problem**: After agent selection, the tool has a cloned bare-skill repo, selected agents, and driver routing, but no copy logic. Need to copy skill files to target dirs for each agent.\n\n**Solution**: Create copyBareSkill that for each agent resolves target via getTargetDir(\"skills\"), copies source dir to {targetDir}/{skillName}/ excluding agntc.json, returns copied file paths for manifest.\n\n**Outcome**: Tested copy module that copies bare skill files to each agent's target, excludes agntc.json, creates dirs, returns paths for manifest tracking.\n\n**Do**:\n1. Create src/copy-bare-skill.ts with CopyBareSkillInput and CopyBareSkillResult types\n2. For each agent: getTargetDir(\"skills\") → null = skip. Compute destDir = projectDir/targetDir/skillName. mkdir recursive. Copy all files excluding agntc.json. Track paths.\n3. Use fs.cp recursive, then rm agntc.json from dest if present\n4. Record directory paths with trailing slash for manifest consistency\n5. Create tests/copy-bare-skill.test.ts with real temp dir fixtures\n\n**Acceptance Criteria**:\n- Copies all files from source to {targetDir}/{skillName}/ per agent\n- Excludes agntc.json from copy\n- Creates destination dir recursively if missing\n- Copies to destination (conflict handling in add flow ensures clean destination before copy)\n- Returns copiedFiles with paths relative to projectDir, trailing slash for dirs\n- Skips agents where getTargetDir returns null\n- skillName = source directory basename\n- Subdirs copied recursively\n- Empty skill dir (only agntc.json) creates empty target, returns dir path\n- Works for multiple agents independently\n\n**Tests**:\n- copies SKILL.md and references to target\n- excludes agntc.json\n- preserves subdir structure\n- creates destination dir when missing\n- returns correct relative paths with trailing slash\n- skips agent when getTargetDir null\n- copies to multiple agents independently\n- handles empty skill dir\n- skillName matches source basename\n- handles deeply nested subdirs\n\n**Context**: Spec rule 4: bare skill — copy entire dir as skill named after source, exclude agntc.json. Manifest shows dir paths with trailing slashes. Phase 2 extends for multi-asset plugin copy.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:56:41Z","updated":"2026-02-19T11:50:56Z"}
{"id":"tick-aaa446","title":"cs-1-9: Manifest Creation and Write","status":"open","priority":2,"description":"**Problem**: After copying files, the tool has install metadata but nowhere to persist it. Without a manifest, remove/update/list can't know what's installed. .agntc/ may or may not exist.\n\n**Solution**: Create manifest module with readManifest, writeManifest, addEntry. readManifest reads .agntc/manifest.json or returns {} if absent. addEntry merges new entry. writeManifest creates dir + writes atomically.\n\n**Outcome**: Tested manifest module handling first install (create dir+file), subsequent installs (merge preserving existing), and reinstall (overwrite entry).\n\n**Do**:\n1. Create src/manifest.ts with ManifestEntry type (ref, commit, installedAt, agents, files) and Manifest type (Record\u003cstring, ManifestEntry\u003e)\n2. readManifest(projectDir) — read .agntc/manifest.json, return {} on ENOENT, propagate other errors\n3. writeManifest(projectDir, manifest) — mkdir -p .agntc/, JSON.stringify 2-space indent + trailing newline, atomic write (write to temp file in .agntc/ then rename to manifest.json to avoid partial writes)\n4. addEntry(manifest, key, entry) — pure function, returns new manifest with entry added/replaced\n5. Create tests/manifest.test.ts with real temp dir fixtures\n6. Export all types and functions\n\n**Acceptance Criteria**:\n- readManifest returns {} when dir or file missing\n- readManifest parses valid manifest\n- readManifest propagates non-ENOENT errors\n- writeManifest creates .agntc/ and manifest.json if missing\n- writeManifest overwrites existing file\n- writeManifest uses 2-space indent + trailing newline\n- writeManifest uses atomic write (temp file + rename)\n- addEntry preserves existing entries, overwrites same key\n- addEntry is pure (no mutation)\n- ManifestEntry matches spec: ref, commit, installedAt, agents, files\n- Full round-trip works\n\n**Tests**:\n- readManifest empty when dir missing\n- readManifest empty when file missing but dir exists\n- readManifest parses single and multiple entries\n- readManifest propagates permission errors\n- readManifest throws on invalid JSON\n- writeManifest creates dir and file\n- writeManifest overwrites existing\n- writeManifest formats correctly\n- writeManifest uses atomic write (no partial writes on crash)\n- addEntry to empty manifest\n- addEntry preserving existing\n- addEntry overwrites same key (reinstall)\n- addEntry doesn't mutate input\n- round-trip write then read\n- entry stores null ref for HEAD, string commit, ISO timestamp, agent array, file array\n\n**Context**: Spec: .agntc/manifest.json, flat object keyed by manifest key. Created on first install. Naming spec confirms .agntc/ directory name. Spec requires single atomic write.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T20:58:03Z","updated":"2026-02-19T11:54:22Z"}
{"id":"tick-d7ffd9","title":"cs-1-10: Add Command End-to-End Integration","status":"open","priority":2,"description":"**Problem**: All components exist in isolation but nothing wires them into the add command. User can't run npx agntc add owner/repo yet.\n\n**Solution**: Replace add stub with full Phase 1 pipeline: parse → clone → config → detect type → detect agents → select → copy → manifest → summary → cleanup. @clack/prompts for UI (intro, spinner, outro). Error handling with cleanup at each step. Non-bare-skill types show \"not yet supported\" and exit cleanly.\n\n**Outcome**: npx agntc add owner/repo against a bare-skill repo works end-to-end. Errors produce clear messages + cleanup. Non-bare-skill types handled gracefully.\n\n**Do**:\n1. Rewrite src/commands/add.ts with full pipeline\n2. @clack/prompts intro/outro, spinner for clone+copy\n3. Parse source → on error: cancel message, exit 1\n4. Clone → spinner, on error: git error message, cleanup, exit 1\n5. Read config → null: \"Collections not yet supported\", cleanup, exit 0. ConfigError: message, cleanup, exit 1\n6. Detect type → bare-skill: continue. plugin: \"not yet supported\", exit 0. not-agntc: warning, exit 0\n7. Detect agents → getRegisteredAgentIds + detect each\n8. Agent multiselect → empty: \"Cancelled\", cleanup, exit 0\n9. Copy bare skill → spinner, on error: cleanup, exit 1\n10. Write manifest → readManifest, addEntry, writeManifest. On error: cleanup, exit 1\n11. Summary → \"Installed {key}@{ref}\" with per-agent counts\n12. Cleanup → always in finally block, swallow cleanup errors\n13. Create tests/commands/add.test.ts mocking all deps\n\n**Acceptance Criteria**:\n- Full happy path works: parse → clone → config → detect → select → copy → manifest → summary → cleanup\n- @clack/prompts intro/outro and spinners shown\n- Errors at each step: clear message, cleanup, exit 1\n- Null config (collection) → not-yet-supported, cleanup, exit 0\n- Plugin type → not-yet-supported, cleanup, exit 0\n- Empty agent selection → cancelled, cleanup, exit 0\n- Summary shows key+ref and per-agent skill count\n- Temp dir cleaned in ALL paths (success, error, cancel)\n- Warnings forwarded to clack.log.warn\n- process.cwd() used as project dir\n\n**Tests**:\n- full happy path integration\n- intro/outro shown\n- spinners during clone and copy\n- error on invalid source (no clone attempted)\n- error + cleanup on clone failure\n- error + cleanup on invalid config\n- not-yet-supported for null config\n- not-yet-supported for plugin type\n- warning for not-agntc\n- forwards warnings to clack\n- detect called on all registered agents\n- correct args to selectAgents\n- cancel on empty selection + cleanup\n- correct args to copyBareSkill\n- error + cleanup on copy failure\n- reads existing manifest before adding\n- correct manifest entry fields\n- error + cleanup on manifest write failure\n- summary with key, ref, per-agent count\n- cleanup on success, error, and cancel\n- cleanup errors swallowed\n- skillName from parsed.repo\n\n**Context**: Capstone task of Phase 1. Wires components into spec's add flow. Phase 1 scope: bare-skill + GitHub shorthand only. Brackets deferred: collection select, reinstall, collision check, conflict check (Phases 2-3).\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T21:00:00Z","updated":"2026-02-18T21:00:00Z"}
{"id":"tick-15542a","title":"cs-1-11: List Command (Minimal)","status":"open","priority":2,"description":"**Problem**: No way for users to see installed plugins. Manifest exists on disk but nothing reads and displays it.\n\n**Solution**: Implement list command to read manifest via readManifest (cs-1-9) and display formatted table via @clack/prompts. Minimal Phase 1 version — no update checks, no detail view, no inline actions.\n\n**Outcome**: npx agntc list shows installed plugins with key, ref, agents, install date. Handles empty/missing/malformed manifest.\n\n**Do**:\n1. Replace list stub in src/commands/list.ts\n2. readManifest(process.cwd())\n3. Empty manifest: \"No plugins installed. Run npx agntc add owner/repo to get started.\" via outro, exit 0\n4. Entries: intro(\"Installed plugins\"), display each with key, version info, agents, date, outro\n5. Version display: @{ref} when set, \"HEAD\" when ref null + commit exists, \"local\" when both null\n6. Agents: comma-separated\n7. Malformed manifest: catch error, \"Failed to read manifest: {error}\", exit 1\n8. Create tests/commands/list.test.ts\n\n**Acceptance Criteria**:\n- Reads manifest from process.cwd()\n- Empty/missing manifest shows spec's empty state message, exits 0\n- Displays each plugin with key, ref, agents, date\n- Ref shown as @tag, HEAD, or local appropriately\n- Malformed manifest shows error, exits 1\n- @clack/prompts for all output\n- No update checks, spinners, or interactivity\n\n**Tests**:\n- empty state for empty manifest\n- empty state for missing manifest\n- single plugin display\n- multiple plugins display\n- ref as tag (@v2.1.6)\n- ref as branch (@main)\n- HEAD when ref null + commit exists\n- local when both null\n- comma-separated agents\n- single agent without comma\n- error on malformed JSON\n- calls readManifest with cwd\n- uses clack intro/outro\n- exits 0 on success and empty\n- exits 1 on error\n\n**Context**: Spec empty state text: \"No plugins installed. Run npx agntc add owner/repo to get started.\" Phase 5 adds full dashboard. Phase 1 list is read-only display only.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-dea5ee","created":"2026-02-18T21:01:34Z","updated":"2026-02-18T21:01:34Z"}
{"id":"tick-aed71e","title":"Phase 2: Multi-Asset Plugins and Collection Support","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-18T21:09:03Z","updated":"2026-02-18T21:09:03Z"}
{"id":"tick-a4cc6d","title":"cs-2-1: Multi-Asset Plugin Asset Copier","status":"open","priority":2,"description":"**Problem**: Phase 1 built copyBareSkill for whole-directory copy. Multi-asset plugins have skills/, agents/, hooks/ dirs whose contents must be individually routed through driver.getTargetDir(assetType). No copy logic exists for this shape.\n\n**Solution**: Create copyPluginAssets that takes source dir, assetDirs list, selected agents, project dir. For each agent × each asset dir: getTargetDir → null = skip, otherwise copy contents to resolved target. Returns copiedFiles (for manifest) and assetCountsByAgent (for summary).\n\n**Outcome**: Tested copier routing multi-asset plugin contents to correct targets, skipping unsupported types, handling empty dirs and nested subdirs.\n\n**Do**:\n1. Create src/copy-plugin-assets.ts with CopyPluginAssetsInput, AssetCounts, CopyPluginAssetsResult types\n2. For each agent × assetDir: getTargetDir(assetDir) → null = skip. Copy contents of source/assetDir to projectDir/targetDir. Track paths and counts.\n3. Copies CONTENTS of asset dirs, not the dirs themselves (skills/planning/ → .claude/skills/planning/)\n4. Create target dirs recursively. Track dir paths with trailing slash, file paths without.\n5. Return copiedFiles (deduped across agents) and assetCountsByAgent\n6. Create tests/copy-plugin-assets.test.ts with real temp dir fixtures\n\n**Acceptance Criteria**:\n- Copies skills/ contents to driver's skills target per agent\n- Copies agents/ contents to driver's agents target per agent\n- Copies hooks/ contents to driver's hooks target per agent\n- Skips asset types where getTargetDir returns null\n- Only processes asset dirs in assetDirs input\n- Copies contents not dirs themselves (no extra nesting)\n- Creates target dirs recursively\n- copiedFiles relative to projectDir, trailing slash for dirs\n- assetCountsByAgent with correct counts\n- Empty asset dirs: zero count, no error\n- Nested subdirs preserved\n- Works per agent independently\n- Does not copy root-level files (only asset dir contents)\n\n**Tests**:\n- copies skills/agents/hooks contents to targets\n- no extra nesting level\n- skips null getTargetDir\n- only processes listed assetDirs\n- creates missing target dirs\n- correct relative paths with trailing slash convention\n- correct per-agent counts\n- empty asset dir handled\n- nested subdirs preserved\n- mixed files and dirs in asset dir\n- multiple agents with different targets\n- subset of asset types\n- single asset type\n\n**Context**: Spec: \"copy contents of each to the appropriate target dir per agent.\" assetDirs from DetectedType (cs-1-5). Routing via driver.getTargetDir (cs-1-6). Claude: all 3 types. Codex (Phase 3): skills only.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-aed71e","created":"2026-02-18T21:09:16Z","updated":"2026-02-18T21:09:16Z"}
{"id":"tick-456e1a","title":"cs-2-2: Add Command: Multi-Asset Plugin Integration","status":"open","priority":2,"description":"**Problem**: Add command returns \"not yet supported\" for plugin type. Users can't install multi-asset plugins. copyPluginAssets exists but nothing calls it.\n\n**Solution**: Replace plugin stub in add command with real pipeline: copyPluginAssets → manifest write → per-agent summary. Surface type detection warnings through @clack/prompts.\n\n**Outcome**: npx agntc add owner/repo against multi-asset plugin works end-to-end. Warnings for misconfigured/empty plugins display clearly.\n\n**Do**:\n1. Replace plugin branch in add command with: copyPluginAssets({ sourceDir, assetDirs, agents, projectDir }) inside spinner\n2. Check empty copiedFiles → warn \"no files to install\", cleanup, exit 0\n3. Write manifest entry with copiedFiles\n4. Render summary: \"Installed {key}[@{ref}]\" + per-agent counts (only non-zero types)\n5. Verify onWarn callback surfaces root SKILL.md warning and not-agntc warning\n6. Handle not-agntc with config: warn + cleanup + exit 0\n\n**Acceptance Criteria**:\n- Plugin type triggers copyPluginAssets with correct args\n- Manifest entry written with copiedFiles\n- Summary shows per-agent counts, omits zero-count types and no-asset agents\n- Empty plugin warns and exits 0 without manifest write\n- Root SKILL.md ignored warning surfaces\n- not-agntc with config shows warning\n- Temp dir cleaned in all paths\n- Spinner during copy\n- Bare-skill path still works\n\n**Tests**:\n- multi-asset plugin e2e install\n- manifest entry with correct fields\n- summary per-agent counts\n- summary omits zero counts\n- summary with/without ref\n- empty plugin warn + exit 0\n- SKILL.md misconfiguration warning\n- not-agntc warning\n- spinner during copy\n- cleanup on success, empty, error\n- copy error → message + exit 1\n- manifest write error → cleanup + exit 1\n- passes detected assetDirs (not hardcoded)\n- bare-skill path unchanged\n\n**Context**: DetectedType plugin has assetDirs. copyPluginAssets returns copiedFiles + assetCountsByAgent. Spec summary: only show non-zero types per agent.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-aed71e","created":"2026-02-18T21:10:58Z","updated":"2026-02-18T21:10:58Z"}
{"id":"tick-46b8a2","title":"cs-2-3: Collection Plugin Multiselect UI","status":"open","priority":2,"description":"**Problem**: Collection repos show \"not yet supported\". Need to let users select which plugins to install. Must indicate already-installed plugins and handle cancel.\n\n**Solution**: Create selectCollectionPlugins taking plugins list, manifest, and key prefix. @clack/prompts multiselect with installed hints. Zero selection/cancel = empty array. Single-plugin collections still show multiselect.\n\n**Outcome**: Tested multiselect presenting all collection plugins with installed status, handling cancel, returning selected names.\n\n**Do**:\n1. Create src/collection-select.ts with selectCollectionPlugins({ plugins, manifest, manifestKeyPrefix })\n2. For each plugin: derive key as prefix/pluginName, check manifest, add \"(installed)\" hint if found\n3. @clack/prompts multiselect, required: false. Already-installed NOT pre-selected.\n4. Handle isCancel → empty array. Zero selection → brief message + empty array.\n5. Return selected plugin names as string[]\n6. Create tests/collection-select.test.ts mocking clack multiselect\n\n**Acceptance Criteria**:\n- Presents all plugins as multiselect options\n- Manifest key = prefix/pluginName\n- Installed plugins show \"(installed)\" hint\n- Cancel returns empty array\n- Zero selection returns empty array\n- Valid selection returns string[]\n- Single-plugin collection still shows multiselect\n- All-installed collection still shows multiselect\n- Empty plugins array returns empty without showing multiselect\n\n**Tests**:\n- presents all plugins\n- correct manifest key construction\n- installed hint shown\n- no hint for not-installed\n- mixed installed/not\n- cancel returns empty\n- zero selection returns empty\n- valid selection returns names\n- single plugin still shows multiselect\n- all installed still shows multiselect\n- empty plugins returns empty\n- correct options shape to clack\n\n**Context**: Spec: collection multiselect, installed plugins marked but selectable (reinstall). Zero selection = cancel. Manifest key: owner/repo/plugin-name. UI only — per-plugin processing in cs-2-4.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-aed71e","created":"2026-02-18T21:12:48Z","updated":"2026-02-18T21:12:48Z"}
{"id":"tick-f68023","title":"cs-2-4: Add Command: Collection Integration","status":"open","priority":2,"description":"**Problem**: Add command shows \"Collections not yet supported\" for collection repos. Need to orchestrate per-plugin pipeline.\n\n**Solution**: Replace collection stub with: selectCollectionPlugins → for each plugin: readConfig, detectType, copy by type → single manifest write with owner/repo/plugin-name keys → per-plugin summary. Plugin failures skip with warning.\n\n**Outcome**: Collection repos present multiselect, install each selected plugin by type, write per-plugin manifest entries, show per-plugin summary.\n\n**Do**:\n1. Replace collection branch in add command\n2. selectCollectionPlugins({ plugins, manifest, manifestKeyPrefix })\n3. Empty selection → cancel + cleanup\n4. Agent detection + multiselect ONCE for all plugins. Empty → cancel + cleanup.\n5. Per plugin: readConfig(pluginDir) — ConfigError → warn + skip. null → warn + skip.\n6. detectType per plugin: bare-skill → copyBareSkill (skillName=pluginName). plugin → copyPluginAssets. not-agntc → warn + skip.\n7. Manifest key: manifestKeyPrefix/pluginName\n8. Single manifest write after all plugins\n9. Per-plugin summary with counts. Note skipped plugins.\n10. Cleanup in finally\n\n**Acceptance Criteria**:\n- Collection triggers selectCollectionPlugins with correct args\n- Agent multiselect once for all plugins\n- Each plugin validated independently\n- ConfigError skips plugin with warning\n- Bare-skill and multi-asset plugins handled by type\n- Manifest keys: owner/repo/plugin-name\n- Single manifest write\n- Per-plugin summary with counts\n- Skipped plugins noted\n- Empty selections cancel cleanly\n- Temp dir cleaned in all paths\n\n**Tests**:\n- collection with bare-skill plugins\n- collection with multi-asset plugins\n- mixed types install each by type\n- manifest keys correct\n- agent multiselect called once\n- invalid agntc.json skips plugin\n- missing agntc.json skips plugin\n- not-agntc skips plugin\n- all plugins failing exits 0\n- empty plugin/agent selection cancels\n- single manifest write\n- per-plugin summary\n- cleanup on all paths\n- no regression on standalone add\n\n**Context**: Spec: collection multiselect, each plugin independent, per-plugin summary. Agent multiselect once, pre-selection uses union of declared agents. Reinstall deferred to cs-2-5.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-aed71e","created":"2026-02-18T21:15:06Z","updated":"2026-02-18T21:15:06Z"}
{"id":"tick-5820dd","title":"cs-2-5: Reinstall on Reselect","status":"open","priority":2,"description":"**Problem**: Selecting an already-installed plugin installs on top of existing files, leaving orphaned files from previous versions. Spec requires nuke-and-reinstall.\n\n**Solution**: Create nukeManifestFiles that deletes files from manifest entry before copying. ENOENT silently skipped. Works for both collection and standalone plugins. Reusable by update/remove in later phases.\n\n**Outcome**: Already-installed plugins' files nuked before re-copy. Missing files skipped gracefully. Manifest entry replaced with fresh data.\n\n**Do**:\n1. Create src/nuke-files.ts with nukeManifestFiles(projectDir, files) → { removed, skipped }\n2. Dirs (trailing /) → fs.rm recursive+force. Files → fs.rm force. ENOENT → skipped. Other errors propagate.\n3. In add command: before copying, check if manifestKey exists in manifest. If so, nukeManifestFiles.\n4. Applies to standalone and collection plugins alike\n5. addEntry replaces old manifest entry after reinstall\n6. Create tests/nuke-files.test.ts with real temp dirs\n7. Update add command tests for reinstall flow\n\n**Acceptance Criteria**:\n- Files nuked before copy begins\n- Directories removed recursively\n- ENOENT silently skipped\n- Non-ENOENT errors propagate\n- Returns removed and skipped lists\n- Per-plugin nuke independent (collection)\n- Manifest entry replaced not duplicated\n- Works for standalone reinstall\n- Works for collection reinstall\n- Different agent selection: old files nuked, new files created\n- Empty files array is no-op\n\n**Tests**:\n- nukes files before copy\n- removes directories recursively\n- removes individual files\n- skips ENOENT\n- returns removed/skipped lists\n- propagates EACCES\n- empty files is no-op\n- mix of existing and missing\n- standalone reinstall nukes first\n- collection reinstall nukes first\n- different agents: old removed, new created\n- only installed plugins nuked\n- manifest entry replaced\n- nuke failure on one collection plugin doesn't block others\n\n**Context**: Spec step 6: delete all manifest files before proceeding. Same mechanics as update's nuke step. nukeManifestFiles reusable by Phase 4 update and remove commands.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-aed71e","created":"2026-02-18T21:15:17Z","updated":"2026-02-18T21:15:17Z"}
{"id":"tick-ef070a","title":"Phase 3: Multi-Agent Support and Source Formats","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-18T21:17:31Z","updated":"2026-02-18T21:17:31Z"}
{"id":"tick-3f18d0","title":"cs-3-1: Codex Agent Driver","status":"open","priority":2,"description":"**Problem**: Only Claude driver exists. Can't route assets to Codex targets. Adding Codex validates driver/strategy architecture.\n\n**Solution**: Implement CodexDriver satisfying AgentDriver. detect: .agents/ in project → which codex fallback. getTargetDir: skills → .agents/skills/, agents → null, hooks → null. Register in registry.\n\n**Outcome**: CodexDriver registered, detectable, routing skills to .agents/skills/. Registry returns both claude and codex.\n\n**Do**:\n1. Create src/drivers/codex-driver.ts implementing AgentDriver\n2. detect: check .agents/ in project → which codex fallback. No ~/.codex/ check.\n3. getTargetDir: skills → .agents/skills, agents → null, hooks → null\n4. Register in registry under \"codex\"\n5. Verify getRegisteredAgentIds returns [\"claude\", \"codex\"]\n6. Create tests/drivers/codex-driver.test.ts\n\n**Acceptance Criteria**:\n- detect true when .agents/ exists, skips system fallback\n- detect falls back to which codex\n- detect false when both fail, no throw\n- getTargetDir: skills → .agents/skills, agents → null, hooks → null\n- Registry includes codex, Claude unchanged\n\n**Tests**: detect with/without .agents/, which codex success/failure, getTargetDir for all types, registry lookup, both agents registered\n\n**Context**: Spec routing: Codex skills → .agents/skills/, agents → null, hooks → null. Detection: .agents/ then which codex.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:20:09Z","updated":"2026-02-18T21:20:09Z"}
{"id":"tick-947bd2","title":"cs-3-2: Agent Detection System","status":"open","priority":2,"description":"**Problem**: Detection is inline in add command. Need reusable detectAgents function for multiple commands.\n\n**Solution**: Extract detectAgents(projectDir) that loops registered drivers, calls detect() in parallel, returns detected AgentId[].\n\n**Outcome**: Tested detectAgents function. Add command uses it instead of inline loop.\n\n**Do**:\n1. Create src/detect-agents.ts with detectAgents(projectDir) → AgentId[]\n2. Loop getRegisteredAgentIds, detect each in parallel (Promise.all)\n3. Return detected IDs (may be empty). Individual failures → not detected.\n4. Replace inline detection in add command\n5. Create tests/detect-agents.test.ts\n\n**Acceptance Criteria**:\n- Returns detected AgentId[]\n- Parallel detection\n- Empty when none detected\n- Individual failure → not detected (no throw)\n- Add command uses detectAgents\n\n**Tests**: both detected, only one, none, parallel, individual failure, add command integration\n\n**Context**: Spec: detection for pre-selection, not gating. Project-level first, system fallback per driver.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:20:09Z","updated":"2026-02-18T21:20:09Z"}
{"id":"tick-1abe95","title":"cs-3-3: Agent Multiselect with Pre-Selection and Warnings","status":"open","priority":2,"description":"**Problem**: Phase 1 selectAgents built with Claude only. Need to verify and enhance for two-agent scenarios.\n\n**Solution**: Validate selectAgents with both agents registered. Verify pre-selection (declared ∩ detected), unsupported warnings, edge cases.\n\n**Outcome**: Multiselect correctly handles all two-agent declared/detected combinations.\n\n**Do**:\n1. Review src/agent-select.ts for two-agent correctness\n2. Add/update tests for all two-agent combinations\n3. Verify spec examples work\n4. Fix any gaps found\n\n**Acceptance Criteria**:\n- Both agents shown\n- Pre-selection = declared ∩ detected for all combinations\n- Unsupported warning on undeclared agents\n- Empty declaredAgents → all get warning\n- Unsupported agent selectable (warn never block)\n- Zero selection returns empty\n\n**Tests**: all declared/detected combinations, unsupported warnings, empty declared, no agents detected, user selects unsupported\n\n**Context**: Spec pre-selection examples. Warn never block. Works with Codex driver now registered.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:20:09Z","updated":"2026-02-18T21:20:09Z"}
{"id":"tick-d63c08","title":"cs-3-4: Source Parsing: HTTPS URL","status":"open","priority":2,"description":"**Problem**: parseSource only handles GitHub shorthand. Need HTTPS URL support for any git host.\n\n**Solution**: Extend parseSource to detect https:// URLs, extract owner/repo from path, support @ref, return type \"https-url\" with cloneUrl. Normalize trailing slash and .git suffix.\n\n**Outcome**: parseSource handles HTTPS URLs from any host with correct manifest key and clone URL.\n\n**Do**:\n1. Add ParsedSource variant: { type: \"https-url\", owner, repo, ref, manifestKey, cloneUrl }\n2. Detect https:// prefix after trim\n3. Parse URL path: strip trailing slash/.git, extract last 2 segments as owner/repo\n4. Build cloneUrl: https://{host}/{owner}/{repo}.git\n5. manifestKey: owner/repo (host-independent)\n6. Update cloneSource to use cloneUrl for https-url type\n7. Update tests\n\n**Acceptance Criteria**:\n- Parses any host (github, gitlab, bitbucket)\n- Extracts owner/repo from URL path\n- Supports @ref suffix\n- Strips trailing slash and .git\n- manifestKey = owner/repo\n- cloneUrl normalized with .git\n- Throws for invalid URLs (no path, single segment)\n- GitHub shorthand still works\n\n**Tests**: various hosts, @ref, trailing slash, .git suffix, invalid URLs, no regression on shorthand\n\n**Context**: Spec: HTTPS URL format from any git host. manifest key = owner/repo regardless of format. @ref suffix supported.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:20:09Z","updated":"2026-02-18T21:20:09Z"}
{"id":"tick-448957","title":"cs-3-5: Source Parsing: SSH URL","status":"open","priority":2,"description":"**Problem**: parseSource doesn't handle SSH URLs. Users with SSH auth can't use agntc add.\n\n**Solution**: Add type: \"ssh-url\" variant. Detect git@ prefix, parse host:owner/repo.git, handle missing .git, support @ref.\n\n**Outcome**: parseSource handles git@host:owner/repo.git[@ref] with correct cloneUrl, owner, repo, manifestKey.\n\n**Do**:\n1. Add ParsedSource variant: { type: \"ssh-url\", owner, repo, ref, manifestKey, cloneUrl }\n2. Detect git@ prefix. Split ref on last @ after repo path.\n3. Parse host:path, strip .git, extract owner/repo\n4. cloneUrl: git@host:owner/repo.git (normalized)\n5. manifestKey: owner/repo\n6. Throw for malformed URLs\n7. Update tests\n\n**Acceptance Criteria**: Parses git@host:owner/repo.git with/without ref, any host, missing .git handled, cloneUrl normalized, manifestKey=owner/repo, errors for malformed, no regression.\n\n**Tests**: with/without ref, tag/branch refs, missing .git, non-GitHub hosts, malformed URLs, no regression\n\n**Context**: Spec: git@github.com:owner/repo.git for SSH auth. @ref supported. manifestKey = owner/repo.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:23:36Z","updated":"2026-02-18T21:23:36Z"}
{"id":"tick-db20a7","title":"cs-3-6: Source Parsing: Local Path","status":"open","priority":2,"description":"**Problem**: parseSource only handles remote sources. Need local paths for development/testing.\n\n**Solution**: Add type: \"local-path\" variant. Detect ./ ../ / ~ prefixes. Resolve absolute, expand tilde, validate exists + is directory at parse time. ref=null, manifestKey=absolute path.\n\n**Outcome**: parseSource handles local paths, validates existence, returns resolved absolute path.\n\n**Do**:\n1. Add ParsedSource variant: { type: \"local-path\", resolvedPath, ref: null, manifestKey }\n2. Detect path prefixes (./ ../ / ~)\n3. Expand ~, resolve to absolute via path.resolve\n4. Validate: fs.stat, must exist and be directory. Throw spec error message.\n5. manifestKey = resolvedPath\n6. Make parseSource async (fs.stat needed). Update callers.\n7. Update tests\n\n**Acceptance Criteria**: Resolves relative/absolute/tilde paths, validates exists+directory, throws spec error for missing/file, ref=null, manifestKey=absolute, tilde expanded, no regression.\n\n**Tests**: relative, absolute, tilde, non-existent, file not dir, permission denied, no regression\n\n**Context**: Spec: local paths for dev/testing. No clone. ref+commit null. Key=absolute path. Error: \"Path {path} does not exist or is not a directory.\"\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:23:36Z","updated":"2026-02-18T21:23:36Z"}
{"id":"tick-0b36b0","title":"cs-3-7: Source Parsing: Direct Collection Path","status":"open","priority":2,"description":"**Problem**: Can't install a specific plugin from a collection via tree URL. Must add whole collection and multiselect.\n\n**Solution**: Add type: \"direct-path\" variant. Detect /tree/ in HTTPS URLs. Extract ref and plugin name from path. cloneUrl for whole repo. targetPlugin for skipping multiselect. Reject @ref suffix on tree URLs.\n\n**Outcome**: parseSource handles tree URLs, extracts ref+plugin from path, returns direct-path type.\n\n**Do**:\n1. Add ParsedSource variant: { type: \"direct-path\", owner, repo, ref, targetPlugin, manifestKey, cloneUrl }\n2. Detect /tree/ in HTTPS URL path (before plain HTTPS fallthrough)\n3. Parse: owner/repo from path, ref = first segment after /tree/, plugin = rest\n4. cloneUrl: https://host/owner/repo.git\n5. manifestKey: owner/repo/plugin-name\n6. Throw for @ref suffix on tree URL, missing ref/plugin\n7. Update tests\n\n**Acceptance Criteria**: Parses tree URLs with branch/tag refs, correct targetPlugin, cloneUrl, manifestKey=owner/repo/plugin, throws for @ref suffix and missing segments, no regression.\n\n**Tests**: branch/tag refs, nested plugin paths, non-GitHub hosts, @ref suffix rejected, missing segments, no regression\n\n**Context**: Spec: direct path = collection shortcut, skips multiselect. Ref embedded in URL. manifestKey = owner/repo/plugin-name.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:23:36Z","updated":"2026-02-18T21:23:36Z"}
{"id":"tick-d24318","title":"cs-3-8: Local Path Source Integration","status":"open","priority":2,"description":"**Problem**: cs-3-6 parses local paths but add command still assumes remote sources (clone + temp dir). Need to wire local path through pipeline.\n\n**Solution**: Branch on type=local-path in add command. Skip clone, use resolvedPath as sourceDir. No temp dir cleanup. commit=null in manifest. Collection keys = absolutePath/pluginName.\n\n**Outcome**: npx agntc add ./my-plugin works without cloning. Correct manifest entry. Collections from local paths supported.\n\n**Do**:\n1. Branch on local-path early in add command\n2. sourceDir = parsed.resolvedPath (skip clone)\n3. Skip temp dir cleanup (conditional)\n4. Proceed with readConfig, detectType, select, copy as normal\n5. Manifest: ref=null, commit=null, key=resolvedPath\n6. Collections: manifestKeyPrefix = resolvedPath, plugin key = path/pluginName\n7. Summary shows \"local\" instead of ref\n8. Update tests\n\n**Acceptance Criteria**: Skips clone, uses resolvedPath, no temp dir, manifest ref+commit null, key=absolute path, bare skill+plugin+collection from local path, collection keys correct, no regression.\n\n**Tests**: skip clone, resolvedPath as source, no cleanup, null ref/commit, correct key, bare skill/plugin/collection from local, collection keys, no agntc.json handling, summary, no regression\n\n**Context**: Spec: local path = no clone, copy directly. ref+commit null. Key = absolute path. Collection plugins: absolutePath/pluginName. ~ expanded.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:23:36Z","updated":"2026-02-18T21:23:36Z"}
{"id":"tick-400db7","title":"cs-3-9: File Path Collision Check","status":"open","priority":2,"description":"**Problem**: Two plugins can install to overlapping paths, silently corrupting the first. No collision detection exists.\n\n**Solution**: checkFileCollisions diffs incoming files against manifest entries (excluding own key for reinstall). resolveCollisions offers remove-conflicting-plugin or cancel. No install-anyway option.\n\n**Outcome**: Collisions hard-block with clear prompt. User removes conflicting plugin in-flow or cancels. Reinstalls excluded from collision check.\n\n**Do**:\n1. Create src/collision-check.ts: checkFileCollisions(incomingFiles, manifest, excludeKey?) → CollisionResult\n2. Group collisions by manifest key\n3. Create src/collision-resolve.ts: resolveCollisions with remove or cancel options\n4. Remove = nukeManifestFiles + delete entry. Cancel = resolved: false.\n5. Multiple colliding plugins resolved sequentially\n6. Create tests\n\n**Acceptance Criteria**: Empty when no overlap, detects overlap, groups by key, excludes own key (reinstall), no install-anyway option, remove triggers nuke + entry removal, cancel returns false, multiple collisions sequential.\n\n**Tests**: no overlap, single/multi collision, exclude own key, directory paths, resolve remove/cancel, multiple plugins sequential, stop on cancel\n\n**Context**: Spec step 7: hard block on cross-plugin overlap. Remove then continue, or cancel. Reinstall nuke (step 6) runs before this.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:26:45Z","updated":"2026-02-18T21:26:45Z"}
{"id":"tick-081566","title":"cs-3-10: Unmanaged File Conflict Check","status":"open","priority":2,"description":"**Problem**: User may have manually placed files at destination paths. Overwriting silently loses work. Need detection and prompt.\n\n**Solution**: checkUnmanagedConflicts scans destination paths on disk, excluding manifest-tracked files. Asset-level detection. resolveUnmanagedConflicts offers per-plugin overwrite-all (double confirmation) or cancel-plugin.\n\n**Outcome**: Unmanaged files detected. Per-plugin prompt with double-confirmed overwrite or cancel. Collections check independently.\n\n**Do**:\n1. Create src/unmanaged-check.ts: checkUnmanagedConflicts(incomingFiles, manifest, projectDir) → UnmanagedConflict[]\n2. Check disk existence, exclude manifest-tracked paths\n3. Asset-level: skill dir, agent file, hook file\n4. Create src/unmanaged-resolve.ts: per-plugin overwrite-all + second confirm, or cancel\n5. Return approved/cancelled lists\n6. Create tests\n\n**Acceptance Criteria**: Empty when nothing on disk, empty when all tracked, detects unmanaged assets, empty dir = conflict, asset-level detection, overwrite needs double confirm, cancel → cancelled, collections independent, all cancelled → empty approved.\n\n**Tests**: no files on disk, all tracked, unmanaged skill/agent/hook, empty dir, asset level, overwrite + confirm, overwrite + decline confirm, cancel, mixed collection, all cancelled\n\n**Context**: Spec step 8: scan for unmanaged files. Asset-level. Overwrite-all with second confirmation or cancel-plugin. After collision check passes. Note: overwrite-on-conflict also serves as the migration path from other tools (e.g., previous plugin managers) — no special migration tooling needed per spec.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:26:45Z","updated":"2026-02-18T22:29:30Z"}
{"id":"tick-f5b1ac","title":"cs-3-11: Add Command Full Conflict Flow Integration","status":"open","priority":2,"description":"**Problem**: Collision check and unmanaged check exist but aren't wired into add command. Goes straight from agent select to copy.\n\n**Solution**: Wire both checks between agent selection and copy. Order: compute incoming files → collision check → resolve → unmanaged check → resolve → copy. All resolution before copying. Summary notes skipped plugins.\n\n**Outcome**: Full conflict flow for every install. Cancelled plugins excluded. No rollback needed.\n\n**Do**:\n1. Create computeIncomingFiles helper mirroring copy path computation\n2. For standalone: collision check → unmanaged check → copy\n3. For collections: per-plugin checks, cancelled excluded from copy\n4. Collision removal persists even if later cancelled\n5. Summary notes skipped plugins with reason\n6. Update tests\n\n**Acceptance Criteria**: Collision before unmanaged before copy, cancel at any stage exits cleanly, collections independent, removal persists after cancel, summary notes skips, computeIncomingFiles matches copy paths, no regression.\n\n**Tests**: collision before copy, unmanaged after collision, cancel at each stage, resolve then install, collection independent, all cancelled, removal persists, incoming files correct, no conflict path, manifest reflects all changes, cleanup on cancel\n\n**Context**: Spec steps 7-8 before step 9. All resolution before copying = no rollback. computeIncomingFiles mirrors copy logic.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-ef070a","created":"2026-02-18T21:26:45Z","updated":"2026-02-18T21:26:45Z"}
{"id":"tick-d85f8a","title":"Phase 4: Remove and Update Commands","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-18T21:28:58Z","updated":"2026-02-18T21:28:58Z"}
{"id":"tick-35621c","title":"cs-4-1: Remove Command: Parameterized Mode","status":"open","priority":2,"description":"**Problem**: No way to remove installed plugins. Users must manually delete files and edit manifest.\n\n**Solution**: Implement parameterized remove: parse key argument, match against manifest (exact, collection prefix, or not found), show files, confirm, nuke via nukeManifestFiles, remove entry, write manifest, summary.\n\n**Outcome**: npx agntc remove owner/repo deletes tracked files and manifest entry after confirmation.\n\n**Do**:\n1. Create src/commands/remove.ts with optional [key] argument\n2. readManifest → empty → \"No plugins installed.\", exit 0\n3. Match: exact key → single target. No exact → collection prefix (keys starting with key/) → multiple. No match → error, exit 1.\n4. Confirm: list files, @clack/prompts confirm. Decline → cancel, exit 0.\n5. nukeManifestFiles per target plugin\n6. Remove entries from manifest, writeManifest\n7. Summary: \"Removed {key}\" with counts\n8. Register in cli.ts\n\n**Acceptance Criteria**: Exact key removes single, prefix removes all collection plugins, non-existent exits 1 with spec message, empty manifest exits 0, confirmation shown, declined cancels, files nuked, manifest updated, summary shown, empty directories left in place after file deletion (no directory cleanup).\n\n**Tests**: standalone remove, collection prefix, specific collection plugin, non-existent key, empty manifest, confirmation shown/declined, files nuked, manifest updated, summary, ENOENT tolerance, preserves unrelated entries, empty parent directories left in place after removal.\n\n**Context**: Spec: confirm → delete → remove entry → write. nukeManifestFiles from cs-2-5. Error: \"Plugin {key} is not installed.\" No modification detection — the tool does not track checksums. If user modified installed files, those changes are lost on remove. Git is the safety net.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:45:19Z","updated":"2026-02-18T22:22:29Z"}
{"id":"tick-5bc8a9","title":"cs-4-2: Remove Command: Interactive Mode","status":"open","priority":2,"description":"**Problem**: Users must know exact manifest key. Need no-arg interactive mode.\n\n**Solution**: No-arg reads manifest, presents @clack/prompts multiselect, selected plugins flow into same confirm → nuke → remove → write → summary path.\n\n**Outcome**: npx agntc remove (no args) shows selectable list. Selected plugins removed after confirmation.\n\n**Do**:\n1. No-arg branch in remove command\n2. readManifest → empty → message, exit 0\n3. @clack/prompts multiselect with all keys + ref hints\n4. Cancel/zero → exit 0\n5. Selection flows to parameterized confirm → nuke → remove → write → summary\n\n**Acceptance Criteria**: No-arg shows multiselect, cancel exits 0, selected flow to confirm+remove, empty manifest handled, single plugin still shows multiselect.\n\n**Tests**: multiselect shown, ref hints, cancel, zero selection, single/multi selection, empty manifest, declined confirmation, correct nuke args.\n\n**Context**: Spec: no-arg presents all plugins. Shares infrastructure with cs-4-1.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:45:19Z","updated":"2026-02-18T21:45:19Z"}
{"id":"tick-76e6c7","title":"cs-4-3: Update Check Logic","status":"open","priority":2,"description":"**Problem**: No way to determine if a plugin has newer version. Update and list dashboard both need this.\n\n**Solution**: Create checkForUpdate returning typed result: update-available, up-to-date, newer-tags, check-failed, or local. Uses git ls-remote for remote comparison.\n\n**Outcome**: Tested update check handling all ref types with correct git ls-remote invocations.\n\n**Do**:\n1. Create src/update-check.ts with UpdateCheckResult union\n2. Local (ref=null, commit=null) → { status: 'local' }\n3. null ref (HEAD): ls-remote HEAD SHA → compare to commit\n4. Branch ref: ls-remote refs/heads/{ref} → compare\n5. Tag ref: always up-to-date + ls-remote --tags for newer tags\n6. Derive cloneUrl from manifest key\n7. All ls-remote failures → check-failed\n8. Create tests mocking child_process\n\n**Acceptance Criteria**: HEAD/branch/tag/local all handled correctly, ls-remote failure → check-failed, branch gone → check-failed, newer tags detected, clone URL derived from key.\n\n**Tests**: HEAD update-available/up-to-date, branch update/match/gone, tag up-to-date/newer-tags, local returns immediately, ls-remote failure/timeout, URL derivation, ls-remote output parsing.\n\n**Context**: Spec update check table. Used by update command and list dashboard (Phase 5).\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:45:19Z","updated":"2026-02-18T21:45:19Z"}
{"id":"tick-2a89a4","title":"cs-4-4: Update Command: Single Plugin Nuke-and-Reinstall","status":"open","priority":2,"description":"**Problem**: No update command. Users must remove and re-add to get newer versions.\n\n**Solution**: Implement update with single-plugin mode: checkForUpdate → nuke → re-clone at same ref → re-copy with same agents → update manifest. No confirmation. No agent re-prompt.\n\n**Outcome**: npx agntc update owner/repo checks, nukes, re-clones, re-copies, updates manifest.\n\n**Do**:\n1. Create src/commands/update.ts with optional [key] argument\n2. readManifest → empty → message, exit 0. No match → error, exit 1.\n3. checkForUpdate → up-to-date → message, exit 0. check-failed → error, exit 1.\n4. update-available: nukeManifestFiles → cloneSource(same ref) → readConfig → detectType → copy(entry.agents) → update manifest entry → writeManifest → cleanup\n5. Summary: old→new commit + per-agent counts\n6. Register in cli.ts\n\n**Acceptance Criteria**: Non-existent key exits 1, empty manifest exits 0, up-to-date message, check-failed error, nuke-and-reinstall pipeline, no confirmation, uses entry.agents, manifest updated with new commit/files, temp dir cleaned.\n\n**Tests**: non-existent key, empty manifest, up-to-date, check-failed, nuke-and-reinstall flow, same agents used, manifest updated, temp dir cleanup, already-deleted files, collection prefix updates all.\n\n**Context**: Spec nuke-and-reinstall: delete → re-clone same ref → re-copy same agents → update manifest. No confirmation. No agent re-selection.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:45:19Z","updated":"2026-02-18T21:45:19Z"}
{"id":"tick-a1ef32","title":"cs-4-5: Update Command: Local Path Re-Copy","status":"open","priority":2,"description":"**Problem**: Local path plugins can't use git update. Need always-re-copy from stored path.\n\n**Solution**: Detect local status from checkForUpdate. Nuke existing, re-copy from stored path (manifest key = path), update manifest. Always copies.\n\n**Outcome**: npx agntc update /path/to/plugin re-copies from source. Handles missing path.\n\n**Do**:\n1. Local-path branch in update after checkForUpdate returns 'local'\n2. Validate source path exists + is directory. Missing → error, exit 1.\n3. nukeManifestFiles → copy from path using entry.agents → update manifest\n4. Summary: \"refreshed\" with counts\n\n**Acceptance Criteria**: Local detected, always re-copies, validates path, missing path errors, no git, manifest updated with null ref/commit, works for standalone and collection local.\n\n**Tests**: local triggers re-copy, copies even if unchanged, validates path, errors when gone, errors no agntc.json, nukes then copies, uses entry.agents, manifest updated, no git clone, no temp dir.\n\n**Context**: Spec: local always re-copy. No change detection. Useful for development.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:45:19Z","updated":"2026-02-18T21:45:19Z"}
{"id":"tick-496cae","title":"cs-4-6: Update Command: Tag-Pinned Behavior","status":"open","priority":2,"description":"**Problem**: Tag-pinned plugins should never auto-upgrade but user should be informed of newer tags.\n\n**Solution**: Handle 'newer-tags' and 'up-to-date' from checkForUpdate for tag-pinned plugins. Display tag list and re-add command. No file/manifest changes.\n\n**Outcome**: Tag-pinned shows up-to-date or lists newer tags with upgrade command. No files touched.\n\n**Do**:\n1. Handle 'newer-tags' status in update command\n2. Display: pinned to {ref}, newer tags available, tag list (newest first)\n3. Show re-add command: npx agntc add {source}@{tag}\n4. 'up-to-date' for tags: brief message\n5. No file/manifest changes, exit 0\n\n**Acceptance Criteria**: Newer tags listed newest-first, re-add command shown, no newer tags → up-to-date, no files/manifest modified, exits 0.\n\n**Tests**: newer tags shown, no newer tags, re-add command, newest first, no nuke/clone/manifest write.\n\n**Context**: Spec: tag-pinned never auto-upgraded. Show available tags, re-add command.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:46:08Z","updated":"2026-02-19T11:25:05Z"}
{"id":"tick-027b1d","title":"cs-4-7: Update Command: Agent Compatibility Changes","status":"open","priority":2,"description":"**Problem**: Plugin update may change agents field. Need to handle dropped agents without re-prompting.\n\n**Solution**: During nuke-and-reinstall, compare new agntc.json agents against manifest agents. effectiveAgents = intersection. All dropped → warn + skip. Partial drop → warn + proceed with remaining. New agents ignored.\n\n**Outcome**: Agent compat changes detected: partial drops warned, total drops skip, new agents ignored.\n\n**Do**:\n1. After re-clone + readConfig: compare newConfig.agents vs entry.agents\n2. effectiveAgents = intersection\n3. All dropped: warn with spec message (includes remove command), don't nuke, exit 0\n4. Partial drop: warn, proceed with effectiveAgents, manifest.agents updated\n5. New agents in config: silently ignore\n6. Summary: \"Updated for {agents}. {dropped} support removed.\"\n\n**Acceptance Criteria**: Detects dropped agents, all dropped warns+skips+leaves files, partial drop warns+proceeds with remaining, manifest agents updated, dropped files removed (part of nuke), new agents ignored, no change proceeds normally.\n\n**Tests**: no change normal, partial drop warns/uses effective/updates manifest, all dropped warns/skips/leaves files/shows remove cmd, new agents ignored, single agent dropped from multi.\n\n**Context**: Spec: re-read agntc.json, compare agents. Dropped → warn + remove files. All dropped → skip. New → ignore. Update = same config, newer version.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:46:08Z","updated":"2026-02-18T21:46:08Z"}
{"id":"tick-7c0be9","title":"cs-4-8: Update Command: All-Plugins Mode","status":"open","priority":2,"description":"**Problem**: npx agntc update (no args) should update all installed plugins.\n\n**Solution**: No-arg mode: read manifest → parallel checkForUpdate → categorize → sequential processing per type → single manifest write → aggregate summary. Partial failures continue.\n\n**Outcome**: Processes all plugins. Mixed types handled. Partial failures noted. Summary per-plugin.\n\n**Do**:\n1. No-arg branch: readManifest → empty → message, exit 0\n2. Spinner: parallel checkForUpdate for all\n3. Categorize: update-available, local, newer-tags, up-to-date, check-failed\n4. Process updatable sequentially (nuke-and-reinstall / local re-copy)\n5. Tag-pinned: info only. Check-failed: note. All up-to-date: brief message.\n6. Single manifest write. Partial failures caught per-plugin.\n7. Aggregate summary\n\n**Acceptance Criteria**: All entries checked in parallel, each type processed correctly, partial failure continues, single manifest write, all up-to-date message, per-plugin summary.\n\n**Tests**: all entries processed, empty manifest, parallel checks, mixed types, partial failure continues, failed noted, single write, all up-to-date, per-plugin summary, spinner shown.\n\n**Context**: Spec: no-arg updates all. npm/brew convention. Each plugin independent.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:46:08Z","updated":"2026-02-18T21:46:08Z"}
{"id":"tick-4ec9ff","title":"cs-4-9: Update Command: Network Retry","status":"open","priority":2,"description":"**Problem**: Clone failures during update have unique context: files already nuked. Need proper error handling for this state.\n\n**Solution**: Verify cloneSource retry applies during update. Handle post-nuke clone failure: contextual error message with reinstall guidance, manifest entry cleanup.\n\n**Outcome**: Transient failures retried. Auth aborts immediately. Post-nuke failure produces actionable error.\n\n**Do**:\n1. Ensure cloneSource errors after nuke caught with context message\n2. Post-nuke clone failure: \"Update of {key} failed. Files removed. Run npx agntc add {source} to reinstall.\"\n3. Remove stale manifest entry on clone failure\n4. Verify 3x retry applies during update\n5. Verify auth failure immediate abort\n6. Create update-specific clone failure tests\n\n**Acceptance Criteria**: Transient retried 3x, retry success completes update, auth aborts immediately, post-nuke failure has reinstall guidance, stale manifest entry removed, temp dir cleaned, all-plugins mode continues after one failure.\n\n**Tests**: transient retry, retry succeeds, auth abort, post-nuke error message, reinstall command in message, manifest entry removed, temp dir cleaned, all-plugins continues, failed noted in summary.\n\n**Context**: Spec: 3x retry transient, no retry auth. Update adds nuance: files nuked before clone. Failure = degraded state needing recovery guidance.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:46:08Z","updated":"2026-02-18T21:46:08Z"}
{"id":"tick-32d35f","title":"cs-4-10: Update and Remove Output Formatting","status":"open","priority":2,"description":"**Problem**: Remove and update have functional logic but output needs polishing to match spec examples.\n\n**Solution**: Consistent @clack/prompts formatting for both commands. Exact spec message strings for agent compat warnings. Per-agent asset counts matching add command style.\n\n**Outcome**: Both commands produce clear output matching spec. All status variants formatted.\n\n**Do**:\n1. Remove confirmation: files grouped by type (skill dirs, agent files, hook files)\n2. Remove summary: \"Removed {key}\" with counts\n3. Update single: \"Updated {key}[@{ref}]: {old} → {new}\" + per-agent counts (non-zero only)\n4. Update all summary: per-plugin result line per status variant\n5. Agent compat messages match spec exactly: \"Plugin {key} no longer declares support for {agent}...\" and \"Updated for Claude. Codex support removed by plugin author — Codex files removed.\"\n6. Tag info: available tags + re-add command\n7. Spinners during clone/copy, intro/outro bookends\n8. Collection remove: list all affected plugins\n\n**Acceptance Criteria**: Remove files grouped by type, remove summary with counts, update shows commit transition, per-agent counts (non-zero only), tag info with re-add, check-failed noted, local shows re-copy, agent drop warning matches spec text, all up-to-date brief, spinners, intro/outro.\n\n**Tests**: remove file grouping, remove summary, update commit transition, per-agent counts, zero-count omitted, all-plugins per-plugin lines, tag list + re-add, check-failed, local message, agent drop spec text, all up-to-date, spinners, intro/outro, collection lists affected, partial failure distinguished.\n\n**Context**: Spec output examples lines 426-437. Consistent with add command summary style. @clack/prompts throughout.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-d85f8a","created":"2026-02-18T21:46:08Z","updated":"2026-02-18T21:46:08Z"}
{"id":"tick-71886c","title":"Phase 5: List Dashboard and Error Hardening","status":"open","priority":2,"parent":"tick-20aa13","created":"2026-02-18T21:48:24Z","updated":"2026-02-18T21:48:24Z"}
{"id":"tick-0f3e21","title":"cs-5-1: Parallel Update Check for All Plugins","status":"open","priority":2,"description":"**Problem**: List dashboard needs update status for all plugins. checkForUpdate handles one at a time. Need parallel bulk check behind spinner.\n\n**Solution**: Create checkAllForUpdates running checkForUpdate in parallel. Returns Map\u003cstring, UpdateCheckResult\u003e. Local plugins return immediately.\n\n**Outcome**: Tested parallel checker. Individual failures yield check-failed without blocking others. Empty manifest returns empty map.\n\n**Do**:\n1. Create src/update-check-all.ts: checkAllForUpdates(manifest) → Map\u003cstring, UpdateCheckResult\u003e\n2. Promise.all for parallel checks. Individual check failures → check-failed.\n3. Local → immediate (no remote check).\n4. Create tests mocking checkForUpdate\n\n**Acceptance Criteria**: All checked in parallel, individual failures isolated, local skips remote, empty manifest → empty map, mixed statuses handled.\n\n**Tests**: update-available, up-to-date, check-failed on failure, local immediate, empty manifest, all failing, mixed statuses, parallel not sequential, newer-tags for tag-pinned.\n\n**Context**: Spec: spinner then parallel ls-remote. Used by list dashboard and potentially update-all.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:52:23Z","updated":"2026-02-19T11:10:39Z"}
{"id":"tick-b0cb9a","title":"cs-5-2: List View: Plugin List with Status Indicators","status":"open","priority":2,"description":"**Problem**: Phase 1 list is static read-only. Spec requires interactive selectable list with status indicators.\n\n**Solution**: Rewrite list command: readManifest → empty state → checkAllForUpdates with spinner → @clack/prompts select with status indicators → Done exits → selection returns key.\n\n**Outcome**: Interactive list with coloured status indicators. Done exits. Plugin selection enters detail view. Replaces cs-1-11.\n\n**Do**:\n1. Rewrite src/commands/list.ts replacing Phase 1 implementation\n2. Empty manifest → spec message, exit 0\n3. Spinner → checkAllForUpdates → build select options with status indicators per spec table\n4. Done option at bottom. Cancel = Done.\n5. Return selected key for navigation loop\n\n**Acceptance Criteria**: Empty state message, spinner during checks, correct status indicators with colours, ref shown when pinned, Done exits, cancel exits, single plugin shows list.\n\n**Tests**: empty state, spinner, all 5 status indicators, ref display, Done, cancel, single plugin, all-local, long keys.\n\n**Context**: Spec: selectable list, status indicators table, Done at bottom. Replaces cs-1-11.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:52:24Z","updated":"2026-02-18T21:52:24Z"}
{"id":"tick-d19707","title":"cs-5-3: Detail View: Plugin Information Display","status":"open","priority":2,"description":"**Problem**: No detail view when plugin selected. Need to show full info and action options.\n\n**Solution**: Create renderDetailView showing key, ref, commit (7 chars), date, agents, per-agent counts, file list. Actions vary by update status per spec table.\n\n**Outcome**: Detail view renders all info. Actions vary by status. Local/HEAD/tag refs displayed correctly.\n\n**Do**:\n1. Create src/commands/list-detail.ts: renderDetailView({ key, entry, updateStatus }) → Action\n2. Display all fields. Compute asset counts from files array.\n3. Action select per spec status table.\n4. Cancel = Back.\n\n**Acceptance Criteria**: All fields displayed, ref variants correct, commit truncated, counts computed, actions match spec table, cancel = Back.\n\n**Tests**: all fields, local/HEAD/tag refs, commit truncation, asset counts, each action set by status, cancel, many files.\n\n**Context**: Spec detail view: all fields listed. Actions per status table.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:52:24Z","updated":"2026-02-18T21:52:24Z"}
{"id":"tick-9d07b8","title":"cs-5-4: Detail View: Update Action","status":"open","priority":2,"description":"**Problem**: Update action selected from detail view but not wired. Need inline nuke-and-reinstall staying in detail view.\n\n**Solution**: Execute update pipeline inline. Remote: nuke → clone → copy. Local: nuke → re-copy. Refresh detail view with success indicator. Failure shows error, stays in detail.\n\n**Outcome**: Update from detail view works. Refreshes with new data. Handles failures gracefully.\n\n**Do**:\n1. Handle update action in list-detail.ts\n2. Remote: nuke-and-reinstall. Local: re-copy. Reuse Phase 4 logic.\n3. Success: return updated entry for refresh. Failure: show error, stay in detail.\n4. Handle agent compat changes. Spinner during operations.\n\n**Acceptance Criteria**: Nuke-and-reinstall for remote, re-copy for local, detail refreshes on success, error stays in detail, agent compat handled, spinner shown, temp dir cleaned, manifest updated.\n\n**Tests**: remote update, local update, success refresh, failure stays, agent compat, clone failure after nuke, temp dir cleanup.\n\n**Context**: Spec: after Update remain in detail with refreshed info + success indicator. Reuses Phase 4 mechanics.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:52:24Z","updated":"2026-02-18T21:52:24Z"}
{"id":"tick-ba9807","title":"cs-5-5: Detail View: Remove Action","status":"open","priority":2,"description":"**Problem**: Remove action from detail view not wired. Need confirm → nuke → remove entry → return to list.\n\n**Solution**: Show files, confirm, nuke, remove entry, write manifest, return to list with message. Reuse cs-4-1 logic.\n\n**Outcome**: Remove from detail confirms, deletes, returns to list. Last plugin → empty state.\n\n**Do**:\n1. Handle remove action in list-detail.ts\n2. List files, confirm. Declined → Back.\n3. nukeManifestFiles, remove entry, writeManifest.\n4. Return removed action for list navigation.\n\n**Acceptance Criteria**: Files shown, declined = Back, confirmed removes + returns to list, last plugin → empty state, ENOENT tolerance, manifest updated.\n\n**Tests**: confirmation shown, declined, confirmed removes, returns to list, last plugin empty state, ENOENT tolerance, manifest preserves others.\n\n**Context**: Spec: after Remove return to list. Always confirm. Reuses cs-4-1 mechanics.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:52:24Z","updated":"2026-02-18T21:52:24Z"}
{"id":"tick-39a172","title":"cs-5-6: Detail View: Change Version Action","status":"open","priority":2,"description":"**Problem**: Tag-pinned plugins with newer tags need Change version action. Not wired yet.\n\n**Solution**: Fetch tags via ls-remote, present selectable list (newest first), selection triggers nuke-and-reinstall at new tag. Remain in detail view.\n\n**Outcome**: Tag list presented, selection installs new version, detail refreshes. Handles no tags, same tag, hundreds of tags.\n\n**Do**:\n1. Handle change-version in list-detail.ts\n2. Fetch tags, sort newest first. No tags → message, Back. Cancel → Back. Same tag → message, Back.\n3. Different tag: nuke-and-reinstall at new ref. Update manifest.\n\n**Acceptance Criteria**: Tags newest-first, no tags handled, cancel = Back, same tag message, different tag triggers reinstall, manifest updated, detail refreshes.\n\n**Tests**: tags displayed, no tags, cancel, same tag, different tag reinstall, manifest updated, refreshed detail, network failure.\n\n**Context**: Spec: Change version presents tag list. Same nuke-reinstall mechanics with new ref.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:53:06Z","updated":"2026-02-19T11:15:59Z"}
{"id":"tick-bb6c3b","title":"cs-5-7: List Navigation Loop","status":"open","priority":2,"description":"**Problem**: List and detail views exist but no loop connects them. Must re-run command after every action.\n\n**Solution**: While loop: list view → selection → detail → action → route (stay/return/exit). Re-read manifest each iteration. Removing last plugin → empty state.\n\n**Outcome**: Continuous interactive loop. Update/remove/navigate without restarting.\n\n**Do**:\n1. While loop in list.ts\n2. renderListView → Done/cancel = exit. Selection → renderDetailView → action routing.\n3. Back → continue. Removed → re-read manifest, continue. Updated → refresh detail.\n4. Empty manifest after remove → empty state, break.\n\n**Acceptance Criteria**: Back → list, Remove → list (plugin gone), Update → detail refresh, Done exits, cancel exits, last removed → empty state, manifest re-read, successive actions work.\n\n**Tests**: Back to list, Done exits, cancel exits, Remove returns to list, Update refreshes, last plugin → empty, successive actions, no stale data.\n\n**Context**: Spec: post-action routing table. Loop ties cs-5-2 through cs-5-6 together.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:53:06Z","updated":"2026-02-18T21:53:06Z"}
{"id":"tick-95a48e","title":"cs-5-8: Partial Copy Failure Rollback","status":"open","priority":2,"description":"**Problem**: Copy failure midway leaves half-installed plugin. Spec requires rollback.\n\n**Solution**: Track copied paths during copy. On error, delete all tracked paths. Best-effort rollback (ENOENT skip, log other errors). Re-throw original error.\n\n**Outcome**: Copy failure rolls back all files. No manifest entry. Clean state.\n\n**Do**:\n1. Modify copyBareSkill/copyPluginAssets to track copiedFiles progressively\n2. try/catch: on error → rollbackCopiedFiles(tracked, projectDir)\n3. Create src/copy-rollback.ts: delete each path, ENOENT skip, log other errors\n4. Re-throw original error after rollback\n\n**Acceptance Criteria**: Failure triggers rollback, tracked files deleted, ENOENT skipped, rollback failure logged not thrown, original error propagated, no manifest entry, both copy functions support rollback, rollback after overwriting another plugin's file deletes the new copy (previous plugin's asset unrecoverable — accepted edge case per spec, user can update that plugin to restore).\n\n**Tests**: rollback on failure, no manifest entry, original error propagated, ENOENT skipped, rollback failure logged, successful copy unaffected, progressive tracking, both copy functions, rollback after cross-plugin overwrite deletes new copy (accepted loss).\n\n**Context**: Spec: rollback to clean state. Half-installed worse than none. Rollback edge case (cross-plugin overwrite) accepted per spec: \"If a copy fails after overwriting a file owned by another plugin, rollback deletes the new copy but the previous plugin's asset is already gone. Accepted as a narrow edge case — user can update the previous plugin to restore its files.\"\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:53:06Z","updated":"2026-02-19T11:54:48Z"}
{"id":"tick-e908a4","title":"cs-5-9: Multi-Plugin Independent Failure Handling","status":"open","priority":2,"description":"**Problem**: Collection plugin failure can affect others. Need independent processing.\n\n**Solution**: Wrap per-plugin processing in try/catch. Track outcomes (installed/failed/skipped). Failed plugins rolled back. Successful ones keep manifest entries. Single manifest write.\n\n**Outcome**: Fault-tolerant collection installs. Individual failures isolated. Summary shows outcomes.\n\n**Do**:\n1. try/catch per plugin in collection flow\n2. Track outcomes: installed/failed/skipped with details\n3. Failed: rollback (cs-5-8). Successful: collect entry.\n4. Single writeManifest with successful entries only.\n5. All-fail exits 0 with summary.\n\n**Acceptance Criteria**: Each plugin independent, failed rolled back, successful preserved, single manifest write, all-fail exits 0, summary distinguishes outcomes, first succeeds + second fails works.\n\n**Tests**: first succeeds second fails, all fail, rollback on failure, skipped alongside failed, single manifest write, three plugins mixed, all succeed normal.\n\n**Context**: Spec: each plugin independent. Success keeps entry, failure rolls back. Summary per-plugin outcome.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:53:06Z","updated":"2026-02-18T21:53:06Z"}
{"id":"tick-1028ba","title":"cs-5-10: Comprehensive Summary Output","status":"open","priority":2,"description":"**Problem**: Summary output across commands inconsistent. Need unified rendering for all outcome combinations.\n\n**Solution**: Create summary renderer module: renderAddSummary, renderUpdateSummary, renderRemoveSummary. Handles per-plugin outcomes, per-agent counts (non-zero only), all status variants. Wire into all commands.\n\n**Outcome**: All commands produce consistent spec-compliant summaries. Mixed outcomes clearly formatted.\n\n**Do**:\n1. Create src/summary.ts with render functions\n2. Add: key+ref, per-agent counts (non-zero), failed/skipped noted for collections\n3. Update: commit transition, per-plugin status, tag info, agent compat messages\n4. Remove: key + counts\n5. Wire into all commands replacing inline summary code\n\n**Acceptance Criteria**: Add matches spec format, collections show per-plugin, update shows transitions, tag info, agent compat spec text, remove shows counts, no zero-count lines, no empty agent sections, consistent @clack usage.\n\n**Tests**: add format, zero-count omitted, collection summaries, failed/skipped noted, update transitions, tag re-add command, agent drop spec text, remove counts, mixed outcomes, all up-to-date, single plugin concise.\n\n**Context**: Spec summary examples. Consistent across add/remove/update. @clack/prompts throughout.\n\n**Spec Reference**: docs/workflow/specification/core-system/specification.md","parent":"tick-71886c","created":"2026-02-18T21:53:06Z","updated":"2026-02-18T21:53:06Z"}
